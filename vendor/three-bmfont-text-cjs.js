
require.register("bmfont", function(exports, require, module) {
    // Generated by CommonJS Everywhere 0.9.7
    (function (global) {
      function require(file, parentModule) {
        if ({}.hasOwnProperty.call(require.cache, file))
          return require.cache[file];
        var resolved = require.resolve(file);
        if (!resolved)
          throw new Error('Failed to resolve module ' + file);
        var module$ = {
            id: file,
            require: require,
            filename: file,
            exports: {},
            loaded: false,
            parent: parentModule,
            children: []
          };
        if (parentModule)
          parentModule.children.push(module$);
        var dirname = file.slice(0, file.lastIndexOf('/') + 1);
        require.cache[file] = module$.exports;
        resolved.call(module$.exports, module$, module$.exports, dirname, file);
        module$.loaded = true;
        return require.cache[file] = module$.exports;
      }
      require.modules = {};
      require.cache = {};
      require.resolve = function (file) {
        return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
      };
      require.define = function (file, fn) {
        require.modules[file] = fn;
      };
      var process = function () {
          var cwd = '/';
          return {
            title: 'browser',
            version: 'v0.12.4',
            browser: true,
            env: {},
            argv: [],
            nextTick: global.setImmediate || function (fn) {
              setTimeout(fn, 0);
            },
            cwd: function () {
              return cwd;
            },
            chdir: function (dir) {
              cwd = dir;
            }
          };
        }();
      require.define('/index.js', function (module, exports, __dirname, __filename) {
        var layout = require('/node_modules/layout-bmfont-text/index.js', module);
        var render = require('/node_modules/three-bmfont-text/index.js', module);
        module.exports = {
          layout: layout,
          render: render
        };
      });
      require.define('/node_modules/three-bmfont-text/index.js', function (module, exports, __dirname, __filename) {
        var createLayout = require('/node_modules/layout-bmfont-text/index.js', module);
        var inherits = require('/node_modules/three-bmfont-text/node_modules/inherits/inherits.js', module);
        var createIndices = require('/node_modules/three-bmfont-text/node_modules/quad-indices/index.js', module);
        var utils = require('/node_modules/three-bmfont-text/lib/utils.js', module);
        var THREE = window.THREE;
        var Base = THREE.BufferGeometry;
        module.exports = function (opt) {
          return new TextMesh(opt);
        };
        function TextMesh(opt) {
          Base.call(this);
          var multipage = opt && opt.multipage;
          this.layout = null;
          this._positions = new THREE.BufferAttribute(null, 2);
          this._uvs = new THREE.BufferAttribute(null, 2);
          if (multipage)
            this._pages = new THREE.BufferAttribute(null, 1);
          this._indices = new THREE.BufferAttribute(null, 1);
          if (opt)
            this.update(opt);
          this.addAttribute('position', this._positions);
          this.addAttribute('uv', this._uvs);
          if (multipage)
            this.addAttribute('page', this._pages);
          this.addAttribute('index', this._indices);
        }
        inherits(TextMesh, Base);
        TextMesh.prototype.update = function (opt) {
          opt = opt || {};
          this.layout = createLayout(opt);
          if (opt.multipage && !this._pages) {
            throw new Error('must specify multipage: true in constructor');
          }
          var font = opt.font;
          var texWidth = font.common.scaleW;
          var texHeight = font.common.scaleH;
          var glyphs = this.layout.glyphs.filter(function (glyph) {
              var bitmap = glyph.data;
              return bitmap.width * bitmap.height > 0;
            });
          var positions = getQuadPositions(glyphs, this.layout);
          var flipY = opt.flipY !== false;
          var uvs = getQuadUVs(glyphs, texWidth, texHeight, flipY);
          if (opt.multipage) {
            var pages = getQuadPages(glyphs);
            this._pages.array = pages;
            this._pages.needsUpdate = true;
          }
          var quadCount = glyphs.length;
          var indices = createIndices({
              clockwise: true,
              count: quadCount
            });
          this._uvs.array = uvs;
          this._uvs.needsUpdate = true;
          this._indices.array = indices;
          this._indices.needsUpdate = true;
          this._positions.array = positions;
          this._positions.needsUpdate = true;
        };
        TextMesh.prototype.computeBoundingSphere = function () {
          if (this.boundingSphere === null)
            this.boundingSphere = new THREE.Sphere;
          var positions = this.attributes.position.array;
          var itemSize = this.attributes.position.itemSize;
          if (!positions || !itemSize || positions.length < 2) {
            this.boundingSphere.radius = 0;
            this.boundingSphere.center.set(0, 0, 0);
            return;
          }
          utils.computeSphere(positions, this.boundingSphere);
          if (isNaN(this.boundingSphere.radius))
            console.error('THREE.BufferGeometry.computeBoundingSphere(): ' + 'Computed radius is NaN. The ' + '"position" attribute is likely to have NaN values.');
        };
        TextMesh.prototype.computeBoundingBox = function () {
          if (this.boundingBox === null)
            this.boundingBox = new THREE.Box3;
          var bbox = this.boundingBox;
          var positions = this.attributes.position.array;
          var itemSize = this.attributes.position.itemSize;
          if (!positions || !itemSize || positions.length < 2) {
            bbox.makeEmpty();
            return;
          }
          utils.computeBox(positions, bbox);
        };
        function getQuadPages(glyphs) {
          var pages = new Float32Array(glyphs.length * 4 * 1);
          var i = 0;
          glyphs.forEach(function (glyph) {
            var id = glyph.data.page || 0;
            pages[i++] = id;
            pages[i++] = id;
            pages[i++] = id;
            pages[i++] = id;
          });
          return pages;
        }
        function getQuadUVs(glyphs, texWidth, texHeight, flipY) {
          var uvs = new Float32Array(glyphs.length * 4 * 2);
          var i = 0;
          glyphs.forEach(function (glyph) {
            var bitmap = glyph.data;
            var bw = bitmap.x + bitmap.width;
            var bh = bitmap.y + bitmap.height;
            var u0 = bitmap.x / texWidth;
            var v1 = bitmap.y / texHeight;
            var u1 = bw / texWidth;
            var v0 = bh / texHeight;
            if (flipY) {
              v1 = (texHeight - bitmap.y) / texHeight;
              v0 = (texHeight - bh) / texHeight;
            }
            uvs[i++] = u0;
            uvs[i++] = v1;
            uvs[i++] = u0;
            uvs[i++] = v0;
            uvs[i++] = u1;
            uvs[i++] = v0;
            uvs[i++] = u1;
            uvs[i++] = v1;
          });
          return uvs;
        }
        function getQuadPositions(glyphs, layout) {
          var positions = new Float32Array(glyphs.length * 4 * 2);
          var i = 0;
          glyphs.forEach(function (glyph) {
            var bitmap = glyph.data;
            var x = glyph.position[0] + bitmap.xoffset;
            var y = glyph.position[1] + bitmap.yoffset;
            var w = bitmap.width;
            var h = bitmap.height;
            positions[i++] = x;
            positions[i++] = y;
            positions[i++] = x;
            positions[i++] = y + h;
            positions[i++] = x + w;
            positions[i++] = y + h;
            positions[i++] = x + w;
            positions[i++] = y;
          });
          return positions;
        }
      });
      require.define('/node_modules/three-bmfont-text/lib/utils.js', function (module, exports, __dirname, __filename) {
        var itemSize = 2;
        var box = {
            min: [
              0,
              0
            ],
            max: [
              0,
              0
            ]
          };
        function bounds(positions) {
          var count = positions.length / itemSize;
          box.min[0] = positions[0];
          box.min[1] = positions[1];
          box.max[0] = positions[0];
          box.max[1] = positions[1];
          for (var i = 0; i < count; i++) {
            var x = positions[i * itemSize + 0];
            var y = positions[i * itemSize + 1];
            box.min[0] = Math.min(x, box.min[0]);
            box.min[1] = Math.min(y, box.min[1]);
            box.max[0] = Math.max(x, box.max[0]);
            box.max[1] = Math.max(y, box.max[1]);
          }
        }
        module.exports.computeBox = function (positions, output) {
          bounds(positions);
          output.min.set(box.min[0], box.min[1], 0);
          output.max.set(box.max[0], box.max[1], 0);
        };
        module.exports.computeSphere = function (positions, output) {
          bounds(positions);
          var minX = box.min[0], minY = box.min[1], maxX = box.max[0], maxY = box.max[1], width = maxX - minX, height = maxY - minY, length = Math.sqrt(width * width + height * height);
          output.center.set(minX + width / 2, minY + height / 2, 0);
          output.radius = length / 2;
        };
      });
      require.define('/node_modules/three-bmfont-text/node_modules/quad-indices/index.js', function (module, exports, __dirname, __filename) {
        var dtype = require('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/dtype/index.js', module);
        var anArray = require('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/an-array/index.js', module);
        var isBuffer = require('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/is-buffer/index.js', module);
        var CW = [
            0,
            2,
            3
          ];
        var CCW = [
            2,
            1,
            3
          ];
        module.exports = function createQuadElements(array, opt) {
          if (!array || !(anArray(array) || isBuffer(array))) {
            opt = array || {};
            array = null;
          }
          if (typeof opt === 'number')
            opt = { count: opt };
          else
            opt = opt || {};
          var type = typeof opt.type === 'string' ? opt.type : 'uint16';
          var count = typeof opt.count === 'number' ? opt.count : 1;
          var start = opt.start || 0;
          var dir = opt.clockwise !== false ? CW : CCW, a = dir[0], b = dir[1], c = dir[2];
          var numIndices = count * 6;
          var indices = array || new (dtype(type))(numIndices);
          for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {
            var x = i + start;
            indices[x + 0] = j + 0;
            indices[x + 1] = j + 1;
            indices[x + 2] = j + 2;
            indices[x + 3] = j + a;
            indices[x + 4] = j + b;
            indices[x + 5] = j + c;
          }
          return indices;
        };
      });
      require.define('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/is-buffer/index.js', function (module, exports, __dirname, __filename) {
        module.exports = function (obj) {
          return !!(obj != null && obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj));
        };
      });
      require.define('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/an-array/index.js', function (module, exports, __dirname, __filename) {
        var str = Object.prototype.toString;
        module.exports = anArray;
        function anArray(arr) {
          return arr.BYTES_PER_ELEMENT && str.call(arr.buffer) === '[object ArrayBuffer]' || Array.isArray(arr);
        }
      });
      require.define('/node_modules/three-bmfont-text/node_modules/quad-indices/node_modules/dtype/index.js', function (module, exports, __dirname, __filename) {
        module.exports = function (dtype) {
          switch (dtype) {
          case 'int8':
            return Int8Array;
          case 'int16':
            return Int16Array;
          case 'int32':
            return Int32Array;
          case 'uint8':
            return Uint8Array;
          case 'uint16':
            return Uint16Array;
          case 'uint32':
            return Uint32Array;
          case 'float32':
            return Float32Array;
          case 'float64':
            return Float64Array;
          case 'array':
            return Array;
          case 'uint8_clamped':
            return Uint8ClampedArray;
          }
        };
      });
      require.define('/node_modules/three-bmfont-text/node_modules/inherits/inherits.js', function (module, exports, __dirname, __filename) {
        module.exports = require('util', module).inherits;
      });
      require.define('util', function (module, exports, __dirname, __filename) {
        var formatRegExp = /%[sdj%]/g;
        exports.format = function (f) {
          if (typeof f !== 'string') {
            var objects = [];
            for (var i = 0; i < arguments.length; i++) {
              objects.push(inspect(arguments[i]));
            }
            return objects.join(' ');
          }
          var i = 1;
          var args = arguments;
          var len = args.length;
          var str = String(f).replace(formatRegExp, function (x) {
              if (x === '%%')
                return '%';
              if (i >= len)
                return x;
              switch (x) {
              case '%s':
                return String(args[i++]);
              case '%d':
                return Number(args[i++]);
              case '%j':
                return JSON.stringify(args[i++]);
              default:
                return x;
              }
            });
          for (var x = args[i]; i < len; x = args[++i]) {
            if (x === null || typeof x !== 'object') {
              str += ' ' + x;
            } else {
              str += ' ' + inspect(x);
            }
          }
          return str;
        };
        exports.deprecate = function (fn, msg) {
          if (process.noDeprecation === true) {
            return fn;
          }
          var warned = false;
          function deprecated() {
            if (!warned) {
              if (process.throwDeprecation) {
                throw new Error(msg);
              } else if (process.traceDeprecation) {
                console.trace(msg);
              } else {
                console.error(msg);
              }
              warned = true;
            }
            return fn.apply(this, arguments);
          }
          return deprecated;
        };
        exports.print = function () {
          for (var i = 0, len = arguments.length; i < len; ++i) {
            process.stdout.write(String(arguments[i]));
          }
        };
        exports.puts = function () {
          for (var i = 0, len = arguments.length; i < len; ++i) {
            process.stdout.write(arguments[i] + '\n');
          }
        };
        exports.debug = function (x) {
          process.stderr.write('DEBUG: ' + x + '\n');
        };
        var error = exports.error = function (x) {
            for (var i = 0, len = arguments.length; i < len; ++i) {
              process.stderr.write(arguments[i] + '\n');
            }
          };
        function inspect(obj, opts) {
          var ctx = {
              seen: [],
              stylize: stylizeNoColor
            };
          if (arguments.length >= 3)
            ctx.depth = arguments[2];
          if (arguments.length >= 4)
            ctx.colors = arguments[3];
          if (typeof opts === 'boolean') {
            ctx.showHidden = opts;
          } else if (opts) {
            exports._extend(ctx, opts);
          }
          if (typeof ctx.showHidden === 'undefined')
            ctx.showHidden = false;
          if (typeof ctx.depth === 'undefined')
            ctx.depth = 2;
          if (typeof ctx.colors === 'undefined')
            ctx.colors = false;
          if (typeof ctx.customInspect === 'undefined')
            ctx.customInspect = true;
          if (ctx.colors)
            ctx.stylize = stylizeWithColor;
          return formatValue(ctx, obj, ctx.depth);
        }
        exports.inspect = inspect;
        inspect.colors = {
          'bold': [
            1,
            22
          ],
          'italic': [
            3,
            23
          ],
          'underline': [
            4,
            24
          ],
          'inverse': [
            7,
            27
          ],
          'white': [
            37,
            39
          ],
          'grey': [
            90,
            39
          ],
          'black': [
            30,
            39
          ],
          'blue': [
            34,
            39
          ],
          'cyan': [
            36,
            39
          ],
          'green': [
            32,
            39
          ],
          'magenta': [
            35,
            39
          ],
          'red': [
            31,
            39
          ],
          'yellow': [
            33,
            39
          ]
        };
        inspect.styles = {
          'special': 'cyan',
          'number': 'yellow',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          'regexp': 'red'
        };
        function stylizeWithColor(str, styleType) {
          var style = inspect.styles[styleType];
          if (style) {
            return '\x1B[' + inspect.colors[style][0] + 'm' + str + '\x1B[' + inspect.colors[style][1] + 'm';
          } else {
            return str;
          }
        }
        function stylizeNoColor(str, styleType) {
          return str;
        }
        function arrayToHash(array) {
          var hash = {};
          array.forEach(function (val, idx) {
            hash[val] = true;
          });
          return hash;
        }
        function formatValue(ctx, value, recurseTimes) {
          if (ctx.customInspect && value && typeof value.inspect === 'function' && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
            return String(value.inspect(recurseTimes));
          }
          var primitive = formatPrimitive(ctx, value);
          if (primitive) {
            return primitive;
          }
          var keys = Object.keys(value);
          var visibleKeys = arrayToHash(keys);
          if (ctx.showHidden) {
            keys = Object.getOwnPropertyNames(value);
          }
          if (keys.length === 0) {
            if (typeof value === 'function') {
              var name = value.name ? ': ' + value.name : '';
              return ctx.stylize('[Function' + name + ']', 'special');
            }
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            }
            if (isDate(value)) {
              return ctx.stylize(Date.prototype.toString.call(value), 'date');
            }
            if (isError(value)) {
              return formatError(value);
            }
          }
          var base = '', array = false, braces = [
              '{',
              '}'
            ];
          if (isArray(value)) {
            array = true;
            braces = [
              '[',
              ']'
            ];
          }
          if (typeof value === 'function') {
            var n = value.name ? ': ' + value.name : '';
            base = ' [Function' + n + ']';
          }
          if (isRegExp(value)) {
            base = ' ' + RegExp.prototype.toString.call(value);
          }
          if (isDate(value)) {
            base = ' ' + Date.prototype.toUTCString.call(value);
          }
          if (isError(value)) {
            base = ' ' + formatError(value);
          }
          if (keys.length === 0 && (!array || value.length == 0)) {
            return braces[0] + base + braces[1];
          }
          if (recurseTimes < 0) {
            if (isRegExp(value)) {
              return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
            } else {
              return ctx.stylize('[Object]', 'special');
            }
          }
          ctx.seen.push(value);
          var output;
          if (array) {
            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
          } else {
            output = keys.map(function (key) {
              return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
            });
          }
          ctx.seen.pop();
          return reduceToSingleString(output, base, braces);
        }
        function formatPrimitive(ctx, value) {
          switch (typeof value) {
          case 'undefined':
            return ctx.stylize('undefined', 'undefined');
          case 'string':
            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
            return ctx.stylize(simple, 'string');
          case 'number':
            return ctx.stylize('' + value, 'number');
          case 'boolean':
            return ctx.stylize('' + value, 'boolean');
          }
          if (value === null) {
            return ctx.stylize('null', 'null');
          }
        }
        function formatError(value) {
          return '[' + Error.prototype.toString.call(value) + ']';
        }
        function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
          var output = [];
          for (var i = 0, l = value.length; i < l; ++i) {
            if (hasOwnProperty(value, String(i))) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
            } else {
              output.push('');
            }
          }
          keys.forEach(function (key) {
            if (!key.match(/^\d+$/)) {
              output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
            }
          });
          return output;
        }
        function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
          var name, str, desc;
          desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
          if (desc.get) {
            if (desc.set) {
              str = ctx.stylize('[Getter/Setter]', 'special');
            } else {
              str = ctx.stylize('[Getter]', 'special');
            }
          } else {
            if (desc.set) {
              str = ctx.stylize('[Setter]', 'special');
            }
          }
          if (!hasOwnProperty(visibleKeys, key)) {
            name = '[' + key + ']';
          }
          if (!str) {
            if (ctx.seen.indexOf(desc.value) < 0) {
              if (recurseTimes === null) {
                str = formatValue(ctx, desc.value, null);
              } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
              }
              if (str.indexOf('\n') > -1) {
                if (array) {
                  str = str.split('\n').map(function (line) {
                    return '  ' + line;
                  }).join('\n').substr(2);
                } else {
                  str = '\n' + str.split('\n').map(function (line) {
                    return '   ' + line;
                  }).join('\n');
                }
              }
            } else {
              str = ctx.stylize('[Circular]', 'special');
            }
          }
          if (typeof name === 'undefined') {
            if (array && key.match(/^\d+$/)) {
              return str;
            }
            name = JSON.stringify('' + key);
            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
              name = name.substr(1, name.length - 2);
              name = ctx.stylize(name, 'name');
            } else {
              name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
              name = ctx.stylize(name, 'string');
            }
          }
          return name + ': ' + str;
        }
        function reduceToSingleString(output, base, braces) {
          var numLinesEst = 0;
          var length = output.reduce(function (prev, cur) {
              numLinesEst++;
              if (cur.indexOf('\n') >= 0)
                numLinesEst++;
              return prev + cur.length + 1;
            }, 0);
          if (length > 60) {
            return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
          }
          return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
        }
        function isArray(ar) {
          return Array.isArray(ar) || typeof ar === 'object' && objectToString(ar) === '[object Array]';
        }
        exports.isArray = isArray;
        function isRegExp(re) {
          return typeof re === 'object' && objectToString(re) === '[object RegExp]';
        }
        exports.isRegExp = isRegExp;
        function isDate(d) {
          return typeof d === 'object' && objectToString(d) === '[object Date]';
        }
        exports.isDate = isDate;
        function isError(e) {
          return typeof e === 'object' && objectToString(e) === '[object Error]';
        }
        exports.isError = isError;
        function objectToString(o) {
          return Object.prototype.toString.call(o);
        }
        exports.p = exports.deprecate(function () {
          for (var i = 0, len = arguments.length; i < len; ++i) {
            error(exports.inspect(arguments[i]));
          }
        }, 'util.p: Use console.error() instead.');
        function pad(n) {
          return n < 10 ? '0' + n.toString(10) : n.toString(10);
        }
        var months = [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
          ];
        function timestamp() {
          var d = new Date;
          var time = [
              pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())
            ].join(':');
          return [
            d.getDate(),
            months[d.getMonth()],
            time
          ].join(' ');
        }
        exports.log = function (msg) {
          exports.puts(timestamp() + ' - ' + msg.toString());
        };
        exports.exec = exports.deprecate(function () {
          return null.exec.apply(this, arguments);
        }, 'util.exec is now called `child_process.exec`.');
        function pump(readStream, writeStream, callback) {
          var callbackCalled = false;
          function call(a, b, c) {
            if (callback && !callbackCalled) {
              callback(a, b, c);
              callbackCalled = true;
            }
          }
          readStream.addListener('data', function (chunk) {
            if (writeStream.write(chunk) === false)
              readStream.pause();
          });
          writeStream.addListener('drain', function () {
            readStream.resume();
          });
          readStream.addListener('end', function () {
            writeStream.end();
          });
          readStream.addListener('close', function () {
            call();
          });
          readStream.addListener('error', function (err) {
            writeStream.end();
            call(err);
          });
          writeStream.addListener('error', function (err) {
            readStream.destroy();
            call(err);
          });
        }
        exports.pump = exports.deprecate(pump, 'util.pump() is deprecated. Use readableStream.pipe() instead.');
        exports.inherits = function (ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
        exports._extend = function (origin, add) {
          if (!add || typeof add !== 'object')
            return origin;
          var keys = Object.keys(add);
          var i = keys.length;
          while (i--) {
            origin[keys[i]] = add[keys[i]];
          }
          return origin;
        };
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
      });
      require.define('/node_modules/layout-bmfont-text/index.js', function (module, exports, __dirname, __filename) {
        var wordWrap = require('/node_modules/layout-bmfont-text/node_modules/word-wrapper/index.js', module);
        var xtend = require('/node_modules/xtend/immutable.js', module);
        var findChar = require('/node_modules/layout-bmfont-text/node_modules/indexof-property/index.js', module)('id');
        var number = require('/node_modules/layout-bmfont-text/node_modules/as-number/index.js', module);
        var X_HEIGHTS = [
            'x',
            'e',
            'a',
            'o',
            'n',
            's',
            'r',
            'c',
            'u',
            'm',
            'v',
            'w',
            'z'
          ];
        var M_WIDTHS = [
            'm',
            'w'
          ];
        var CAP_HEIGHTS = [
            'H',
            'I',
            'N',
            'E',
            'F',
            'K',
            'L',
            'T',
            'U',
            'V',
            'W',
            'X',
            'Y',
            'Z'
          ];
        var TAB_ID = '\t'.charCodeAt(0);
        var SPACE_ID = ' '.charCodeAt(0);
        var ALIGN_LEFT = 0, ALIGN_CENTER = 1, ALIGN_RIGHT = 2;
        module.exports = function createLayout(opt) {
          return new TextLayout(opt);
        };
        function TextLayout(opt) {
          this.glyphs = [];
          this._measure = this.computeMetrics.bind(this);
          this.update(opt);
        }
        TextLayout.prototype.update = function (opt) {
          opt = xtend({ measure: this._measure }, opt);
          this._opt = opt;
          this._opt.tabSize = number(this._opt.tabSize, 4);
          if (!opt.font)
            throw new Error('must provide a valid bitmap font');
          var glyphs = this.glyphs;
          var text = opt.text || '';
          var font = opt.font;
          this._setupSpaceGlyphs(font);
          var lines = wordWrap.lines(text, opt);
          var minWidth = opt.width || 0;
          glyphs.length = 0;
          var maxLineWidth = lines.reduce(function (prev, line) {
              return Math.max(prev, line.width, minWidth);
            }, 0);
          var x = 0;
          var y = 0;
          var chars = font.chars;
          var lineHeight = number(opt.lineHeight, font.common.lineHeight);
          var baseline = font.common.base;
          var descender = lineHeight - baseline;
          var letterSpacing = opt.letterSpacing || 0;
          var height = lineHeight * lines.length - descender;
          var align = getAlignType(this._opt.align);
          y -= height;
          this._width = maxLineWidth;
          this._height = height;
          this._descender = font.common.lineHeight - baseline;
          this._baseline = baseline;
          this._xHeight = getXHeight(font);
          this._capHeight = getCapHeight(font);
          this._lineHeight = lineHeight;
          this._ascender = lineHeight - descender - this._xHeight;
          var self = this;
          lines.forEach(function (line) {
            var start = line.start;
            var end = line.end;
            var lineWidth = line.width;
            var lastGlyph;
            for (var i = start; i < end; i++) {
              var id = text.charCodeAt(i);
              var glyph = self.getGlyph(font, id);
              if (glyph) {
                if (lastGlyph)
                  x += getKerning(font, lastGlyph.id, glyph.id);
                var tx = x;
                if (align === ALIGN_CENTER)
                  tx += (maxLineWidth - lineWidth) / 2;
                else if (align === ALIGN_RIGHT)
                  tx += maxLineWidth - lineWidth;
                glyphs.push({
                  position: [
                    tx,
                    y
                  ],
                  data: glyph,
                  index: i
                });
                x += glyph.xadvance + letterSpacing;
                lastGlyph = glyph;
              }
            }
            y += lineHeight;
            x = 0;
          });
        };
        TextLayout.prototype._setupSpaceGlyphs = function (font) {
          this._fallbackSpaceGlyph = null;
          this._fallbackTabGlyph = null;
          if (!font.chars || font.chars.length === 0)
            return;
          var space = getGlyphById(font, SPACE_ID) || getMGlyph(font) || font.chars[0];
          var tabWidth = this._opt.tabSize * space.xadvance;
          this._fallbackSpaceGlyph = space;
          this._fallbackTabGlyph = xtend(space, {
            x: 0,
            y: 0,
            xadvance: tabWidth,
            id: TAB_ID,
            xoffset: 0,
            yoffset: 0,
            width: 0,
            height: 0
          });
        };
        TextLayout.prototype.getGlyph = function (font, id) {
          var glyph = getGlyphById(font, id);
          if (glyph)
            return glyph;
          else if (id === TAB_ID)
            return this._fallbackTabGlyph;
          else if (id === SPACE_ID)
            return this._fallbackSpaceGlyph;
          return null;
        };
        TextLayout.prototype.computeMetrics = function (text, start, end, width) {
          var letterSpacing = this._opt.letterSpacing || 0;
          var font = this._opt.font;
          var curPen = 0;
          var curWidth = 0;
          var count = 0;
          var glyph;
          var lastGlyph;
          if (!font.chars || font.chars.length === 0) {
            return {
              start: start,
              end: start,
              width: 0
            };
          }
          end = Math.min(text.length, end);
          for (var i = start; i < end; i++) {
            var id = text.charCodeAt(i);
            var glyph = this.getGlyph(font, id);
            if (glyph) {
              var xoff = glyph.xoffset;
              var kern = lastGlyph ? getKerning(font, lastGlyph.id, glyph.id) : 0;
              curPen += kern;
              var nextPen = curPen + glyph.xadvance + letterSpacing;
              var nextWidth = curPen + glyph.width;
              if (nextWidth >= width || nextPen >= width)
                break;
              curPen = nextPen;
              curWidth = nextWidth;
              lastGlyph = glyph;
            }
            count++;
          }
          if (lastGlyph)
            curWidth += lastGlyph.xoffset;
          return {
            start: start,
            end: start + count,
            width: curWidth
          };
        };
        [
          'width',
          'height',
          'descender',
          'ascender',
          'xHeight',
          'baseline',
          'capHeight',
          'lineHeight'
        ].forEach(addGetter);
        function addGetter(name) {
          Object.defineProperty(TextLayout.prototype, name, {
            get: wrapper(name),
            configurable: true
          });
        }
        function wrapper(name) {
          return new Function([
            'return function ' + name + '() {',
            '  return this._' + name,
            '}'
          ].join('\n'))();
        }
        function getGlyphById(font, id) {
          if (!font.chars || font.chars.length === 0)
            return null;
          var glyphIdx = findChar(font.chars, id);
          if (glyphIdx >= 0)
            return font.chars[glyphIdx];
          return null;
        }
        function getXHeight(font) {
          for (var i = 0; i < X_HEIGHTS.length; i++) {
            var id = X_HEIGHTS[i].charCodeAt(0);
            var idx = findChar(font.chars, id);
            if (idx >= 0)
              return font.chars[idx].height;
          }
          return 0;
        }
        function getMGlyph(font) {
          for (var i = 0; i < M_WIDTHS.length; i++) {
            var id = M_WIDTHS[i].charCodeAt(0);
            var idx = findChar(font.chars, id);
            if (idx >= 0)
              return font.chars[idx];
          }
          return 0;
        }
        function getCapHeight(font) {
          for (var i = 0; i < CAP_HEIGHTS.length; i++) {
            var id = CAP_HEIGHTS[i].charCodeAt(0);
            var idx = findChar(font.chars, id);
            if (idx >= 0)
              return font.chars[idx].height;
          }
          return 0;
        }
        function getKerning(font, left, right) {
          if (!font.kernings || font.kernings.length === 0)
            return 0;
          var table = font.kernings;
          for (var i = 0; i < table.length; i++) {
            var kern = table[i];
            if (kern.first === left && kern.second === right)
              return kern.amount;
          }
          return 0;
        }
        function getAlignType(align) {
          if (align === 'center')
            return ALIGN_CENTER;
          else if (align === 'right')
            return ALIGN_RIGHT;
          return ALIGN_LEFT;
        }
      });
      require.define('/node_modules/layout-bmfont-text/node_modules/as-number/index.js', function (module, exports, __dirname, __filename) {
        module.exports = function numtype(num, def) {
          return typeof num === 'number' ? num : typeof def === 'number' ? def : 0;
        };
      });
      require.define('/node_modules/layout-bmfont-text/node_modules/indexof-property/index.js', function (module, exports, __dirname, __filename) {
        module.exports = function compile(property) {
          if (!property || typeof property !== 'string')
            throw new Error('must specify property for indexof search');
          return new Function('array', 'value', 'start', [
            'start = start || 0',
            'for (var i=start; i<array.length; i++)',
            '  if (array[i]["' + property + '"] === value)',
            '      return i',
            'return -1'
          ].join('\n'));
        };
      });
      require.define('/node_modules/xtend/immutable.js', function (module, exports, __dirname, __filename) {
        module.exports = extend;
        function extend() {
          var target = {};
          for (var i = 0; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (source.hasOwnProperty(key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        }
      });
      require.define('/node_modules/layout-bmfont-text/node_modules/word-wrapper/index.js', function (module, exports, __dirname, __filename) {
        var newline = /\n/;
        var newlineChar = '\n';
        var whitespace = /\s/;
        module.exports = function (text, opt) {
          var lines = module.exports.lines(text, opt);
          return lines.map(function (line) {
            return text.substring(line.start, line.end);
          }).join('\n');
        };
        module.exports.lines = function wordwrap(text, opt) {
          opt = opt || {};
          if (opt.width === 0 && opt.mode !== 'nowrap')
            return [];
          text = text || '';
          var width = typeof opt.width === 'number' ? opt.width : Number.MAX_VALUE;
          var start = Math.max(0, opt.start || 0);
          var end = typeof opt.end === 'number' ? opt.end : text.length;
          var mode = opt.mode;
          var measure = opt.measure || monospace;
          if (mode === 'pre')
            return pre(measure, text, start, end, width);
          else
            return greedy(measure, text, start, end, width, mode);
        };
        function idxOf(text, chr, start, end) {
          var idx = text.indexOf(chr, start);
          if (idx === -1 || idx > end)
            return end;
          return idx;
        }
        function isWhitespace(chr) {
          return whitespace.test(chr);
        }
        function pre(measure, text, start, end, width) {
          var lines = [];
          var lineStart = start;
          for (var i = start; i < end && i < text.length; i++) {
            var chr = text.charAt(i);
            var isNewline = newline.test(chr);
            if (isNewline || i === end - 1) {
              var lineEnd = isNewline ? i : i + 1;
              var measured = measure(text, lineStart, lineEnd, width);
              lines.push(measured);
              lineStart = i + 1;
            }
          }
          return lines;
        }
        function greedy(measure, text, start, end, width, mode) {
          var lines = [];
          var testWidth = width;
          if (mode === 'nowrap')
            testWidth = Number.MAX_VALUE;
          while (start < end && start < text.length) {
            var newLine = idxOf(text, newlineChar, start, end);
            while (start < newLine) {
              if (!isWhitespace(text.charAt(start)))
                break;
              start++;
            }
            var measured = measure(text, start, newLine, testWidth);
            var lineEnd = start + (measured.end - measured.start);
            var nextStart = lineEnd + newlineChar.length;
            if (lineEnd < newLine) {
              while (lineEnd > start) {
                if (isWhitespace(text.charAt(lineEnd)))
                  break;
                lineEnd--;
              }
              if (lineEnd === start) {
                if (nextStart > start + newlineChar.length)
                  nextStart--;
                lineEnd = nextStart;
              } else {
                nextStart = lineEnd;
                while (lineEnd > start) {
                  if (!isWhitespace(text.charAt(lineEnd - newlineChar.length)))
                    break;
                  lineEnd--;
                }
              }
            }
            if (lineEnd >= start) {
              var result = measure(text, start, lineEnd, testWidth);
              lines.push(result);
            }
            start = nextStart;
          }
          return lines;
        }
        function monospace(text, start, end, width) {
          var glyphs = Math.min(width, end - start);
          return {
            start: start,
            end: start + glyphs
          };
        }
      });
      module.exports = require('/index.js');
    }.call(window, exports));
});