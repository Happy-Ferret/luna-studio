
def null self::Std a::a -> a:
    a

def print self msg::String:
    ```autoLift1 print #{msg}```

class ```Bool```:
    True
    False

def Bool.toString self::Bool -> String:
    ```liftF1 show #{self}```

class ```Maybe``` a:
    Just:
        unwrap :: a
    Nothing

class ```Either``` a b:
    Left: l :: a
    Right: r :: b

# CHAR

def Char.toString self::Char -> String:
    ```liftF2 (:) #{self} (val ([] :: String))```

# INT

def Int.+ self::Int a::Int -> Int:
    ```liftF2 (+) #{self} #{a}```

def Int.- self::Int a::Int -> Int:
    ```liftF2 (-) #{self} #{a}```

def Int.* self::Int a::Int -> Int:
    ```liftF2 (*) #{self} #{a}```

def Int./ self::Int a::Int -> Int:
    ```liftF2 (/) #{self} #{a}```

def Int.> self::Int a::Int -> Bool:
    ```liftF2 (>) #{self} #{a}```

def Int.== self::Int a::Int -> Bool:
    ```liftF2 (==) #{self} #{a}```

def Int.< self::Int a::Int -> Bool:
    ```liftF2 (<) #{self} #{a}```

def Int.<= self::Int a::Int -> Bool:
    ```liftF2 (<=) #{self} #{a}```

def Int.>= self::Int a::Int -> Bool:
    ```liftF2 (>=) #{self} #{a}```

# def Int.inc:
#     self.add 1

# def Int.dec:
#     self.sub 1

def Int.fromIntegral self::Int -> Float:
    ```liftF1 fromIntegral #{self} :: Value Pure Safe Float```

def Int.toString self::Int -> String:
    ```liftF1 show #{self}```

# DOUBLE / FLOAT

def Float.acc:
    ```liftF1 variable #{self}```

def Float.truncate self::Float -> Int:
    ```liftF1 truncate #{self} :: Value Pure Safe Int```

def Float.round self::Float -> Int:
    ```liftF1 round #{self} :: Value Pure Safe Int```

def Float.floor self::Float -> Int:
    ```liftF1 floor #{self} :: Value Pure Safe Int```

def Float.ceiling self::Float -> Int:
    ```liftF1 ceiling #{self} :: Value Pure Safe Int```

def Float.+ self::Float a::Float -> Float:
    ```liftF2 (+) #{self} #{a}```

def Float.- self::Float a::Float -> Float:
    ```liftF2 (-) #{self} #{a}```

def Float.* self::Float a::Float -> Float:
    ```liftF2 (*) #{self} #{a}```

def Float./ self::Float a::Float -> Float:
    ```liftF2 (/) #{self} #{a}```

def Float.> self::Float a::Float -> Bool:
    ```liftF2 (>) #{self} #{a}```

def Float.== self::Float a::Float -> Bool:
    ```liftF2 (==) #{self} #{a}```

def Float.< self::Float a::Float -> Bool:
    ```liftF2 (<) #{self} #{a}```

def Float.<= self::Float a::Float -> Bool:
    ```liftF2 (<=) #{self} #{a}```

def Float.>= self::Float a::Float -> Bool:
    ```liftF2 (>=) #{self} #{a}```

def Float.toString self::Float -> String:
    ```liftF1 show #{self}```

alias FilePath = String

class Image

def emptyImage self::Std -> Image:
    ```liftF0 Image.empty```

def load self::Std path::FilePath -> Image:
    ```autoLift1 realReadLuna #{path}```

def Image.save self::Image path::FilePath -> Image:
    ```autoLift2 saveImageLuna #{path} #{self}```

# def Image.defocus self::Image radius::Int:
#     ```liftF2 defocus #{radius} #{self}```

# def Image.motionBlur self::Image size::Int angle::Float:
#     ```liftF3 motionBlur #{size} #{angle} #{self}```

# def Image.bilateral self::Image psigma::Float csigma::Float size::Int:
#     ```liftF4 bilateral #{psigma} #{csigma} #{size} #{self}```

def Image.offset self::Image value::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 offsetLuna #{value} #{matte} #{self}```

def Image.contrast self::Image value::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 contrastLuna #{value} #{matte} #{self}```

def Image.exposure self::Image blackpoint::Color ex::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 exposureLuna #{blackpoint} #{ex} #{matte} #{self}```

def Image.grade self::Image blackpoint::Color whitepoint::Color lift::Color gain::Color multiply::Color offset::Color gamma::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF5 (gradeLunaColor #{blackpoint} #{whitepoint} #{lift} #{gain}) #{multiply} #{offset} #{gamma} #{matte} #{self}```

class ```ColorCorrectCurves``` a:
    ColorCorrectCurves:
        shadows, highlights :: CurveGUI a

class ColorCC color:
    saturation, contrast, gamma, gain, offset :: color

alias HueCorrectGUI = (CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float)

def Image.colorCorrect self::Image
                       master::ColorCC Color
                       shadows::ColorCC Color
                       midtones::ColorCC Color
                       highlights::ColorCC Color
                       -> Image:
    ```liftF5 colorCorrectLuna' #{master} #{shadows} #{midtones} #{highlights} #{self}```

def Image.colorCorrectCurves self::Image
                       curves::ColorCorrectCurves
                       master::ColorCC Color
                       shadows::ColorCC Color
                       midtones::ColorCC Color
                       highlights::ColorCC Color
                       -> Image:
    ```liftF5 (colorCorrectLunaCurves curves) #{master} #{shadows} #{midtones} #{highlights} #{self}```

def Image.hueCorrect self::Image curves::HueCorrectGUI -> Image:
    ```liftF2 hueCorrectLuna #{curves} #{self}```

def Image.saturate self::Image saturation::Color -> Image:
    ```liftF2 saturateLuna #{saturation} #{self}```

def Image.posterize self::Image colors::Float -> Image:
    ```liftF2 posterizeLuna #{colors} #{self}```

def Image.multiply self::Image val::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF2 multiplyLuna #{val} #{matte} #{self}```

def Image.gamma self::Image val::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF2 gammaLuna #{val} #{matte} #{self}```

class ```KeyerMode```:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

class ```KeyerThresholds``` a:
    min, minRolloff, max, maxRolloff :: a

alias KeyerThresholdsF = KeyerThresholds Float

def Image.key self::Image mode::KeyerMode thresholds::KeyerThresholdsF -> Image:
    ```liftF3 keyerLuna #{mode} #{thresholds} #{self}```

def Image.differenceKey self::Image offset::Float gain::Float constantOutside::Bool background::Image -> Image:
    ```liftF5 differenceKeyerLuna #{offset} #{gain} #{constantOutside} #{background} #{self}```

def Image.premultiply self::Image -> Image:
    ```liftF1 premultiplyLuna #{self}```

def Image.unpremultiply self::Image -> Image:
    ```liftF1 unpremultiplyLuna #{self}```

def Image.invert self::Image -> Image:
    ```liftF1 invertLuna #{self}```

def Image.histEq self::Image bins::Int -> Image:
    ```liftF2 histEqLuna #{bins} #{self}```

alias Threshold = (Float, Float)
alias Clamp = Maybe (Float, Float)

def Image.clamp self::Image thresholds::Threshold clamps::Clamp -> Image:
    ```liftF3 clampLuna #{thresholds} #{clamps} #{self}```

def Image.erode self::Image size::Int -> Image:
    ```liftF2 erodeLuna #{size} #{self}```

def Image.dilate self::Image size::Int -> Image:
    ```liftF2 dilateLuna #{size} #{self}```

def Image.open self::Image size::Int -> Image:
    ```liftF2 openLuna #{size} #{self}```

def Image.close self::Image size::Int -> Image:
    ```liftF2 closeLuna #{size} #{self}```

# def Image.radialBlur self::Image size::Int angle::Float:
#     ```liftF3 radialBlurLuna #{size} #{angle} #{self}```

class ```EdgeOperator```:
    Prewitt
    Sobel
    Scharr
    Laplace: x,y :: Int
             cross, side :: Float 

def Image.edgeDetect self::Image edgeOperator::EdgeOperator -> Image:
    ```liftF2 edgeDetectLuna #{edgeOperator} #{self}```

# def Image.bayer self::Image bits::Int:
#     ```liftF2 orderedDitherLuna #{bits} #{self}```

class ```Point``` x y:
    Point: x,y :: Float

# def Image.cornerPin self::Image p1::Point p2::Point p3::Point p4::Point:
#     p1x = p1.x
#     p1y = p1.y
#     p2x = p2.x
#     p2y = p2.y
#     p3x = p3.x
#     p3y = p3.y
#     p4x = p4.x
#     p4y = p4.y

#     ```liftF9 cornerPinLuna #{p1x} #{p1y} #{p2x} #{p2y} #{p3x} #{p3y} #{p4x} #{p4y} #{self}```

def Image.blur self::Image kernelSize::Int -> Image:
    ```liftF2 blurLuna #{kernelSize} #{self}```

# def Image.laplacian self::Image kernelSize::Int centerVal::Float sideVal::Float:
#     ```liftF4 laplacianLuna #{kernelSize} #{centerVal} #{sideVal} #{self}```

class ```MergeMode```:
    Atop
    Average: ab :: AlphaBlend
    ColorBurn: ab :: AlphaBlend
    ColorDodge: ab :: AlphaBlend
    ConjointOver
    Copy: ab :: AlphaBlend
    Difference: ab :: AlphaBlend
    DisjointOver
    DivideBySource: ab :: AlphaBlend
    DivideByDestination: ab :: AlphaBlend
    Exclusion: ab :: AlphaBlend
    From: ab :: AlphaBlend
    Geometric: ab :: AlphaBlend
    HardLight: ab :: AlphaBlend
    Hypot: ab :: AlphaBlend
    In
    MergeMask
    MergeMatte
    # Max
    # Min
    Minus: ab :: AlphaBlend
    Multiply: ab :: AlphaBlend
    Out
    Over
    Overlay: ab :: AlphaBlend
    Plus: ab :: AlphaBlend
    Screen: ab :: AlphaBlend
    SoftLight: ab :: AlphaBlend
    SoftLightPegtop: ab :: AlphaBlend
    SoftLightIllusions: ab :: AlphaBlend
    SoftLightPhotoshop: ab :: AlphaBlend
    Stencil
    Under
    XOR

class ```AlphaBlend```:
    Adobe
    Custom

def Image.merge self::Image mode::MergeMode img::Image -> Image:
    ```liftF3 mergeLuna #{mode} #{self} #{img}```

def perlin self::Std z::Float width::Int height::Int -> Image:
    ```liftF3 perlinLuna #{z} #{width} #{height}```

def billow self::Std z::Float width::Int height::Int -> Image:
    ```liftF3 billowLuna #{z} #{width} #{height}```

# TRANSFORMATIONS

alias ImgMask = Maybe Image

def noImgMask self::Std:
    ```val (Nothing :: Maybe (Value Pure Safe Image))```

class ```V2``` a:
    x, y :: a

def Image.crop self::Image rect::(Rectangle Int) reformat::Bool defaultOutside::Bool -> Image:
    ```liftF4 cropLuna ((fmap.fmap) variable -> #{rect}) #{reformat} #{defaultOutside} #{self}```

# VIEW

def View.channel self::View name::String:
    ```liftF2 View.get #{self} #{name}```

def View.append self::View channel::String:
    ```liftF2 View.append #{channel} #{self}```

def View.remove self::View name::String:
    ```liftF2 View.remove #{name} #{self}```

def View.map self::View f:
    ```liftF2 View.map #{f} #{self}```

# GEOM

class ```Point2``` a:
    x,y :: a

class ```Rectangle``` a:
    pA,pB :: Point2 a

class ```SkewOrder```:
    SkewXY
    SkewYX

class ```Skew``` a:
    value :: V2 a
    order :: SkewOrder

class ```Transform``` a:
    translate :: V2 a
    rotate    :: a
    scale     :: V2 a
    skew      :: Skew a
    center    :: Point2 a

alias RectangleF = Rectangle Float
alias RectangleI = Rectangle Int

alias TransformF = Transform Float

def Image.rotateAt self::Image point::(Point2 Float) phi::Float matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 rotateAtLuna #{point} #{phi} #{matte} #{self}```

def Image.translate self::Image vec::(V2 Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 translateLuna #{vec} #{matte} #{self}```

def Image.scaleAt self::Image point::(Point2 Float) vec::(V2 Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 scaleAtLuna #{point} #{vec} #{matte} #{self}```

def Image.skewAt self::Image point::(Point2 Float) skew::(Skew Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 skewAtLuna #{point} #{skew} #{matte} #{self}```

def Image.transform self::Image trans::TransformF -> Image:
    ```liftF2 transformLuna #{trans} #{self}```

class ```ControlPoint``` a:
    point               :: Point2 a
    handleIn, handleOut :: Maybe (Point2 a)

class ```Path``` a:
    closed   :: Bool
    vertices :: [ControlPoint a]

class ```Shape``` a:
    paths :: [Path a]

class ```Mask``` a:
    path    :: Path a
    feather :: Maybe (Path a)

class Matte a

def imageMatte self::Std image::Image channelName::String -> (Maybe (Matte Float)):
     ```lift2 imageMatteLuna #{image} #{channelName}```

def vectorMatte self::Std mask::(Mask Float) -> (Maybe (Matte Float)):
    ```liftF1 vectorMatteLuna #{mask}```

def noMatte self::Std -> (Maybe (Matte Float)):
    ```val (Nothing :: Maybe (Matte Float))```

def point self::Std x y:
    Point2 x y

def nopoint self::Std:
    ```val (Nothing :: Maybe (Point2 Float))```

def rasterizeMask self::Std w::Int h::Int m::(Mask Float) -> Image:
    ```liftF3 rasterizeMaskLuna #{w} #{h} #{m}```

# COLORS

class ```RGBA``` a:
    rgbaR, rgbaG, rgbaB, rgbaA :: a

class ```ColorMult``` color:
    color      :: color
    multiplier :: Float

alias Color = ColorMult (RGBA Float)

class ```Format```:
    PCVideo
    NTSC
    PAL
    HD
    NTSC169
    PAL169
    K1Super35
    K1Cinemascope
    K2Super35
    K2Cinemascope
    K4Super35
    K4Cinemascope
    Square256
    Square512
    Square1K
    Square2K
    CustomFormat: width, height :: Int

def constant self::Std format::Format color::Color -> Image:
    ```liftF2 constantLuna #{format} #{color}```

class ```Gamma``` a:
    Gamma: a :: Float
    Cineon
    LStar
    REDLog
    SLog
    SRGBGamma

# alias GammaF = Gamma Float

def Image.gammaToLinear self::Image gamma::(Gamma Float) -> Image:
    ```liftF2 gammaToLinearLuna #{gamma} #{self}```

def Image.gammaFromLinear self::Image gamma::(Gamma Float) -> Image:
    ```liftF2 gammaFromLinearLuna #{gamma} #{self}```

def time self::Std:
    0.0

alias Time = Float

def foo self::Std a::Time:
	a

def Image.render self::Image path::FilePath t::Time:
    ()
#
#                MATH and such
#

class ```HandleGUI```:
    NonLinearGUI:
        weight, angle :: Float
    VerticalGUI:
        length :: Float
    LinearGUI

class ```ControlPointGUI``` x:
    ControlPointGUI:
        point :: Point2 x
        handleIn, handleOut :: HandleGUI

class ```CurveGUI``` x:
    BezierCurveGUI:
        vertices :: [ControlPointGUI x]

def getValueAtCurve self::Std curve::(CurveGUI Float) x::Time -> Float:
    ```liftF2 getValueAtCurveGUI #{curve} #{x}```
