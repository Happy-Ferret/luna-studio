
def null self::Std a::a -> a:
    a

def print self msg::String:
    ```autoLift1 print #{msg}```

class ```Bool```:
    True
    False

def Bool.toString self::Bool -> String:
    ```liftF1 show #{self}```

class ```Maybe``` a:
    Just:
        unwrap :: a
    Nothing

class ```Either``` a b:
    Left: l :: a
    Right: r :: b

# CHAR

def Char.toString self::Char -> String:
    ```liftF2 (:) #{self} (val ([] :: String))```

# INT

def Int.+ self::Int a::Int -> Int:
    ```liftF2 (+) #{self} #{a}```

def Int.- self::Int a::Int -> Int:
    ```liftF2 (-) #{self} #{a}```

def Int.* self::Int a::Int -> Int:
    ```liftF2 (*) #{self} #{a}```

def Int./ self::Int a::Int -> Int:
    ```liftF2 (/) #{self} #{a}```

def Int.> self::Int a::Int -> Bool:
    ```liftF2 (>) #{self} #{a}```

def Int.== self::Int a::Int -> Bool:
    ```liftF2 (==) #{self} #{a}```

def Int.< self::Int a::Int -> Bool:
    ```liftF2 (<) #{self} #{a}```

def Int.<= self::Int a::Int -> Bool:
    ```liftF2 (<=) #{self} #{a}```

def Int.>= self::Int a::Int -> Bool:
    ```liftF2 (>=) #{self} #{a}```

# def Int.inc:
#     self.add 1

# def Int.dec:
#     self.sub 1

def Int.fromIntegral self::Int -> Float:
    ```liftF1 fromIntegral #{self} :: Value Pure Safe Float```

def Int.toString self::Int -> String:
    ```liftF1 show #{self}```

# DOUBLE / FLOAT

def Float.acc:
    ```liftF1 variable #{self}```

def Float.truncate self::Float -> Int:
    ```liftF1 truncate #{self} :: Value Pure Safe Int```

def Float.round self::Float -> Int:
    ```liftF1 round #{self} :: Value Pure Safe Int```

def Float.floor self::Float -> Int:
    ```liftF1 floor #{self} :: Value Pure Safe Int```

def Float.ceiling self::Float -> Int:
    ```liftF1 ceiling #{self} :: Value Pure Safe Int```

def Float.+ self::Float a::Float -> Float:
    ```liftF2 (+) #{self} #{a}```

def Float.- self::Float a::Float -> Float:
    ```liftF2 (-) #{self} #{a}```

def Float.* self::Float a::Float -> Float:
    ```liftF2 (*) #{self} #{a}```

def Float./ self::Float a::Float -> Float:
    ```liftF2 (/) #{self} #{a}```

def Float.> self::Float a::Float -> Bool:
    ```liftF2 (>) #{self} #{a}```

def Float.== self::Float a::Float -> Bool:
    ```liftF2 (==) #{self} #{a}```

def Float.< self::Float a::Float -> Bool:
    ```liftF2 (<) #{self} #{a}```

def Float.<= self::Float a::Float -> Bool:
    ```liftF2 (<=) #{self} #{a}```

def Float.>= self::Float a::Float -> Bool:
    ```liftF2 (>=) #{self} #{a}```

def Float.toString self::Float -> String:
    ```liftF1 show #{self}```

alias FilePath = String

class Image

def emptyImage self::Std -> Image:
    ```liftF0 Image.empty```

def load self::Std path::FilePath -> Image:
    ```autoLift1 realReadLuna #{path}```

def Image.save self::Image path::FilePath -> Image:
    ```autoLift2 saveImageLuna #{path} #{self}```

# def Image.defocus self::Image radius::Int:
#     ```liftF2 defocus #{radius} #{self}```

# def Image.motionBlur self::Image size::Int angle::Float:
#     ```liftF3 motionBlur #{size} #{angle} #{self}```

# def Image.bilateral self::Image psigma::Float csigma::Float size::Int:
#     ```liftF4 bilateral #{psigma} #{csigma} #{size} #{self}```

def Image.offset self::Image value::Color -> Image:
    ```liftF2 offsetLuna #{value} #{self}```

def Image.contrast self::Image value::Color -> Image:
    ```liftF2 contrastLuna #{value} #{self}```

def Image.exposure self::Image blackpoint::Color ex::Color -> Image:
    ```liftF3 exposureLuna #{blackpoint} #{ex} #{self}```

def Image.grade self::Image blackpoint::ColorBlack whitepoint::ColorWhite lift::ColorBlack gain::ColorWhite multiply::ColorWhite offset::ColorBlack gamma::ColorWhite -> Image:
    ```liftF5 (gradeLunaColor #{blackpoint} #{whitepoint} #{lift}) #{gain} #{multiply} #{offset} #{gamma} #{self}```

alias ColorCorrectGUI = (CurveGUI, CurveGUI)
alias HueCorrectGUI = (CurveGUI, CurveGUI, CurveGUI, CurveGUI, CurveGUI, CurveGUI, CurveGUI, CurveGUI, CurveGUI)
alias Color5 = (Color, Color, Color, Color ,Color)

def Image.colorCorrect self::Image
                       master::Color5 #masterSaturation masterContrast masterGamma masterGain masterOffset
                       shadows::Color5 #shadowsSaturation shadowsContrast shadowsGamma shadowsGain shadowsOffset
                       midtones::Color5 #midtonesSaturation midtonesContrast midtonesGamma midtonesGain midtonesOffset
                       highlights::Color5 #highlightsSaturation highlightsContrast highlightsGamma highlightsGain highlightsOffset:
                       -> Image:
    ```liftF5 colorCorrectLuna' #{master} #{shadows} #{midtones} #{highlights} #{self}```

def Image.colorCorrectCurves self::Image
                       curves::ColorCorrectGUI
                       master::Color5 #masterSaturation masterContrast masterGamma masterGain masterOffset
                       shadows::Color5 #shadowsSaturation shadowsContrast shadowsGamma shadowsGain shadowsOffset
                       midtones::Color5 #midtonesSaturation midtonesContrast midtonesGamma midtonesGain midtonesOffset
                       highlights::Color5 #highlightsSaturation highlightsContrast highlightsGamma highlightsGain highlightsOffset:
                       -> Image:
    ```liftF5 (colorCorrectLunaCurves curves) #{master} #{shadows} #{midtones} #{highlights} #{self}```

def Image.hueCorrect self::Image curves::HueCorrectGUI -> Image:
    ```liftF2 hueCorrectLuna #{curves} #{self}```

def Image.saturate self::Image saturation::Color -> Image:
    ```liftF2 saturateLuna #{saturation} #{self}```

def Image.posterize self::Image colors::Float -> Image:
    ```liftF2 posterizeLuna #{colors} #{self}```

def Image.multiply self::Image val::Color -> Image:
    ```liftF2 multiplyLuna #{val} #{self}```

def Image.gamma self::Image val::Color -> Image:
    ```liftF2 gammaLuna #{val} #{self}```

class ```KeyerMode```:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

class ```KeyerThresholds``` a:
    min, minRolloff, max, maxRolloff :: a

alias KeyerThresholdsF = KeyerThresholds Float

def Image.key self::Image mode::KeyerMode thresholds::KeyerThresholdsF -> Image:
    ```liftF3 keyerLuna #{mode} #{thresholds} #{self}```

def Image.differenceKey self::Image offset::Float gain::Float background::Image -> Image:
    ```liftF4 differenceKeyerLuna #{offset} #{gain} #{background} #{self}```

def Image.premultiply self::Image -> Image:
    ```liftF1 premultiplyLuna #{self}```

def Image.unpremultiply self::Image -> Image:
    ```liftF1 unpremultiplyLuna #{self}```

def Image.invert self::Image -> Image:
    ```liftF1 invertLuna #{self}```

def Image.histEq self::Image bins::Int -> Image:
    ```liftF2 histEqLuna #{bins} #{self}```

alias Threshold = (Float, Float)
alias Clamp = Maybe (Float, Float)

def Image.clamp self::Image thresholds::Threshold clamps::Clamp -> Image:
    ```liftF3 clampLuna #{thresholds} #{clamps} #{self}```

def Image.erode self::Image size::Int -> Image:
    ```liftF2 erodeLuna #{size} #{self}```

def Image.dilate self::Image size::Int -> Image:
    ```liftF2 dilateLuna #{size} #{self}```

def Image.open self::Image size::Int -> Image:
    ```liftF2 openLuna #{size} #{self}```

def Image.close self::Image size::Int -> Image:
    ```liftF2 closeLuna #{size} #{self}```

# def Image.radialBlur self::Image size::Int angle::Float:
#     ```liftF3 radialBlurLuna #{size} #{angle} #{self}```

def Image.edgeDetect self::Image edgeOperator -> Image:
    ```liftF2 edgeDetectLuna #{edgeOperator} #{self}```

# def Image.bayer self::Image bits::Int:
#     ```liftF2 orderedDitherLuna #{bits} #{self}```

class ```Point``` x y:
    Point: x,y :: Float

# def Image.cornerPin self::Image p1::Point p2::Point p3::Point p4::Point:
#     p1x = p1.x
#     p1y = p1.y
#     p2x = p2.x
#     p2y = p2.y
#     p3x = p3.x
#     p3y = p3.y
#     p4x = p4.x
#     p4y = p4.y

#     ```liftF9 cornerPinLuna #{p1x} #{p1y} #{p2x} #{p2y} #{p3x} #{p3y} #{p4x} #{p4y} #{self}```

def Image.blur self::Image kernelSize::Int -> Image:
    ```liftF2 blurLuna #{kernelSize} #{self}```

# def Image.laplacian self::Image kernelSize::Int centerVal::Float sideVal::Float:
#     ```liftF4 laplacianLuna #{kernelSize} #{centerVal} #{sideVal} #{self}```

class ```MergeMode```:
    Atop
    Average
    ColorBurn
    ColorDodge
    ConjointOver
    Copy
    Difference
    DisjointOver
    DivideBySource
    DivideByDestination
    Exclusion
    From
    Geometric
    HardLight
    Hypot
    In
    Mask
    Matte
    Minus
    Multiply
    Out
    Over
    Overlay
    Plus
    Screen
    SoftLight
    SoftLightPegtop
    SoftLightIllusions
    Stencil
    Under
    XOR

class ```AlphaBlend```:
    Adobe
    Custom

def Image.merge self::Image mode::MergeMode alphaBlendMode::AlphaBlend img::Image -> Image:
    ```liftF4 mergeLuna #{mode} #{alphaBlendMode} #{self} #{img}```

def perlin self::Std z::Float width::Int height::Int -> Image:
    ```liftF3 perlinLuna #{z} #{width} #{height}```

def billow self::Std z::Float width::Int height::Int -> Image:
    ```liftF3 billowLuna #{z} #{width} #{height}```

# TRANSFORMATIONS

alias ImgMask = Maybe Image

def noImgMask self::Std:
    ```val (Nothing :: Maybe (Value Pure Safe Image))```

class ```V2``` a:
    x, y :: a

def Image.translate self::Image vec::(V2 Float) -> Image:
    ```liftF2 translateLuna #{vec} #{self}```

def Image.rotate self::Image phi::Float -> Image:
    ```liftF2 rotateLuna #{phi} #{self}```

def Image.rotateAt self::Image point::(Point2 Float) phi::Float -> Image:
    ```liftF3 rotateAtLuna #{point} #{phi} #{self}```

def Image.scale self::Image vec::(V2 Float) -> Image:
    ```liftF2 scaleLuna #{vec} #{self}```

def Image.scaleAt self::Image point::(Point2 Float) vec::(V2 Float) -> Image:
    ```liftF3 scaleAtLuna #{point} #{vec} #{self}```

def Image.crop self::Image rect::(Rectangle Int) reformat::Bool defaultOutside::Bool -> Image:
    ```liftF4 cropLuna #{rect} #{reformat} #{defaultOutside} #{self}```

# VIEW

def View.channel self::View name::String:
    ```liftF2 View.get #{self} #{name}```

def View.append self::View channel::String:
    ```liftF2 View.append #{channel} #{self}```

def View.remove self::View name::String:
    ```liftF2 View.remove #{name} #{self}```

def View.map self::View f:
    ```liftF2 View.map #{f} #{self}```

# GEOM

class ```Point2``` a:
    x,y :: a

class ```Rectangle``` a:
    pA,pB :: Point2 a

class ```SkewOrder```:
    SkewXY
    SkewYX

class ```Skew``` a:
    point :: V2 a
    order :: SkewOrder

class ```Transform``` a:
    translate :: V2 a
    rotate    :: a
    scale     :: V2 a
    skew      :: Skew a
    center    :: Point2 a

alias RectangleF = Rectangle Float
alias RectangleI = Rectangle Int

alias TransformF = Transform Float

# class ```ControlPoint``` a:
# class ControlPoint a:
#     point               :: Point2 a
#     handleIn, handleOut :: Maybe (Point2 a)

# class ```Path``` a:
#     closed   :: Bool
#     vertices :: [ControlPoint a]

# class ```Shape``` a:
#     paths :: [Path a]

# class ```Mask``` a:
#     path    :: Path a
#     feather :: Maybe (Path a)

alias ControlPoint = (Point2 Float, Maybe (Point2 Float), Maybe (Point2 Float))
alias Path         = (Bool, [ControlPoint])
alias Shape        = [Path]

class Matte a

def imageMatte self::Std image::Image channelName::String -> (Maybe (Matte Float)):
     ```lift2 imageMatteLuna #{image} #{channelName}```

def vectorMatte self::Std mask::Mask -> (Maybe (Matte Float)):
    ```liftF1 vectorMatteLuna #{mask}```

def noMatte self::Std -> (Maybe (Matte Float)):
    ```val (Nothing :: Maybe (Matte Float))```

def Image.offsetMatte self::Image value::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 offsetMatteLuna #{value} #{matte} #{self}```

def Image.contrastMatte self::Image value::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 contrastMatteLuna #{value} #{matte} #{self}```

def Image.exposureMatte self::Image blackpoint::Color ex::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 exposureMatteLuna #{blackpoint} #{ex} #{matte} #{self}```

def Image.gradeMatte self::Image blackpoint::Color whitepoint::Color lift::Color gain::Color multiply::Color offset::Color gamma::Color matte::(Maybe (Matte Float)) -> Image:
    ```liftF5 (gradeLunaColorMatte #{blackpoint} #{whitepoint} #{lift} #{gain}) #{multiply} #{offset} #{gamma} #{matte} #{self}```

def Image.rotateAtMatte self::Image point::(Point2 Float) phi::Float matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 rotateAtMatteLuna #{point} #{phi} #{matte} #{self}```

def Image.translateMatte self::Image vec::(V2 Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 translateMatteLuna #{vec} #{matte} #{self}```

def Image.scaleAtMatte self::Image point::(Point2 Float) vec::(V2 Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 scaleAtMatteLuna #{point} #{vec} #{matte} #{self}```

def Image.skewAtMatte self::Image point::(Point2 Float) skew::(Skew Float) matte::(Maybe (Matte Float)) -> Image:
    ```liftF4 skewAtMatteLuna #{point} #{skew} #{matte} #{self}```

def Image.transformMatte self::Image trans::TransformF matte::(Maybe (Matte Float)) -> Image:
    ```liftF3 transformLuna #{trans} #{matte} #{self}```

alias Mask = (Path, Maybe (Path))

def point self::Std x y:
    Point2 x y

def nopoint self::Std:
    ```val (Nothing :: Maybe (Point2 Float))```

def controlPoint point handleIn handleOut:
    (point, handleIn, handleOut)

def path closed vertices:
    (closed, vertices)

def shape paths:
    paths

def mask path feather:
    (path, feather)

def rasterizeMask self::Std w::Int h::Int m::Mask -> Image:
    ```liftF3 rasterizeMaskLuna #{w} #{h} #{m}```

# COLORS

class ```RGBA``` a:
    rgbaR, rgbaG, rgbaB, rgbaA :: a

alias Color = RGBA Float
alias ColorBlack = RGBA Float
alias ColorWhite = RGBA Float

alias ColorCC = (Color, Color, Color, Color, Color)

def constant self::Std width::Int height::Int color::Color -> Image:
    ```liftF3 constantLuna #{width} #{height} #{color}```

class ```Gamma``` a:
    Gamma: a :: Float
    Cineon
    LStar
    REDLog
    SLog
    SRGBGamma

# alias GammaF = Gamma Float

def Image.gammaToLinear self::Image gamma::(Gamma Float) -> Image:
    ```liftF2 gammaToLinearLuna #{gamma} #{self}```

def Image.gammaFromLinear self::Image gamma::(Gamma Float) -> Image:
    ```liftF2 gammaFromLinearLuna #{gamma} #{self}```

def time self::Std:
    0.0

alias Time = Float

def foo self::Std a::Time:
	a

#
#                MATH and such
#

alias Point2F = Point2 Float
alias CurveGUI = [ControlPointGUI]
alias ControlPointGUI = (Point2F, HandleGUI, HandleGUI)
alias HandleGUI = (Int, Float, Float)

def curveGUI self::Std vertices::CurveGUI -> CurveGUI:
    vertices

def controlPointGUI self::Std point::Point2F handleIn::HandleGUI handleOut::HandleGUI -> ControlPointGUI:
    (point, handleIn, handleOut)

def nonLinearHandleGUI self::Std weight::Float angle::Float -> HandleGUI:
    (0, weight, angle)

def verticalHandleGUI self::Std length::Float -> HandleGUI:
    (1, length, 0.0)

def linearHandleGUI self::Std -> HandleGUI:
    (2, 0.0, 0.0)

def getValueAtCurve self::Std curve::curveGUI x::Time -> Float:
    ```liftF2 getValueAtCurveGUI #{curve} #{x}```
