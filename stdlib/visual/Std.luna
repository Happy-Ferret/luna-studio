
def null self::Std a::a -> a:
    a

def print self msg::String

class ```Bool```:
    True
    False

def Bool.toString self::Bool -> String

class ```Maybe``` a:
    Just:
        unwrap :: a
    Nothing

class ```Either``` a b:
    Left: l :: a
    Right: r :: b

# CHAR

def Char.toString self::Char -> String

# STRING

def String.++ self::String str::String -> String

# INT

def Int.+ self::Int a::Int -> Int

def Int.- self::Int a::Int -> Int

def Int.* self::Int a::Int -> Int

def Int./ self::Int a::Int -> Int

def Int.> self::Int a::Int -> Bool

def Int.== self::Int a::Int -> Bool

def Int.< self::Int a::Int -> Bool

def Int.<= self::Int a::Int -> Bool

def Int.>= self::Int a::Int -> Bool

# def Int.inc:
#     self.add 1

# def Int.dec:
#     self.sub 1

def Int.fromIntegral self::Int -> Float

def Int.toString self::Int -> String

# DOUBLE / FLOAT

def Float.acc

def Float.truncate self::Float -> Int

def Float.round self::Float -> Int

def Float.floor self::Float -> Int

def Float.ceiling self::Float -> Int

def Float.+ self::Float a::Float -> Float

def Float.- self::Float a::Float -> Float

def Float.* self::Float a::Float -> Float

def Float./ self::Float a::Float -> Float

def Float.> self::Float a::Float -> Bool

def Float.== self::Float a::Float -> Bool

def Float.< self::Float a::Float -> Bool

def Float.<= self::Float a::Float -> Bool

def Float.>= self::Float a::Float -> Bool

def Float.toString self::Float -> String

alias FilePath = String
alias SavePath = FilePath
alias LoadPath = FilePath
alias LoadDirPath = FilePath

class Image

def emptyImage self::Std -> Image

def read self::Std path::LoadPath gamma::(Gamma Float) -> Image

def readSeq self::Std path::LoadDirPath fileName::String gamma::(Gamma Float) frame::Time -> Image

def Image.save self::Image path::SavePath gamma::(Gamma Float) -> Image

# def Image.defocus self::Image radius::Int

# def Image.motionBlur self::Image size::Int angle::Float

# def Image.bilateral self::Image psigma::Float csigma::Float size::Int

def Image.offset self::Image value::Color matte::(Maybe (Matte Float)) -> Image

def Image.contrast self::Image value::Color matte::(Maybe (Matte Float)) -> Image

def Image.exposure self::Image blackpoint::Color ex::Color matte::(Maybe (Matte Float)) -> Image

def Image.grade self::Image blackpoint::Color whitepoint::Color lift::Color gain::Color multiply::Color offset::Color gamma::Color matte::(Maybe (Matte Float)) -> Image

class ```ColorCorrectCurves``` a:
    ColorCorrectCurves:
        shadows, highlights :: CurveGUI a

class ColorCC color:
    saturation, contrast, gamma, gain, offset :: color

alias HueCorrectGUI = (CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float, CurveGUI Float)

def Image.colorCorrect self::Image
                       master::(ColorCC Color)
                       shadows::(ColorCC Color)
                       midtones::(ColorCC Color)
                       highlights::(ColorCC Color)
                       -> Image

def Image.colorCorrectCurves self::Image
                       curves::(ColorCorrectCurves Float)
                       master::(ColorCC Color)
                       shadows::(ColorCC Color)
                       midtones::(ColorCC Color)
                       highlights::(ColorCC Color)
                       -> Image

class ```HueCorrectCurves``` a:
    HueCorrectCurves:
        sat, lum, red, green, blue, rsup, gsup, bsup :: CurveGUI a

def Image.hueCorrect self::Image curves::(HueCorrectCurves Float) -> Image

class ```CrosstalkCurves``` a:
    CrosstalkCurves:
        red, green, blue, redGreen, redBlue, greenRed, greenBlue, blueRed, blueGreen :: CurveGUI a

def Image.crosstalk self::Image curves::(CrosstalkCurves Float) -> Image

def Image.saturate self::Image saturation::Color -> Image

def Image.posterize self::Image colors::Float -> Image

def Image.multiply self::Image val::Color matte::(Maybe (Matte Float)) -> Image

def Image.gamma self::Image val::Color affectAlpha::Bool matte::(Maybe (Matte Float)) -> Image

class ```KeyerMode```:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

class ```KeyerThresholds``` a:
    min, minRolloff, max, maxRolloff :: a

alias KeyerThresholdsF = KeyerThresholds Float

def Image.key self::Image mode::KeyerMode thresholds::KeyerThresholdsF -> Image

def Image.differenceKey self::Image offset::Float gain::Float constantOutside::Bool background::Image -> Image

def Image.premultiply self::Image -> Image

def Image.unpremultiply self::Image -> Image

def Image.invert self::Image -> Image

def Image.histEq self::Image bins::Int -> Image

alias Threshold = (Float, Float)
alias Clamp = Maybe (Float, Float)

def Image.clamp self::Image thresholds::Threshold clamps::Clamp -> Image

def Image.erode self::Image size::Int -> Image

def Image.dilate self::Image size::Int -> Image

def Image.open self::Image size::Int -> Image

def Image.close self::Image size::Int -> Image

# def Image.radialBlur self::Image size::Int angle::Float

class ```Orientation```:
    Vertical
    Horizontal

class ```EdgeOperator```:
    Prewitt: dir :: Orientation
    Sobel: dir :: Orientation
    Scharr: dir :: Orientation
    Laplace  # : x, y :: Int
             #   cross, side :: Float

def Image.edgeDetect self::Image edgeOperator::EdgeOperator -> Image

def laplace self::Std kernelSize::Int crossValue::Float sideValue::Float -> EdgeOperator:
    ```liftF3 laplacianOperator #{kernelSize} #{crossValue} #{sideValue}```

def scharr self::Std -> EdgeOperator:
    ```liftF0 laplacianOperator```

def sobel self::Std -> EdgeOperator:
    ```liftF0 sobelOperator```

def prewitt self::Std -> EdgeOperator:
    ```liftF0 prewittOperator```

def EdgeOperator.transpose self::EdgeOperator -> EdgeOperator:
    ```liftF1 transpose #{self}```

# def Image.bayer self::Image bits::Int:
#     ```liftF2 orderedDitherLuna #{bits} #{self}```

def Image.blur self::Image kernelSize::Int -> Image

class ```BlurType```:
    GaussBlur
    BoxBlur
    TriangleBlur

def Image.edgeBlur self::Image channel::String blurType::BlurType kernelSize::Int multiplier::Float -> Image

# def Image.laplacian self::Image kernelSize::Int centerVal::Float sideVal::Float:
#     ```liftF4 laplacianLuna #{kernelSize} #{centerVal} #{sideVal} #{self}```

class ```MergeMode```:
    Atop
    Average: alphaBlend :: AlphaBlend
    ColorBurn: alphaBlend :: AlphaBlend
    ColorDodge: alphaBlend :: AlphaBlend
    ConjointOver
    Copy: alphaBlend :: AlphaBlend
    Difference: alphaBlend :: AlphaBlend
    DisjointOver
    DivideBySource: alphaBlend :: AlphaBlend
    DivideByDestination: alphaBlend :: AlphaBlend
    Exclusion: alphaBlend :: AlphaBlend
    From: alphaBlend :: AlphaBlend
    Geometric: alphaBlend :: AlphaBlend
    HardLight: alphaBlend :: AlphaBlend
    Hypot: alphaBlend :: AlphaBlend
    In
    MergeMask
    MergeMatte
    MergeMax: alphaBlend :: AlphaBlend
    MergeMin: alphaBlend :: AlphaBlend
    Minus: alphaBlend :: AlphaBlend
    Multiply: alphaBlend :: AlphaBlend
    Out
    Over
    Overlay: alphaBlend :: AlphaBlend
    Plus: alphaBlend :: AlphaBlend
    Screen: alphaBlend :: AlphaBlend
    SoftLight: alphaBlend :: AlphaBlend
    SoftLightPegtop: alphaBlend :: AlphaBlend
    SoftLightIllusions: alphaBlend :: AlphaBlend
    SoftLightPhotoshop: alphaBlend :: AlphaBlend
    Stencil
    Under
    XOR

class ```AlphaBlend```:
    Adobe
    Custom

def Image.merge background::Image foreground::Image mode::MergeMode mask::(Maybe (Matte Float))-> Image

class ```Quality```:
    Fast
    Standard
    Best

class ```NoiseParams```:
    Perlin:
        quality :: Quality
        frequency :: Float
        lacunarity :: Float
        octaves :: Int
        persistence :: Float
        seed :: Int
        z :: Float
    Billow:
        quality :: Quality
        frequency :: Float
        lacunarity :: Float
        octaves :: Int
        persistence :: Float
        seed :: Int
        z :: Float
    RidgedMulti:
        quality :: Quality
        frequency :: Float
        lacunarity :: Float
        octaves :: Int
        maxOctave :: Int
      #  seed :: Int
        exponent :: Float
        offset :: Float
        gain :: Float
        z :: Float


def noise self::Std params::NoiseParams width::Int height::Int -> Image

# TRANSFORMATIONS

alias ImgMask = Maybe Image

def noImgMask self::Std

class ```V2``` a:
    x, y :: a

def Image.crop self::Image rect::(Rectangle Int) reformat::Bool defaultOutside::Bool -> Image

# VIEW

def View.channel self::View name::String

def View.append self::View channel::String

def View.remove self::View name::String

def View.map self::View f

# GEOM

class ```Point2``` a:
    x,y :: a

class ```Rectangle``` a:
    pA,pB :: Point2 a

class ```SkewOrder```:
    SkewXY
    SkewYX

class ```Skew``` a:
    value :: V2 a
    order :: SkewOrder

class ```Transform``` a:
    translate :: V2 a
    rotate    :: a
    scale     :: V2 a
    skew      :: Skew a
    center    :: Point2 a

alias RectangleF = Rectangle Float
alias RectangleI = Rectangle Int

alias TransformF = Transform Float

def Image.rotateAt self::Image point::(Point2 Float) phi::Float reformat::Bool matte::(Maybe (Matte Float)) -> Image

def Image.translate self::Image vec::(V2 Float) reformat::Bool matte::(Maybe (Matte Float)) -> Image

def Image.scaleAt self::Image point::(Point2 Float) vec::(V2 Float) reformat::Bool matte::(Maybe (Matte Float)) -> Image

def Image.skewAt self::Image point::(Point2 Float) skew::(Skew Float) reformat::Bool matte::(Maybe (Matte Float)) -> Image

def Image.transform self::Image trans::TransformF reformat::Bool matte::(Maybe (Matte Float)) -> Image

def Image.cornerPin self::Image p1::(Point2 Float) p2::(Point2 Float) p3::(Point2 Float) p4::(Point2 Float) -> Image

class ```ControlPoint``` a:
    point               :: Point2 a
    handleIn, handleOut :: Maybe (Point2 a)

class ```Path``` a:
    closed   :: Bool
    vertices :: [ControlPoint a]

class ```Shape``` a:
    paths :: [Path a]

class ```Mask``` a:
    path    :: Path a
    feather :: Maybe (Path a)

class Matte a

def imageMatte self::Std image::Image channelName::String -> (Maybe (Matte Float))

def vectorMatte self::Std mask::(Mask Float) -> (Maybe (Matte Float))

def noMatte self::Std -> (Maybe (Matte Float))

def point self::Std x y:
    Point2 x y

def nopoint self::Std

def rasterizeMask self::Std w::Int h::Int m::(Mask Float) -> Image

class ```RotoAlgorithm```:
    GPU
    CPU

def Image.roto self::Image mask::(Mask Float) format::Format premultiply::Bool alpha::Bool algorithm::RotoAlgorithm -> Image

# experimental ######

alias BinaryMask = String
alias BinaryCurveGUI = String
alias BinaryAnimableMask = String

def Image.rotoB self::Image mask::BinaryMask format::Format premultiply::Bool alpha::Bool -> Image

def maskFromBinary mask::BinaryMask -> Mask Float

def animationFromBinary mask::BinaryCurveGUI -> CurveGUI Float

def animableMaskFromBinary mask::BinaryAnimableMask -> Mask AnimableFloat

class ```AnimableFloat```:
    ConstantValue: value :: Float
    AnimationCurve: curve :: CurveGUI Float

def interpolateMask mask::(Mask AnimableFloat) time::Time -> Mask Float

#####################

# COLORS

class ```RGBA``` a:
    rgbaR, rgbaG, rgbaB, rgbaA :: a

alias Color = RGBA Float

class ```Format```:
    PCVideo
    NTSC
    PAL
    HD
    NTSC169
    PAL169
    K1Super35
    K1Cinemascope
    K2Super35
    K2Cinemascope
    K4Super35
    K4Cinemascope
    Square256
    Square512
    Square1K
    Square2K
    CustomFormat: width, height :: Int

def constant self::Std format::Format color::Color -> Image

class ```Gamma``` a:
    Gamma: a :: Float
    Cineon
    Linear
    LStar
    REDLog
    SLog
    SRGBGamma

# alias GammaF = Gamma Float

def Image.gammaToLinear self::Image gamma::(Gamma Float) -> Image

def Image.gammaFromLinear self::Image gamma::(Gamma Float) -> Image

def time self::Std:
    0.0

alias Time = Float

def foo self::Std a::Time:
	a

def render self::Std img::Image path::SavePath gamma::(Gamma Float) a::Time:
    ()
#
#                MATH and such
#

class ```HandleGUI```:
    NonLinearGUI:
        weight, angle :: Float
    VerticalGUI:
        length :: Float
    LinearGUI

class ```ControlPointGUI``` x:
    ControlPointGUI:
        point :: Point2 x
        handleIn, handleOut :: HandleGUI

class ```CurveGUI``` x:
    BezierCurveGUI:
        vertices :: [ControlPointGUI x]

def getValueAtCurve self::Std curve::(CurveGUI Float) x::Time -> Float
