@AllowOrphans

import ```Flowbox.Graphics.Composition.Dither```
import ```Flowbox.Graphics.Mockup```
import ```Flowbox.Graphics.Image.Image```
import ```Flowbox.Graphics.Image.Merge (AlphaBlend(..))```
import ```Flowbox.Graphics.Composition.Generators.Keyer```


class Vector a:
    x,y,z :: a
    def test a b:
        (a, b)

def print msg:
    ```autoLift1 print #{msg}```

def Int.+ a:
    ```liftF2 (+) #{self} #{a}```

def Int.- a:
    ```liftF2 (-) #{self} #{a}```

def Int.* a:
    ```liftF2 (*) #{self} #{a}```

def Int./ a:
    ```liftF2 (/) #{self} #{a}```

def Int.> a:
    ```liftF2 (>) #{self} #{a}```

def Int.== a:
    ```liftF2 (==) #{self} #{a}```

def Int.< a:
    ```liftF2 (<) #{self} #{a}```

def Int.<= a:
    ```liftF2 (<=) #{self} #{a}```

def Int.>= a:
    ```liftF2 (>=) #{self} #{a}```

def Int.inc:
    self + 1

def Int.dec:
    self - 1

alias Path = String

def load path:
    ```autoLift1 loadImageLuna #{path}```

def Image.save path:
    ```autoLift2 saveImageLuna #{path} #{self}```

def Image.defocus radius:
    ```liftF1 (onEachChannel $ defocus #{radius}) #{self}```

def Image.motionBlur size angle:
    ```liftF1 (onEachChannel $ motionBlur #{size} #{angle}) #{self}```

def Image.bilateral psigma csigma size:
    ```liftF1 (onEachChannel $ bilateral #{psigma} #{csigma} #{size}) #{self}```

def Image.offset value:
    ```liftF1 (onEachValue $ offsetLuna #{value}) #{self}```

def Image.contrast value:
    ```liftF1 (onEachValue $ contrastLuna #{value}) #{self}```

def Image.exposure blackpoint ex:
    ```liftF1 (onEachValue $ exposureLuna #{blackpoint} #{ex}) #{self}```

def Image.colorCorrect saturation contrast gamma gain offset:
    ```liftF1 (onEachRGB $ colorCorrectLuna #{saturation} #{contrast} #{gamma} #{gain} #{offset}) #{self}```

def Image.grade blackpoint whitepoint lift gain multiply offset gamma:
    ```liftF1 (onEachValue $ gradeLuna #{blackpoint} #{whitepoint} #{lift} #{gain} #{multiply} #{offset} #{gamma}) #{self}```

def Image.saturate saturation:
    ```liftF1 (onEachRGB $ saturateLuna #{saturation}) #{self}```

def Image.posterize colors:
    ```liftF1 (onEachValue $ posterizeLuna #{colors}) #{self}```

class ```Bool```:
    True
    False

class ```KeyerMode```:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

def Image.key mode a b c d:
    ```liftF1 (keyerLuna #{mode} #{a} #{b} #{c} #{d}) #{self}```

def Image.differenceKey offset gain background:
    ```liftF2 (differenceKeyerLuna #{offset} #{gain}) #{background} #{self}```

class Point a:
    x,y :: a

def Image.cornerPin p1 p2 p3 p4:
    p1x = p1.x
    p1y = p1.y
    p2x = p2.x
    p2y = p2.y
    p3x = p3.x
    p3y = p3.y
    p4x = p4.x
    p4y = p4.y

    ```liftF1 (cornerPinLuna #{p1x} #{p1y} #{p2x} #{p2y} #{p3x} #{p3y} #{p4x} #{p4y}) #{self}```

# def Image.blur kernelSize:
#     ```liftF1 (gaussianLuna #{kernelSize}) #{self}```

def Image.blur kernelSize:
    ```liftF2 gaussianLuna' #{kernelSize} #{self}```

def Image.laplacian kernelSize centerVal sideVal:
    ```liftF1 (laplacianLuna #{kernelSize} #{centerVal} #{sideVal}) #{self}```

def Image.rotate phi:
    ```liftF1 (onEachChannel $ rotateCenterLuna #{phi}) #{self}```

def Image.translate boundary x y:
    ```liftF4 translateLuna #{boundary} #{x} #{y} #{self}```

def circular width height:
    ```liftF2 circularLuna #{width} #{height}```

def conical width height:
    ```liftF2 conicalLuna #{width} #{height}```

def diamond width height:
    ```liftF2 diamondLuna #{width} #{height}```

def radial metric width height:
    ```liftF3 radialShapeLuna #{metric} #{width} #{height}```

def linear width height:
    ```liftF2 linearShapeLuna #{width} #{height}```

class ```Metric```:
    Chebyshev
    Euclidean
    Minkowski: p :: Double
    Taxicab

def square side:
    ```liftF1 squareLuna #{side}```

def perlin z width height:
    ```liftF3 perlinLuna #{z} #{width} #{height}```

def billow z width height:
    ```liftF3 billowLuna #{z} #{width} #{height}```

class Range:
    lo, hi :: Double

def Image.hsvTool hueRange hueRotation hueRolloff
            saturationRange saturationAdjustment saturationRolloff
            brightnessRange brightnessAdjustment brightnessRolloff:
    hueRangeStart = hueRange.lo
    hueRangeEnd   = hueRange.hi
    saturationRangeStart = saturationRange.lo
    saturationRangeEnd   = saturationRange.hi
    brightnessRangeStart = brightnessRange.lo
    brightnessRangeEnd   = brightnessRange.hi

    # ```liftF1 (onEachRGB $ hsvToolLuna #{hueRangeStart} #{hueRangeEnd} #{hueRotation} #{hueRolloff}
    #                        #{saturationRangeStart} #{saturationRangeEnd} #{saturationAdjustment} #{saturationRolloff}
    #                        #{brightnessRangeStart} #{brightnessRangeEnd} #{brightnessAdjustment} #{brightnessRolloff}) #{self}```
    ```test #{hueRangeStart} #{hueRangeEnd} #{hueRotation} #{hueRolloff}
              #{saturationRangeStart} #{saturationRangeEnd} #{saturationAdjustment} #{saturationRolloff}
              #{brightnessRangeStart} #{brightnessRangeEnd} #{brightnessAdjustment} #{brightnessRolloff} #{self}```

class ```MergeMode```:
    Atop
    Average
    ColorBurn
    ColorDodge
    ConjointOver
    Copy
    Difference
    DisjointOver
    DivideBySource
    DivideByDestination
    Exclusion
    From
    Geometric
    HardLight
    Hypot
    In
    Mask
    Matte
    # Max
    # Min
    Minus
    Multiply
    Out
    Over
    Overlay
    Plus
    Screen
    SoftLight
    SoftLightPegtop
    SoftLightIllusions
    Stencil
    Under
    XOR

class ```AlphaBlend```:
    Adobe
    Custom

def Image.merge mode alphaBlendMode img:
    ```liftF4 mergeLuna #{mode} #{alphaBlendMode} #{self} #{img}```

def Image.erode size:
    ```liftF2 erodeLuna #{size} #{self}```

def Image.dilate size:
    ```liftF2 dilateLuna #{size} #{self}```

def Image.open size:
    ```liftF2 openLuna #{size} #{self}```

def Image.close size:
    ```liftF2 closeLuna #{size} #{self}```

def Image.premultiply:
    ```liftF1 premultiplyLuna #{self}```

def Image.unpremultiply:
    ```liftF1 unpremultiplyLuna #{self}```

def Image.invert:
    ```liftF1 invertLuna #{self}```

def Image.colorMatrix matrix:
    ```liftF2 colorMatrixLuna #{matrix} #{self}```

def Image.multiply val:
    ```liftF2 multiplyLuna #{val} #{self}```

def Image.gamma val:
    ```liftF2 gammaLuna #{val} #{self}```

def Image.clamp thresholds clamps:
    # clamps powinno byÄ‡ Maybe ale wymaga pattern-matchingu klas
    thresholdLo = thresholds.lo
    thresholdHi = thresholds.hi
    clampLo = clamps.lo
    clampHi = clamps.hi
    ```liftF5 clampLuna #{thresholdLo} #{thresholdHi} #{clampLo} #{clampHi} #{self}```

def Image.radialBlur size angle:
    ```liftF3 radialBlurLuna #{size} #{angle} #{self}```

def Image.histEq bins:
    ```liftF2 histEqLuna #{bins} #{self}```

class Dithering:
    FloydSteinberg
    Brukes
    Fan
    JarvisJudiceNinke
    Stucki
    Sierra2
    Sierra3
    Atkinson
    ShiauFan4
    ShiauFan5

# def Image.dither bound diffusionMethod bits:
#     diffusionTable = case diffusionMethod:
#         FloydSteinberg:    ```val floydSteinberg```
#         Brukes:            ```val brukes```
#         Fan:               ```val fan```
#         JarvisJudiceNinke: ```val jarvisJudiceNinke```
#         Stucki:            ```val stucki```
#         Sierra2:           ```val sierra2```
#         Sierra3:           ```val sierra3```
#         Atkinson:          ```val atkinson```
#         ShiauFan4:         ```val shiauFan4```
#         ShiauFan5:         ```val shiauFan5```
#     ```autoLift4 ditherLuna #{bound} #{bits} #{diffusionTable} #{self}```

def Image.bayer bits:
    ```liftF2 orderedDitherLuna #{bits} #{self}```

class ```Boundary```:
    Clamp
    Mirror
    Wrap
    Constant: a :: Double

def main:
    lena = load "./test.png"
    checker = load "./checker.png"
    lena = lena.merge Plus Adobe checker
    lena.save "./out.png"

    circul = Main.circular 720 480
    circul.save "./out.png"

    conical = Main.conical 1280 720
    conical.save "./out.png"

    p = Main.billow 0.0 1280 720
    p.save "./out.png"
