@AllowOrphans

import ```Data.Maybe (fromJust)```
import ```qualified Data.Array.Accelerate as A```

import ```Flowbox.Graphics.Color as Color```
import ```Flowbox.Graphics.Color.Companding.AlexaV3LogC```
import ```Flowbox.Graphics.Color.Companding.Cineon```
import ```Flowbox.Graphics.Color.Companding.Gamma```
import ```Flowbox.Graphics.Color.Companding.LStar```
import ```Flowbox.Graphics.Color.Companding.Panalog```
import ```Flowbox.Graphics.Color.Companding.PLogLin```
import ```Flowbox.Graphics.Color.Companding.Rec709```
import ```Flowbox.Graphics.Color.Companding.REDLog```
import ```Flowbox.Graphics.Color.Companding.SLog```
import ```Flowbox.Graphics.Color.Companding.SRGB```
import ```Flowbox.Graphics.Color.Companding.ViperLog```
import ```Flowbox.Graphics.Composition.Dither```
import ```Flowbox.Graphics.Mockup```
import ```Flowbox.Graphics.Image.Image as Image```
import ```Flowbox.Graphics.Image.View as View```
import ```Flowbox.Graphics.Image.Merge (AlphaBlend(..))```
import ```Flowbox.Graphics.Composition.Generators.Keyer```


class Vector a:
    x,y,z :: a
    def test a b:
        (a, b)

def print msg:
    ```autoLift1 print #{msg}```

def Int.+ a:
    ```liftF2 (+) #{self} #{a}```

def Int.- a:
    ```liftF2 (-) #{self} #{a}```

def Int.* a:
    ```liftF2 (*) #{self} #{a}```

def Int./ a:
    ```liftF2 (/) #{self} #{a}```

def Int.> a:
    ```liftF2 (>) #{self} #{a}```

def Int.== a:
    ```liftF2 (==) #{self} #{a}```

def Int.< a:
    ```liftF2 (<) #{self} #{a}```

def Int.<= a:
    ```liftF2 (<=) #{self} #{a}```

def Int.>= a:
    ```liftF2 (>=) #{self} #{a}```

def Int.inc:
    self + 1

def Int.dec:
    self - 1

alias Path = String

def load path:
    ```autoLift1 loadImageLuna #{path}```

def Image.save path:
    ```autoLift2 saveImageLuna #{path} #{self}```

def Image.defocus radius:
    ```liftF2 defocus #{radius} #{self}```

def Image.motionBlur size angle:
    ```liftF3 motionBlur #{size} #{angle} #{self}```

def Image.bilateral psigma csigma size:
    ```liftF4 bilateral #{psigma} #{csigma} #{size} #{self}```

def Image.offset value:
    ```liftF2 offsetLuna #{value} #{self}```

def Image.contrast value:
    ```liftF2 contrastLuna #{value} #{self}```

def Image.exposure blackpoint ex:
    ```liftF3 exposureLuna #{blackpoint} #{ex} #{self}```

def Image.colorCorrect saturation contrast gamma gain offset:
    ```liftF6 colorCorrectLuna #{saturation} #{contrast} #{gamma} #{gain} #{offset} #{self}```

def Image.grade blackpoint whitepoint lift gain multiply offset gamma:
    ```liftF8 gradeLuna #{blackpoint} #{whitepoint} #{lift} #{gain} #{multiply} #{offset} #{gamma} #{self}```

def Image.saturate saturation:
    ```liftF2 saturateLuna #{saturation} #{self}```

def Image.posterize colors:
    ```liftF2 posterizeLuna #{colors} #{self}```

class ```Bool```:
    True
    False

class ```KeyerMode```:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

def Image.key mode a b c d:
    ```liftF6 keyerLuna #{mode} #{a} #{b} #{c} #{d} #{self}```

def Image.differenceKey offset gain background:
    ```liftF4 differenceKeyerLuna #{offset} #{gain} #{background} #{self}```

class Point a:
    x,y :: a

def Image.cornerPin p1 p2 p3 p4:
    p1x = p1.x
    p1y = p1.y
    p2x = p2.x
    p2y = p2.y
    p3x = p3.x
    p3y = p3.y
    p4x = p4.x
    p4y = p4.y

    ```liftF9 cornerPinLuna #{p1x} #{p1y} #{p2x} #{p2y} #{p3x} #{p3y} #{p4x} #{p4y} #{self}```

# def Image.blur kernelSize:
#     ```liftF1 (gaussianLuna #{kernelSize}) #{self}```

def Image.blur kernelSize:
    ```liftF2 gaussianLuna #{kernelSize} #{self}```

def Image.laplacian kernelSize centerVal sideVal:
    ```liftF4 laplacianLuna #{kernelSize} #{centerVal} #{sideVal} #{self}```

def Image.rotate phi:
    ```liftF2 rotateCenterLuna #{phi} #{self}```

def Image.translate boundary x y:
    ```liftF4 translateLuna #{boundary} #{x} #{y} #{self}```

def Image.scaleTo boundary x y:
    ```liftF4 scaleToLuna #{boundary} #{x} #{y} #{self}```

def Image.scale boundary x y:
    ```liftF4 scaleLuna #{boundary} #{x} #{y} #{self}```

def circular width height:
    ```liftF2 circularLuna #{width} #{height}```

def conical width height:
    ```liftF2 conicalLuna #{width} #{height}```

def diamond width height:
    ```liftF2 diamondLuna #{width} #{height}```

def radial metric width height:
    ```liftF3 radialShapeLuna #{metric} #{width} #{height}```

def linear width height:
    ```liftF2 linearShapeLuna #{width} #{height}```

class ```Metric```:
    Chebyshev
    Euclidean
    Minkowski: p :: Double
    Taxicab

def square side:
    ```liftF1 squareLuna #{side}```

def perlin z width height:
    ```liftF3 perlinLuna #{z} #{width} #{height}```

def billow z width height:
    ```liftF3 billowLuna #{z} #{width} #{height}```

class Range:
    lo, hi :: Double

def Image.hsvTool hueRange hueRotation hueRolloff
            saturationRange saturationAdjustment saturationRolloff
            brightnessRange brightnessAdjustment brightnessRolloff:
    hueRangeStart = hueRange.lo
    hueRangeEnd   = hueRange.hi
    saturationRangeStart = saturationRange.lo
    saturationRangeEnd   = saturationRange.hi
    brightnessRangeStart = brightnessRange.lo
    brightnessRangeEnd   = brightnessRange.hi

    # ```liftF1 (onEachRGB $ hsvToolLuna #{hueRangeStart} #{hueRangeEnd} #{hueRotation} #{hueRolloff}
    #                        #{saturationRangeStart} #{saturationRangeEnd} #{saturationAdjustment} #{saturationRolloff}
    #                        #{brightnessRangeStart} #{brightnessRangeEnd} #{brightnessAdjustment} #{brightnessRolloff}) #{self}```
    ```test #{hueRangeStart} #{hueRangeEnd} #{hueRotation} #{hueRolloff}
              #{saturationRangeStart} #{saturationRangeEnd} #{saturationAdjustment} #{saturationRolloff}
              #{brightnessRangeStart} #{brightnessRangeEnd} #{brightnessAdjustment} #{brightnessRolloff} #{self}```

class ```MergeMode```:
    Atop
    Average
    ColorBurn
    ColorDodge
    ConjointOver
    Copy
    Difference
    DisjointOver
    DivideBySource
    DivideByDestination
    Exclusion
    From
    Geometric
    HardLight
    Hypot
    In
    Mask
    Matte
    # Max
    # Min
    Minus
    Multiply
    Out
    Over
    Overlay
    Plus
    Screen
    SoftLight
    SoftLightPegtop
    SoftLightIllusions
    Stencil
    Under
    XOR

class ```AlphaBlend```:
    Adobe
    Custom

def Image.merge mode alphaBlendMode img:
    ```liftF4 mergeLuna #{mode} #{alphaBlendMode} #{self} #{img}```

def Image.erode size:
    ```liftF2 erodeLuna #{size} #{self}```

def Image.dilate size:
    ```liftF2 dilateLuna #{size} #{self}```

def Image.open size:
    ```liftF2 openLuna #{size} #{self}```

def Image.close size:
    ```liftF2 closeLuna #{size} #{self}```

def Image.premultiply:
    ```liftF1 premultiplyLuna #{self}```

def Image.unpremultiply:
    ```liftF1 unpremultiplyLuna #{self}```

def Image.invert:
    ```liftF1 invertLuna #{self}```

def Image.colorMatrix matrix:
    ```liftF2 colorMatrixLuna #{matrix} #{self}```

def Image.multiply val:
    ```liftF2 multiplyLuna #{val} #{self}```

def Image.gamma val:
    ```liftF2 gammaLuna #{val} #{self}```

def Image.clamp thresholds clamps:
    # clamps powinno byÄ‡ Maybe ale wymaga pattern-matchingu klas
    thresholdLo = thresholds.lo
    thresholdHi = thresholds.hi
    clampLo = clamps.lo
    clampHi = clamps.hi
    ```liftF5 clampLuna #{thresholdLo} #{thresholdHi} #{clampLo} #{clampHi} #{self}```

def Image.radialBlur size angle:
    ```liftF3 radialBlurLuna #{size} #{angle} #{self}```

def Image.histEq bins:
    ```liftF2 histEqLuna #{bins} #{self}```

class Dithering:
    FloydSteinberg
    Brukes
    Fan
    JarvisJudiceNinke
    Stucki
    Sierra2
    Sierra3
    Atkinson
    ShiauFan4
    ShiauFan5

def Image.dither bound diffusionMethod bits:
    # diffusionTable = case diffusionMethod:
    #     FloydSteinberg:    ```val floydSteinberg```
    #     Brukes:            ```val brukes```
    #     Fan:               ```val fan```
    #     JarvisJudiceNinke: ```val jarvisJudiceNinke```
    #     Stucki:            ```val stucki```
    #     Sierra2:           ```val sierra2```
    #     Sierra3:           ```val sierra3```
    #     Atkinson:          ```val atkinson```
    #     ShiauFan4:         ```val shiauFan4```
    #     ShiauFan5:         ```val shiauFan5```
    # ```autoLift4 ditherLuna #{bound} #{bits} #{diffusionTable} #{self}```
    ```autoLift4 ditherLuna #{bound} #{bits} (val floydSteinberg) #{self}```

def Image.bayer bits:
    ```liftF2 orderedDitherLuna #{bits} #{self}```

class RGBAPixel:
    r, g, b, a :: Double

# def Image.colorGrade blackpoint whitepoint lift gain multiply offset gamma:
#     blackpointR = blackpoint.r
#     blackpointG = blackpoint.g
#     blackpointB = blackpoint.b
#     blackpointA = blackpoint.a
#     whitepointR = whitepoint.r
#     whitepointG = whitepoint.g
#     whitepointB = whitepoint.b
#     whitepointA = whitepoint.a
#     liftR = lift.r
#     liftG = lift.g
#     liftB = lift.b
#     liftA = lift.a
#     gainR = gain.r
#     gainG = gain.g
#     gainB = gain.b
#     gainA = gain.a
#     multiplyR = multiply.r
#     multiplyG = multiply.g
#     multiplyB = multiply.b
#     multiplyA = multiply.a
#     offsetR = offset.r
#     offsetG = offset.g
#     offsetB = offset.b
#     offsetA = offset.a
#     gammaR = gamma.r
#     gammaG = gamma.g
#     gammaB = gamma.b
#     gammaA = gamma.a
#     ```liftF8 gradeLuna' (Color.RGBA #{blackpointR} #{blackpointG} #{blackpointB} #{blackpointA})
#                          (Color.RGBA #{whitepointR} #{whitepointG} #{whitepointB} #{whitepointA})
#                          (Color.RGBA #{liftR} #{liftG} #{liftB} #{liftA})
#                          (Color.RGBA #{gainR} #{gainG} #{gainB} #{gainA})
#                          (Color.RGBA #{multiplyR} #{multiplyG} #{multiplyB} #{multiplyA})
#                          (Color.RGBA #{offsetR} #{offsetG} #{offsetB} #{offsetA})
#                          (Color.RGBA #{gammaR} #{gammaG} #{gammaB} #{gammaA})
#                          #{self}```

class ```Boundary```:
    Clamp
    Mirror
    Wrap
    Constant: a :: Double

def Image.edgeDetect edgeOperator:
    ```liftF2 edgeDetectLuna #{edgeOperator} #{self}```

def Image.view name:
    ```liftF2 Image.lookup #{name} #{self}```

def Maybe.unwrap:
    ```liftF1 fromJust #{self}```

class ```Either``` a b:
    Left: l :: a
    Right: r :: b

def Either.unwrap:
    ```liftF1 (either (error "unwrap called on Left") id) #{self}```

def View.channel name:
    ```liftF2 View.get #{self} #{name}```

def View.append channel:
    ```liftF2 View.append #{channel} #{self}```

def View.remove name:
    ```liftF2 View.remove #{name} #{self}```

def Image.removeChannel viewName channelName:
    ```liftF3 removeChannelLuna #{viewName} #{channelName} #{self}```

def Image.getChannel viewName channelName:
    ```liftF3 getChannelLuna #{viewName} #{channelName} #{self}```

def Image.insertChannel viewName channel:
    ```liftF3 insertChannelLuna #{viewName} #{channel} #{self}```

def Image.view name:
    ```liftF2 Image.lookup #{name} #{self}```

def Image.deleteView name:
    ```liftF2 Image.delete #{name} #{self}```

def readEXR filePath:
    ```autoLift1 readFromEXR #{filePath}```

class ```Gamma```:
    AlexaV3LogC
    Cineon
    Gamma: a :: Double
    LStar
    Panalog
    PLogLin
    Rec709
    REDLog
    SLog
    SRGBGamma
    ViperLog

def Image.gammaToLinear gamma:
    realGamma = ```val $ Gamma (2.2 :: A.Exp Double)```
    ```liftF2 gammaToLinearLuna #{realGamma} #{self}```

def Image.gammaFromLinear gamma:
    realGamma = ```val $ Gamma (2.2 :: A.Exp Double)```
    ```liftF2 gammaFromLinearLuna #{realGamma} #{self}```

class ```InterpolationFilter```:
    NearestNeighbour
    Box
    Basic
    Triangle
    Bell
    BSpline
    Lanczos: a :: Double
    Polynomial: a, b :: Double
    Mitchell
    CatmullRom
    Gauss: a :: Double
    Dirac: a :: Double

def Image.interpolate boundary filter:
    ```liftF3 interpolateChannelsLuna #{boundary} #{filter} #{self}```

def Image.multisample grid filter:
    ```liftF3 multisampleChannelsLuna #{grid} #{filter} #{self}```


def main:
    lena = load "./test.png"
    checker = load "./checker.png"
    lena = lena.merge Plus Adobe checker
    lena.save "./out.png"

    circul = Main.circular 720 480
    circul.save "./out.png"

    conical = Main.conical 1280 720
    conical.save "./out.png"

    p = Main.billow 0.0 1280 720
    p.save "./out.png"
