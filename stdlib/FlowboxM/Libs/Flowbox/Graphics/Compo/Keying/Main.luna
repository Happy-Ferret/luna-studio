
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
#
#   THIS IS A GENERATED FILE ! ! !   WOULD BE BETTER NOT TO MODIFY IT ! ! !
#
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


# = = = include : ../../../Prelude.lunaturbo
#
#                STD
#

foreign haskell import Data.Array.Accelerate (Boundary(..))
foreign haskell import Data.Maybe (fromJust)

foreign haskell import Flowbox.Graphics.Utils.Accelerate (variable)

foreign haskell import Flowbox.Graphics.Mockup
foreign haskell import Flowbox.Graphics.Mockup.Basic



foreign haskell class Char
foreign haskell class Float
foreign haskell class Int

foreign haskell class Bool:
    True
    False

foreign haskell def Bool.toString:
    liftF1 show self

foreign haskell class Maybe a:
    Just:
        unwrap :: a
    Nothing

foreign haskell class Either a b:
    Left: l :: a
    Right: r :: b

foreign haskell def Either.unwrap:
    liftF1 (either (error "unwrap called on Left") id) self

class Range:
    lo, hi :: Float

alias FilePath = String

# foreign haskell class Metric:
#     Chebyshev
#     Euclidean
#     Minkowski: p :: Float
#     Taxicab

foreign haskell class Boundary:
    Clamp
    # Mirror # WARN: does not work yet
    Wrap
    Constant: a :: Float

def null a:
    a

foreign haskell def print msg:
    autoLift1 print msg

# CHAR

foreign haskell def Char.toString:
    liftF2 (:) self (val ([] :: String))

# INT

foreign haskell def Int.+ a:
    liftF2 (+) self a

foreign haskell def Int.- a:
    liftF2 (-) self a

foreign haskell def Int.* a:
    liftF2 (*) self a

foreign haskell def Int./ a:
    liftF2 (/) self a

foreign haskell def Int.> a:
    liftF2 (>) self a

foreign haskell def Int.== a:
    liftF2 (==) self a

foreign haskell def Int.< a:
    liftF2 (<) self a

foreign haskell def Int.<= a:
    liftF2 (<=) self a

foreign haskell def Int.>= a:
    liftF2 (>=) self a

def Int.inc:
    self + 1

def Int.dec:
    self - 1

foreign haskell def Int.fromIntegral:
    liftF1 fromIntegral self :: Value Pure Safe Float

foreign haskell def Int.toString:
    liftF1 show self

# DOUBLE

foreign haskell def Float.acc:
    liftF1 variable self

foreign haskell def Float.truncate:
    liftF1 truncate self :: Value Pure Safe Int

foreign haskell def Float.round:
    liftF1 round self :: Value Pure Safe Int

foreign haskell def Float.floor:
    liftF1 floor self :: Value Pure Safe Int

foreign haskell def Float.ceiling:
    liftF1 ceiling self :: Value Pure Safe Int

foreign haskell def Float.+ a:
    liftF2 (+) self a

foreign haskell def Float.- a:
    liftF2 (-) self a

foreign haskell def Float.* a:
    liftF2 (*) self a

foreign haskell def Float./ a:
    liftF2 (/) self a

foreign haskell def Float.> a:
    liftF2 (>) self a

foreign haskell def Float.== a:
    liftF2 (==) self a

foreign haskell def Float.< a:
    liftF2 (<) self a

foreign haskell def Float.<= a:
    liftF2 (<=) self a

foreign haskell def Float.>= a:
    liftF2 (>=) self a

foreign haskell def Float.toString:
    liftF1 show self

# foreign haskell def Float.floor:
#     liftF1 floor self

# = = = end include : ../../../Prelude.lunaturbo


# = = = include : ../../Image/Image.lunaturbo
#
#                IMAGE
#

foreign haskell import Flowbox.Graphics.Image.Image as Image

foreign haskell class Image

foreign haskell def emptyImage:
    liftF0 Image.empty

foreign haskell def load path:
    autoLift1 realReadLuna path

foreign haskell def Image.save path:
    autoLift2 saveImageLuna path self

foreign haskell def Image.view name:
    liftF2 Image.lookup name self

# can't use this because of no matrix support in Luna?
# foreign haskell def Image.colorMatrix matrix:
#     liftF2 colorMatrixLuna matrix self

# foreign haskell def Image.removeChannel viewName channelName:
#     liftF3 removeChannelLuna viewName channelName self

foreign haskell def Image.getChannel viewName channelName:
    liftF3 getChannelLuna viewName channelName self

# foreign haskell def Image.insertChannel viewName channel:
#     liftF3 insertChannelLuna viewName channel self

foreign haskell def Image.deleteView name:
    liftF2 Image.delete name self

foreign haskell def Image.map f:
    liftF2 Image.map f self

# foreign haskell def Image.updateView f viewName:
#     liftF3 Image.update f viewName self

foreign haskell def Image.insertView view:
    liftF2 Image.insert view self

foreign haskell def imageSingleton view:
    liftF1 Image.singleton view

# = = = end include : ../../Image/Image.lunaturbo

# include ../../Geom2D/Geom.lunaturbo

# = = = include : Keying.lunaturbo
#
#                IMAGE - KEYING
#

foreign haskell import Flowbox.Graphics.Composition.Keying

foreign haskell import Flowbox.Graphics.Mockup.Keying

foreign haskell class KeyerMode:
    Red
    Green
    Blue
    Redscreen
    Greenscreen
    Bluescreen
    Saturation
    Luminance
    Max
    Min

foreign haskell class KeyerThresholds a:
    min, minRolloff, max, maxRolloff :: a

foreign haskell def Image.key mode thresholds:
    liftF3 keyerLuna mode thresholds self

foreign haskell def Image.differenceKey offset gain constantOutside background:
    liftF5 differenceKeyerLuna offset gain constantOutside background self

# = = = end include : Keying.lunaturbo


# foreign haskell def Image.crop rect reformat defaultOutside:
#     liftF4 cropLuna (fmap variable $ rect) reformat defaultOutside self

def main:
    print "FilterTransform test"

    lena    = load "./lena.png"
    moonbow = load "./moonbow.jpg"

    keyed = lena.differenceKey 0.0 1.0 False moonbow
    keyed.save "./keyed.png"

