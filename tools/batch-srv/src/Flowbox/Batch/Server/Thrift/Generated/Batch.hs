{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import           Control.Exception      
import           Data.ByteString.Lazy   
import           Data.Hashable          
import           Data.Int               
import           Data.Text.Lazy         ( Text )
import qualified Data.Text.Lazy       as TL
import           Data.Typeable          ( Typeable )
import qualified Data.HashMap.Strict  as Map
import qualified Data.HashSet         as Set
import qualified Data.Vector          as Vector

import           Thrift                 
import           Thrift.Types           ()

import           Fs_Types               
import           Graphview_Types        
import           Projects_Types         
import           Attrs_Types            
import           Defs_Types             
import           Graph_Types            
import           Libs_Types             
import           Types_Types            


import           Batch_Types            
import qualified Batch_Iface          as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Projects_args = Projects_args deriving (Show,Eq,Typeable)
instance Hashable Projects_args where
  hashWithSalt salt record = salt  
write_Projects_args oprot record = do
  writeStructBegin oprot "Projects_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_args_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Projects_args_fields iprot record
read_Projects_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_args_fields iprot (Projects_args{})
  readStructEnd iprot
  return record
data Projects_result = Projects_result{f_Projects_result_success :: Maybe (Vector.Vector Projects_Types.Project)} deriving (Show,Eq,Typeable)
instance Hashable Projects_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Projects_result_success record  
write_Projects_result oprot record = do
  writeStructBegin oprot "Projects_result"
  case f_Projects_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter12 -> Projects_Types.write_Project oprot _viter12) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_result_fields iprot record = do
  (_,_t14,_id15) <- readFieldBegin iprot
  if _t14 == T_STOP then return record else
    case _id15 of 
      0 -> if _t14 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Project iprot)) in do {(_etype19,_size16) <- readListBegin iprot; f _size16})
        read_Projects_result_fields iprot record{f_Projects_result_success=Just s}
        else do
          skip iprot _t14
          read_Projects_result_fields iprot record
      _ -> do
        skip iprot _t14
        readFieldEnd iprot
        read_Projects_result_fields iprot record
read_Projects_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_result_fields iprot (Projects_result{f_Projects_result_success=Nothing})
  readStructEnd iprot
  return record
data CreateProject_args = CreateProject_args{f_CreateProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_args_project record  
write_CreateProject_args oprot record = do
  writeStructBegin oprot "CreateProject_args"
  case f_CreateProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_args_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_args_fields iprot record{f_CreateProject_args_project=Just s}
        else do
          skip iprot _t24
          read_CreateProject_args_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_CreateProject_args_fields iprot record
read_CreateProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_args_fields iprot (CreateProject_args{f_CreateProject_args_project=Nothing})
  readStructEnd iprot
  return record
data CreateProject_result = CreateProject_result{f_CreateProject_result_success :: Maybe Projects_Types.Project,f_CreateProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_result_success record   `hashWithSalt` f_CreateProject_result_missingFields record  
write_CreateProject_result oprot record = do
  writeStructBegin oprot "CreateProject_result"
  case f_CreateProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_CreateProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_result_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      0 -> if _t29 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_success=Just s}
        else do
          skip iprot _t29
          read_CreateProject_result_fields iprot record
      1 -> if _t29 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_missingFields=Just s}
        else do
          skip iprot _t29
          read_CreateProject_result_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_CreateProject_result_fields iprot record
read_CreateProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_result_fields iprot (CreateProject_result{f_CreateProject_result_success=Nothing,f_CreateProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data OpenProject_args = OpenProject_args{f_OpenProject_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_args_path record  
write_OpenProject_args oprot record = do
  writeStructBegin oprot "OpenProject_args"
  case f_OpenProject_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_args_fields iprot record = do
  (_,_t34,_id35) <- readFieldBegin iprot
  if _t34 == T_STOP then return record else
    case _id35 of 
      1 -> if _t34 == T_STRING then do
        s <- readString iprot
        read_OpenProject_args_fields iprot record{f_OpenProject_args_path=Just s}
        else do
          skip iprot _t34
          read_OpenProject_args_fields iprot record
      _ -> do
        skip iprot _t34
        readFieldEnd iprot
        read_OpenProject_args_fields iprot record
read_OpenProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_args_fields iprot (OpenProject_args{f_OpenProject_args_path=Nothing})
  readStructEnd iprot
  return record
data OpenProject_result = OpenProject_result{f_OpenProject_result_success :: Maybe Projects_Types.Project,f_OpenProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_result_success record   `hashWithSalt` f_OpenProject_result_missingFields record  
write_OpenProject_result oprot record = do
  writeStructBegin oprot "OpenProject_result"
  case f_OpenProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_OpenProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_result_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      0 -> if _t39 == T_STRUCT then do
        s <- (read_Project iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_success=Just s}
        else do
          skip iprot _t39
          read_OpenProject_result_fields iprot record
      1 -> if _t39 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_missingFields=Just s}
        else do
          skip iprot _t39
          read_OpenProject_result_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_OpenProject_result_fields iprot record
read_OpenProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_result_fields iprot (OpenProject_result{f_OpenProject_result_success=Nothing,f_OpenProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CloseProject_args = CloseProject_args{f_CloseProject_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_args_projectID record  
write_CloseProject_args oprot record = do
  writeStructBegin oprot "CloseProject_args"
  case f_CloseProject_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_args_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_I32 then do
        s <- readI32 iprot
        read_CloseProject_args_fields iprot record{f_CloseProject_args_projectID=Just s}
        else do
          skip iprot _t44
          read_CloseProject_args_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_CloseProject_args_fields iprot record
read_CloseProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_args_fields iprot (CloseProject_args{f_CloseProject_args_projectID=Nothing})
  readStructEnd iprot
  return record
data CloseProject_result = CloseProject_result{f_CloseProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_result_missingFields record  
write_CloseProject_result oprot record = do
  writeStructBegin oprot "CloseProject_result"
  case f_CloseProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_result_fields iprot record = do
  (_,_t49,_id50) <- readFieldBegin iprot
  if _t49 == T_STOP then return record else
    case _id50 of 
      1 -> if _t49 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CloseProject_result_fields iprot record{f_CloseProject_result_missingFields=Just s}
        else do
          skip iprot _t49
          read_CloseProject_result_fields iprot record
      _ -> do
        skip iprot _t49
        readFieldEnd iprot
        read_CloseProject_result_fields iprot record
read_CloseProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_result_fields iprot (CloseProject_result{f_CloseProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data StoreProject_args = StoreProject_args{f_StoreProject_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable StoreProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreProject_args_projectID record  
write_StoreProject_args oprot record = do
  writeStructBegin oprot "StoreProject_args"
  case f_StoreProject_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreProject_args_fields iprot record = do
  (_,_t54,_id55) <- readFieldBegin iprot
  if _t54 == T_STOP then return record else
    case _id55 of 
      1 -> if _t54 == T_I32 then do
        s <- readI32 iprot
        read_StoreProject_args_fields iprot record{f_StoreProject_args_projectID=Just s}
        else do
          skip iprot _t54
          read_StoreProject_args_fields iprot record
      _ -> do
        skip iprot _t54
        readFieldEnd iprot
        read_StoreProject_args_fields iprot record
read_StoreProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreProject_args_fields iprot (StoreProject_args{f_StoreProject_args_projectID=Nothing})
  readStructEnd iprot
  return record
data StoreProject_result = StoreProject_result{f_StoreProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable StoreProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreProject_result_missingFields record  
write_StoreProject_result oprot record = do
  writeStructBegin oprot "StoreProject_result"
  case f_StoreProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreProject_result_fields iprot record = do
  (_,_t59,_id60) <- readFieldBegin iprot
  if _t59 == T_STOP then return record else
    case _id60 of 
      1 -> if _t59 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_StoreProject_result_fields iprot record{f_StoreProject_result_missingFields=Just s}
        else do
          skip iprot _t59
          read_StoreProject_result_fields iprot record
      _ -> do
        skip iprot _t59
        readFieldEnd iprot
        read_StoreProject_result_fields iprot record
read_StoreProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreProject_result_fields iprot (StoreProject_result{f_StoreProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Libraries_args = Libraries_args{f_Libraries_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Libraries_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_args_projectID record  
write_Libraries_args oprot record = do
  writeStructBegin oprot "Libraries_args"
  case f_Libraries_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_args_fields iprot record = do
  (_,_t64,_id65) <- readFieldBegin iprot
  if _t64 == T_STOP then return record else
    case _id65 of 
      1 -> if _t64 == T_I32 then do
        s <- readI32 iprot
        read_Libraries_args_fields iprot record{f_Libraries_args_projectID=Just s}
        else do
          skip iprot _t64
          read_Libraries_args_fields iprot record
      _ -> do
        skip iprot _t64
        readFieldEnd iprot
        read_Libraries_args_fields iprot record
read_Libraries_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_args_fields iprot (Libraries_args{f_Libraries_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Libraries_result = Libraries_result{f_Libraries_result_success :: Maybe (Vector.Vector Libs_Types.Library),f_Libraries_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Libraries_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_result_success record   `hashWithSalt` f_Libraries_result_missingFields record  
write_Libraries_result oprot record = do
  writeStructBegin oprot "Libraries_result"
  case f_Libraries_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter68 -> Libs_Types.write_Library oprot _viter68) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Libraries_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_result_fields iprot record = do
  (_,_t70,_id71) <- readFieldBegin iprot
  if _t70 == T_STOP then return record else
    case _id71 of 
      0 -> if _t70 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Library iprot)) in do {(_etype75,_size72) <- readListBegin iprot; f _size72})
        read_Libraries_result_fields iprot record{f_Libraries_result_success=Just s}
        else do
          skip iprot _t70
          read_Libraries_result_fields iprot record
      1 -> if _t70 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Libraries_result_fields iprot record{f_Libraries_result_missingFields=Just s}
        else do
          skip iprot _t70
          read_Libraries_result_fields iprot record
      _ -> do
        skip iprot _t70
        readFieldEnd iprot
        read_Libraries_result_fields iprot record
read_Libraries_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_result_fields iprot (Libraries_result{f_Libraries_result_success=Nothing,f_Libraries_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_args = CreateLibrary_args{f_CreateLibrary_args_library :: Maybe Libs_Types.Library,f_CreateLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_args_library record   `hashWithSalt` f_CreateLibrary_args_projectID record  
write_CreateLibrary_args oprot record = do
  writeStructBegin oprot "CreateLibrary_args"
  case f_CreateLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_CreateLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_args_fields iprot record = do
  (_,_t80,_id81) <- readFieldBegin iprot
  if _t80 == T_STOP then return record else
    case _id81 of 
      1 -> if _t80 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_args_fields iprot record{f_CreateLibrary_args_library=Just s}
        else do
          skip iprot _t80
          read_CreateLibrary_args_fields iprot record
      2 -> if _t80 == T_I32 then do
        s <- readI32 iprot
        read_CreateLibrary_args_fields iprot record{f_CreateLibrary_args_projectID=Just s}
        else do
          skip iprot _t80
          read_CreateLibrary_args_fields iprot record
      _ -> do
        skip iprot _t80
        readFieldEnd iprot
        read_CreateLibrary_args_fields iprot record
read_CreateLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_args_fields iprot (CreateLibrary_args{f_CreateLibrary_args_library=Nothing,f_CreateLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_result = CreateLibrary_result{f_CreateLibrary_result_success :: Maybe Libs_Types.Library,f_CreateLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_result_success record   `hashWithSalt` f_CreateLibrary_result_missingFields record  
write_CreateLibrary_result oprot record = do
  writeStructBegin oprot "CreateLibrary_result"
  case f_CreateLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_CreateLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_result_fields iprot record = do
  (_,_t85,_id86) <- readFieldBegin iprot
  if _t85 == T_STOP then return record else
    case _id86 of 
      0 -> if _t85 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_success=Just s}
        else do
          skip iprot _t85
          read_CreateLibrary_result_fields iprot record
      1 -> if _t85 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_missingFields=Just s}
        else do
          skip iprot _t85
          read_CreateLibrary_result_fields iprot record
      _ -> do
        skip iprot _t85
        readFieldEnd iprot
        read_CreateLibrary_result_fields iprot record
read_CreateLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_result_fields iprot (CreateLibrary_result{f_CreateLibrary_result_success=Nothing,f_CreateLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_args = LoadLibrary_args{f_LoadLibrary_args_path :: Maybe Text,f_LoadLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_args_path record   `hashWithSalt` f_LoadLibrary_args_projectID record  
write_LoadLibrary_args oprot record = do
  writeStructBegin oprot "LoadLibrary_args"
  case f_LoadLibrary_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_args_fields iprot record = do
  (_,_t90,_id91) <- readFieldBegin iprot
  if _t90 == T_STOP then return record else
    case _id91 of 
      1 -> if _t90 == T_STRING then do
        s <- readString iprot
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_path=Just s}
        else do
          skip iprot _t90
          read_LoadLibrary_args_fields iprot record
      2 -> if _t90 == T_I32 then do
        s <- readI32 iprot
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_projectID=Just s}
        else do
          skip iprot _t90
          read_LoadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t90
        readFieldEnd iprot
        read_LoadLibrary_args_fields iprot record
read_LoadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_args_fields iprot (LoadLibrary_args{f_LoadLibrary_args_path=Nothing,f_LoadLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_result = LoadLibrary_result{f_LoadLibrary_result_success :: Maybe Libs_Types.Library,f_LoadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_result_success record   `hashWithSalt` f_LoadLibrary_result_missingFields record  
write_LoadLibrary_result oprot record = do
  writeStructBegin oprot "LoadLibrary_result"
  case f_LoadLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_result_fields iprot record = do
  (_,_t95,_id96) <- readFieldBegin iprot
  if _t95 == T_STOP then return record else
    case _id96 of 
      0 -> if _t95 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_success=Just s}
        else do
          skip iprot _t95
          read_LoadLibrary_result_fields iprot record
      1 -> if _t95 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t95
          read_LoadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t95
        readFieldEnd iprot
        read_LoadLibrary_result_fields iprot record
read_LoadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_result_fields iprot (LoadLibrary_result{f_LoadLibrary_result_success=Nothing,f_LoadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_args = UnloadLibrary_args{f_UnloadLibrary_args_libID :: Maybe Int32,f_UnloadLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_args_libID record   `hashWithSalt` f_UnloadLibrary_args_projectID record  
write_UnloadLibrary_args oprot record = do
  writeStructBegin oprot "UnloadLibrary_args"
  case f_UnloadLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UnloadLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_args_fields iprot record = do
  (_,_t100,_id101) <- readFieldBegin iprot
  if _t100 == T_STOP then return record else
    case _id101 of 
      1 -> if _t100 == T_I32 then do
        s <- readI32 iprot
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_libID=Just s}
        else do
          skip iprot _t100
          read_UnloadLibrary_args_fields iprot record
      2 -> if _t100 == T_I32 then do
        s <- readI32 iprot
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_projectID=Just s}
        else do
          skip iprot _t100
          read_UnloadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t100
        readFieldEnd iprot
        read_UnloadLibrary_args_fields iprot record
read_UnloadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_args_fields iprot (UnloadLibrary_args{f_UnloadLibrary_args_libID=Nothing,f_UnloadLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_result = UnloadLibrary_result{f_UnloadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_result_missingFields record  
write_UnloadLibrary_result oprot record = do
  writeStructBegin oprot "UnloadLibrary_result"
  case f_UnloadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_result_fields iprot record = do
  (_,_t105,_id106) <- readFieldBegin iprot
  if _t105 == T_STOP then return record else
    case _id106 of 
      1 -> if _t105 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UnloadLibrary_result_fields iprot record{f_UnloadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t105
          read_UnloadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t105
        readFieldEnd iprot
        read_UnloadLibrary_result_fields iprot record
read_UnloadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_result_fields iprot (UnloadLibrary_result{f_UnloadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_args = StoreLibrary_args{f_StoreLibrary_args_libID :: Maybe Int32,f_StoreLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_args_libID record   `hashWithSalt` f_StoreLibrary_args_projectID record  
write_StoreLibrary_args oprot record = do
  writeStructBegin oprot "StoreLibrary_args"
  case f_StoreLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_StoreLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_args_fields iprot record = do
  (_,_t110,_id111) <- readFieldBegin iprot
  if _t110 == T_STOP then return record else
    case _id111 of 
      1 -> if _t110 == T_I32 then do
        s <- readI32 iprot
        read_StoreLibrary_args_fields iprot record{f_StoreLibrary_args_libID=Just s}
        else do
          skip iprot _t110
          read_StoreLibrary_args_fields iprot record
      2 -> if _t110 == T_I32 then do
        s <- readI32 iprot
        read_StoreLibrary_args_fields iprot record{f_StoreLibrary_args_projectID=Just s}
        else do
          skip iprot _t110
          read_StoreLibrary_args_fields iprot record
      _ -> do
        skip iprot _t110
        readFieldEnd iprot
        read_StoreLibrary_args_fields iprot record
read_StoreLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_args_fields iprot (StoreLibrary_args{f_StoreLibrary_args_libID=Nothing,f_StoreLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_result = StoreLibrary_result{f_StoreLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_result_missingFields record  
write_StoreLibrary_result oprot record = do
  writeStructBegin oprot "StoreLibrary_result"
  case f_StoreLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_result_fields iprot record = do
  (_,_t115,_id116) <- readFieldBegin iprot
  if _t115 == T_STOP then return record else
    case _id116 of 
      1 -> if _t115 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_StoreLibrary_result_fields iprot record{f_StoreLibrary_result_missingFields=Just s}
        else do
          skip iprot _t115
          read_StoreLibrary_result_fields iprot record
      _ -> do
        skip iprot _t115
        readFieldEnd iprot
        read_StoreLibrary_result_fields iprot record
read_StoreLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_result_fields iprot (StoreLibrary_result{f_StoreLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data BuildLibrary_args = BuildLibrary_args{f_BuildLibrary_args_libID :: Maybe Int32,f_BuildLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable BuildLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_BuildLibrary_args_libID record   `hashWithSalt` f_BuildLibrary_args_projectID record  
write_BuildLibrary_args oprot record = do
  writeStructBegin oprot "BuildLibrary_args"
  case f_BuildLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_BuildLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_BuildLibrary_args_fields iprot record = do
  (_,_t120,_id121) <- readFieldBegin iprot
  if _t120 == T_STOP then return record else
    case _id121 of 
      1 -> if _t120 == T_I32 then do
        s <- readI32 iprot
        read_BuildLibrary_args_fields iprot record{f_BuildLibrary_args_libID=Just s}
        else do
          skip iprot _t120
          read_BuildLibrary_args_fields iprot record
      2 -> if _t120 == T_I32 then do
        s <- readI32 iprot
        read_BuildLibrary_args_fields iprot record{f_BuildLibrary_args_projectID=Just s}
        else do
          skip iprot _t120
          read_BuildLibrary_args_fields iprot record
      _ -> do
        skip iprot _t120
        readFieldEnd iprot
        read_BuildLibrary_args_fields iprot record
read_BuildLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_BuildLibrary_args_fields iprot (BuildLibrary_args{f_BuildLibrary_args_libID=Nothing,f_BuildLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data BuildLibrary_result = BuildLibrary_result{f_BuildLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable BuildLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_BuildLibrary_result_missingFields record  
write_BuildLibrary_result oprot record = do
  writeStructBegin oprot "BuildLibrary_result"
  case f_BuildLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_BuildLibrary_result_fields iprot record = do
  (_,_t125,_id126) <- readFieldBegin iprot
  if _t125 == T_STOP then return record else
    case _id126 of 
      1 -> if _t125 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_BuildLibrary_result_fields iprot record{f_BuildLibrary_result_missingFields=Just s}
        else do
          skip iprot _t125
          read_BuildLibrary_result_fields iprot record
      _ -> do
        skip iprot _t125
        readFieldEnd iprot
        read_BuildLibrary_result_fields iprot record
read_BuildLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_BuildLibrary_result_fields iprot (BuildLibrary_result{f_BuildLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_args = LibraryRootDef_args{f_LibraryRootDef_args_libID :: Maybe Int32,f_LibraryRootDef_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_args_libID record   `hashWithSalt` f_LibraryRootDef_args_projectID record  
write_LibraryRootDef_args oprot record = do
  writeStructBegin oprot "LibraryRootDef_args"
  case f_LibraryRootDef_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_args_fields iprot record = do
  (_,_t130,_id131) <- readFieldBegin iprot
  if _t130 == T_STOP then return record else
    case _id131 of 
      1 -> if _t130 == T_I32 then do
        s <- readI32 iprot
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_libID=Just s}
        else do
          skip iprot _t130
          read_LibraryRootDef_args_fields iprot record
      2 -> if _t130 == T_I32 then do
        s <- readI32 iprot
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_projectID=Just s}
        else do
          skip iprot _t130
          read_LibraryRootDef_args_fields iprot record
      _ -> do
        skip iprot _t130
        readFieldEnd iprot
        read_LibraryRootDef_args_fields iprot record
read_LibraryRootDef_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_args_fields iprot (LibraryRootDef_args{f_LibraryRootDef_args_libID=Nothing,f_LibraryRootDef_args_projectID=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_result = LibraryRootDef_result{f_LibraryRootDef_result_success :: Maybe Defs_Types.Definition,f_LibraryRootDef_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_result_success record   `hashWithSalt` f_LibraryRootDef_result_missingFields record  
write_LibraryRootDef_result oprot record = do
  writeStructBegin oprot "LibraryRootDef_result"
  case f_LibraryRootDef_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_result_fields iprot record = do
  (_,_t135,_id136) <- readFieldBegin iprot
  if _t135 == T_STOP then return record else
    case _id136 of 
      0 -> if _t135 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_success=Just s}
        else do
          skip iprot _t135
          read_LibraryRootDef_result_fields iprot record
      1 -> if _t135 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_missingFields=Just s}
        else do
          skip iprot _t135
          read_LibraryRootDef_result_fields iprot record
      _ -> do
        skip iprot _t135
        readFieldEnd iprot
        read_LibraryRootDef_result_fields iprot record
read_LibraryRootDef_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_result_fields iprot (LibraryRootDef_result{f_LibraryRootDef_result_success=Nothing,f_LibraryRootDef_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefsGraph_args = DefsGraph_args{f_DefsGraph_args_libID :: Maybe Int32,f_DefsGraph_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefsGraph_args_libID record   `hashWithSalt` f_DefsGraph_args_projectID record  
write_DefsGraph_args oprot record = do
  writeStructBegin oprot "DefsGraph_args"
  case f_DefsGraph_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefsGraph_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_args_fields iprot record = do
  (_,_t140,_id141) <- readFieldBegin iprot
  if _t140 == T_STOP then return record else
    case _id141 of 
      1 -> if _t140 == T_I32 then do
        s <- readI32 iprot
        read_DefsGraph_args_fields iprot record{f_DefsGraph_args_libID=Just s}
        else do
          skip iprot _t140
          read_DefsGraph_args_fields iprot record
      2 -> if _t140 == T_I32 then do
        s <- readI32 iprot
        read_DefsGraph_args_fields iprot record{f_DefsGraph_args_projectID=Just s}
        else do
          skip iprot _t140
          read_DefsGraph_args_fields iprot record
      _ -> do
        skip iprot _t140
        readFieldEnd iprot
        read_DefsGraph_args_fields iprot record
read_DefsGraph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_args_fields iprot (DefsGraph_args{f_DefsGraph_args_libID=Nothing,f_DefsGraph_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefsGraph_result = DefsGraph_result{f_DefsGraph_result_success :: Maybe Defs_Types.DefsGraph,f_DefsGraph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefsGraph_result_success record   `hashWithSalt` f_DefsGraph_result_missingFields record  
write_DefsGraph_result oprot record = do
  writeStructBegin oprot "DefsGraph_result"
  case f_DefsGraph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_DefsGraph oprot _v
    writeFieldEnd oprot}
  case f_DefsGraph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_result_fields iprot record = do
  (_,_t145,_id146) <- readFieldBegin iprot
  if _t145 == T_STOP then return record else
    case _id146 of 
      0 -> if _t145 == T_STRUCT then do
        s <- (read_DefsGraph iprot)
        read_DefsGraph_result_fields iprot record{f_DefsGraph_result_success=Just s}
        else do
          skip iprot _t145
          read_DefsGraph_result_fields iprot record
      1 -> if _t145 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefsGraph_result_fields iprot record{f_DefsGraph_result_missingFields=Just s}
        else do
          skip iprot _t145
          read_DefsGraph_result_fields iprot record
      _ -> do
        skip iprot _t145
        readFieldEnd iprot
        read_DefsGraph_result_fields iprot record
read_DefsGraph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_result_fields iprot (DefsGraph_result{f_DefsGraph_result_success=Nothing,f_DefsGraph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefByID_args = DefByID_args{f_DefByID_args_defID :: Maybe Int32,f_DefByID_args_libID :: Maybe Int32,f_DefByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefByID_args_defID record   `hashWithSalt` f_DefByID_args_libID record   `hashWithSalt` f_DefByID_args_projectID record  
write_DefByID_args oprot record = do
  writeStructBegin oprot "DefByID_args"
  case f_DefByID_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefByID_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefByID_args_fields iprot record = do
  (_,_t150,_id151) <- readFieldBegin iprot
  if _t150 == T_STOP then return record else
    case _id151 of 
      1 -> if _t150 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_defID=Just s}
        else do
          skip iprot _t150
          read_DefByID_args_fields iprot record
      2 -> if _t150 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_libID=Just s}
        else do
          skip iprot _t150
          read_DefByID_args_fields iprot record
      3 -> if _t150 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_projectID=Just s}
        else do
          skip iprot _t150
          read_DefByID_args_fields iprot record
      _ -> do
        skip iprot _t150
        readFieldEnd iprot
        read_DefByID_args_fields iprot record
read_DefByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefByID_args_fields iprot (DefByID_args{f_DefByID_args_defID=Nothing,f_DefByID_args_libID=Nothing,f_DefByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefByID_result = DefByID_result{f_DefByID_result_success :: Maybe Defs_Types.Definition,f_DefByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefByID_result_success record   `hashWithSalt` f_DefByID_result_missingFields record  
write_DefByID_result oprot record = do
  writeStructBegin oprot "DefByID_result"
  case f_DefByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_DefByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefByID_result_fields iprot record = do
  (_,_t155,_id156) <- readFieldBegin iprot
  if _t155 == T_STOP then return record else
    case _id156 of 
      0 -> if _t155 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefByID_result_fields iprot record{f_DefByID_result_success=Just s}
        else do
          skip iprot _t155
          read_DefByID_result_fields iprot record
      1 -> if _t155 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefByID_result_fields iprot record{f_DefByID_result_missingFields=Just s}
        else do
          skip iprot _t155
          read_DefByID_result_fields iprot record
      _ -> do
        skip iprot _t155
        readFieldEnd iprot
        read_DefByID_result_fields iprot record
read_DefByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefByID_result_fields iprot (DefByID_result{f_DefByID_result_success=Nothing,f_DefByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_args = AddDefinition_args{f_AddDefinition_args_definition :: Maybe Defs_Types.Definition,f_AddDefinition_args_parentID :: Maybe Int32,f_AddDefinition_args_libID :: Maybe Int32,f_AddDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_args_definition record   `hashWithSalt` f_AddDefinition_args_parentID record   `hashWithSalt` f_AddDefinition_args_libID record   `hashWithSalt` f_AddDefinition_args_projectID record  
write_AddDefinition_args oprot record = do
  writeStructBegin oprot "AddDefinition_args"
  case f_AddDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_parentID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parentID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_args_fields iprot record = do
  (_,_t160,_id161) <- readFieldBegin iprot
  if _t160 == T_STOP then return record else
    case _id161 of 
      1 -> if _t160 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_definition=Just s}
        else do
          skip iprot _t160
          read_AddDefinition_args_fields iprot record
      2 -> if _t160 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_parentID=Just s}
        else do
          skip iprot _t160
          read_AddDefinition_args_fields iprot record
      3 -> if _t160 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_libID=Just s}
        else do
          skip iprot _t160
          read_AddDefinition_args_fields iprot record
      4 -> if _t160 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_projectID=Just s}
        else do
          skip iprot _t160
          read_AddDefinition_args_fields iprot record
      _ -> do
        skip iprot _t160
        readFieldEnd iprot
        read_AddDefinition_args_fields iprot record
read_AddDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_args_fields iprot (AddDefinition_args{f_AddDefinition_args_definition=Nothing,f_AddDefinition_args_parentID=Nothing,f_AddDefinition_args_libID=Nothing,f_AddDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_result = AddDefinition_result{f_AddDefinition_result_success :: Maybe Defs_Types.Definition,f_AddDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_result_success record   `hashWithSalt` f_AddDefinition_result_missingFields record  
write_AddDefinition_result oprot record = do
  writeStructBegin oprot "AddDefinition_result"
  case f_AddDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_result_fields iprot record = do
  (_,_t165,_id166) <- readFieldBegin iprot
  if _t165 == T_STOP then return record else
    case _id166 of 
      0 -> if _t165 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_success=Just s}
        else do
          skip iprot _t165
          read_AddDefinition_result_fields iprot record
      1 -> if _t165 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_missingFields=Just s}
        else do
          skip iprot _t165
          read_AddDefinition_result_fields iprot record
      _ -> do
        skip iprot _t165
        readFieldEnd iprot
        read_AddDefinition_result_fields iprot record
read_AddDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_result_fields iprot (AddDefinition_result{f_AddDefinition_result_success=Nothing,f_AddDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_args = UpdateDefinition_args{f_UpdateDefinition_args_definition :: Maybe Defs_Types.Definition,f_UpdateDefinition_args_libID :: Maybe Int32,f_UpdateDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_args_definition record   `hashWithSalt` f_UpdateDefinition_args_libID record   `hashWithSalt` f_UpdateDefinition_args_projectID record  
write_UpdateDefinition_args oprot record = do
  writeStructBegin oprot "UpdateDefinition_args"
  case f_UpdateDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_UpdateDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_args_fields iprot record = do
  (_,_t170,_id171) <- readFieldBegin iprot
  if _t170 == T_STOP then return record else
    case _id171 of 
      1 -> if _t170 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_definition=Just s}
        else do
          skip iprot _t170
          read_UpdateDefinition_args_fields iprot record
      2 -> if _t170 == T_I32 then do
        s <- readI32 iprot
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_libID=Just s}
        else do
          skip iprot _t170
          read_UpdateDefinition_args_fields iprot record
      3 -> if _t170 == T_I32 then do
        s <- readI32 iprot
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_projectID=Just s}
        else do
          skip iprot _t170
          read_UpdateDefinition_args_fields iprot record
      _ -> do
        skip iprot _t170
        readFieldEnd iprot
        read_UpdateDefinition_args_fields iprot record
read_UpdateDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_args_fields iprot (UpdateDefinition_args{f_UpdateDefinition_args_definition=Nothing,f_UpdateDefinition_args_libID=Nothing,f_UpdateDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_result = UpdateDefinition_result{f_UpdateDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_result_missingFields record  
write_UpdateDefinition_result oprot record = do
  writeStructBegin oprot "UpdateDefinition_result"
  case f_UpdateDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_result_fields iprot record = do
  (_,_t175,_id176) <- readFieldBegin iprot
  if _t175 == T_STOP then return record else
    case _id176 of 
      1 -> if _t175 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateDefinition_result_fields iprot record{f_UpdateDefinition_result_missingFields=Just s}
        else do
          skip iprot _t175
          read_UpdateDefinition_result_fields iprot record
      _ -> do
        skip iprot _t175
        readFieldEnd iprot
        read_UpdateDefinition_result_fields iprot record
read_UpdateDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_result_fields iprot (UpdateDefinition_result{f_UpdateDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_args = RemoveDefinition_args{f_RemoveDefinition_args_defID :: Maybe Int32,f_RemoveDefinition_args_libID :: Maybe Int32,f_RemoveDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_args_defID record   `hashWithSalt` f_RemoveDefinition_args_libID record   `hashWithSalt` f_RemoveDefinition_args_projectID record  
write_RemoveDefinition_args oprot record = do
  writeStructBegin oprot "RemoveDefinition_args"
  case f_RemoveDefinition_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_args_fields iprot record = do
  (_,_t180,_id181) <- readFieldBegin iprot
  if _t180 == T_STOP then return record else
    case _id181 of 
      1 -> if _t180 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_defID=Just s}
        else do
          skip iprot _t180
          read_RemoveDefinition_args_fields iprot record
      2 -> if _t180 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_libID=Just s}
        else do
          skip iprot _t180
          read_RemoveDefinition_args_fields iprot record
      3 -> if _t180 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_projectID=Just s}
        else do
          skip iprot _t180
          read_RemoveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t180
        readFieldEnd iprot
        read_RemoveDefinition_args_fields iprot record
read_RemoveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_args_fields iprot (RemoveDefinition_args{f_RemoveDefinition_args_defID=Nothing,f_RemoveDefinition_args_libID=Nothing,f_RemoveDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_result = RemoveDefinition_result{f_RemoveDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_result_missingFields record  
write_RemoveDefinition_result oprot record = do
  writeStructBegin oprot "RemoveDefinition_result"
  case f_RemoveDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_result_fields iprot record = do
  (_,_t185,_id186) <- readFieldBegin iprot
  if _t185 == T_STOP then return record else
    case _id186 of 
      1 -> if _t185 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveDefinition_result_fields iprot record{f_RemoveDefinition_result_missingFields=Just s}
        else do
          skip iprot _t185
          read_RemoveDefinition_result_fields iprot record
      _ -> do
        skip iprot _t185
        readFieldEnd iprot
        read_RemoveDefinition_result_fields iprot record
read_RemoveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_result_fields iprot (RemoveDefinition_result{f_RemoveDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_args = DefinitionChildren_args{f_DefinitionChildren_args_defID :: Maybe Int32,f_DefinitionChildren_args_libID :: Maybe Int32,f_DefinitionChildren_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_args_defID record   `hashWithSalt` f_DefinitionChildren_args_libID record   `hashWithSalt` f_DefinitionChildren_args_projectID record  
write_DefinitionChildren_args oprot record = do
  writeStructBegin oprot "DefinitionChildren_args"
  case f_DefinitionChildren_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionChildren_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionChildren_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_args_fields iprot record = do
  (_,_t190,_id191) <- readFieldBegin iprot
  if _t190 == T_STOP then return record else
    case _id191 of 
      1 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_defID=Just s}
        else do
          skip iprot _t190
          read_DefinitionChildren_args_fields iprot record
      2 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_libID=Just s}
        else do
          skip iprot _t190
          read_DefinitionChildren_args_fields iprot record
      3 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_projectID=Just s}
        else do
          skip iprot _t190
          read_DefinitionChildren_args_fields iprot record
      _ -> do
        skip iprot _t190
        readFieldEnd iprot
        read_DefinitionChildren_args_fields iprot record
read_DefinitionChildren_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_args_fields iprot (DefinitionChildren_args{f_DefinitionChildren_args_defID=Nothing,f_DefinitionChildren_args_libID=Nothing,f_DefinitionChildren_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_result = DefinitionChildren_result{f_DefinitionChildren_result_success :: Maybe (Vector.Vector Defs_Types.Definition),f_DefinitionChildren_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_result_success record   `hashWithSalt` f_DefinitionChildren_result_missingFields record  
write_DefinitionChildren_result oprot record = do
  writeStructBegin oprot "DefinitionChildren_result"
  case f_DefinitionChildren_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter194 -> Defs_Types.write_Definition oprot _viter194) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_DefinitionChildren_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_result_fields iprot record = do
  (_,_t196,_id197) <- readFieldBegin iprot
  if _t196 == T_STOP then return record else
    case _id197 of 
      0 -> if _t196 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Definition iprot)) in do {(_etype201,_size198) <- readListBegin iprot; f _size198})
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_success=Just s}
        else do
          skip iprot _t196
          read_DefinitionChildren_result_fields iprot record
      1 -> if _t196 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_missingFields=Just s}
        else do
          skip iprot _t196
          read_DefinitionChildren_result_fields iprot record
      _ -> do
        skip iprot _t196
        readFieldEnd iprot
        read_DefinitionChildren_result_fields iprot record
read_DefinitionChildren_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_result_fields iprot (DefinitionChildren_result{f_DefinitionChildren_result_success=Nothing,f_DefinitionChildren_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_args = DefinitionParent_args{f_DefinitionParent_args_defID :: Maybe Int32,f_DefinitionParent_args_libID :: Maybe Int32,f_DefinitionParent_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_args_defID record   `hashWithSalt` f_DefinitionParent_args_libID record   `hashWithSalt` f_DefinitionParent_args_projectID record  
write_DefinitionParent_args oprot record = do
  writeStructBegin oprot "DefinitionParent_args"
  case f_DefinitionParent_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_args_fields iprot record = do
  (_,_t206,_id207) <- readFieldBegin iprot
  if _t206 == T_STOP then return record else
    case _id207 of 
      1 -> if _t206 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_defID=Just s}
        else do
          skip iprot _t206
          read_DefinitionParent_args_fields iprot record
      2 -> if _t206 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_libID=Just s}
        else do
          skip iprot _t206
          read_DefinitionParent_args_fields iprot record
      3 -> if _t206 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_projectID=Just s}
        else do
          skip iprot _t206
          read_DefinitionParent_args_fields iprot record
      _ -> do
        skip iprot _t206
        readFieldEnd iprot
        read_DefinitionParent_args_fields iprot record
read_DefinitionParent_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_args_fields iprot (DefinitionParent_args{f_DefinitionParent_args_defID=Nothing,f_DefinitionParent_args_libID=Nothing,f_DefinitionParent_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_result = DefinitionParent_result{f_DefinitionParent_result_success :: Maybe Defs_Types.Definition,f_DefinitionParent_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_result_success record   `hashWithSalt` f_DefinitionParent_result_missingFields record  
write_DefinitionParent_result oprot record = do
  writeStructBegin oprot "DefinitionParent_result"
  case f_DefinitionParent_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_result_fields iprot record = do
  (_,_t211,_id212) <- readFieldBegin iprot
  if _t211 == T_STOP then return record else
    case _id212 of 
      0 -> if _t211 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_success=Just s}
        else do
          skip iprot _t211
          read_DefinitionParent_result_fields iprot record
      1 -> if _t211 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_missingFields=Just s}
        else do
          skip iprot _t211
          read_DefinitionParent_result_fields iprot record
      _ -> do
        skip iprot _t211
        readFieldEnd iprot
        read_DefinitionParent_result_fields iprot record
read_DefinitionParent_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_result_fields iprot (DefinitionParent_result{f_DefinitionParent_result_success=Nothing,f_DefinitionParent_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_args = NewTypeModule_args{f_NewTypeModule_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_args_name record  
write_NewTypeModule_args oprot record = do
  writeStructBegin oprot "NewTypeModule_args"
  case f_NewTypeModule_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_args_fields iprot record = do
  (_,_t216,_id217) <- readFieldBegin iprot
  if _t216 == T_STOP then return record else
    case _id217 of 
      1 -> if _t216 == T_STRING then do
        s <- readString iprot
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_name=Just s}
        else do
          skip iprot _t216
          read_NewTypeModule_args_fields iprot record
      _ -> do
        skip iprot _t216
        readFieldEnd iprot
        read_NewTypeModule_args_fields iprot record
read_NewTypeModule_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_args_fields iprot (NewTypeModule_args{f_NewTypeModule_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_result = NewTypeModule_result{f_NewTypeModule_result_success :: Maybe Types_Types.Type,f_NewTypeModule_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_result_success record   `hashWithSalt` f_NewTypeModule_result_missingFields record  
write_NewTypeModule_result oprot record = do
  writeStructBegin oprot "NewTypeModule_result"
  case f_NewTypeModule_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeModule_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_result_fields iprot record = do
  (_,_t221,_id222) <- readFieldBegin iprot
  if _t221 == T_STOP then return record else
    case _id222 of 
      0 -> if _t221 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_success=Just s}
        else do
          skip iprot _t221
          read_NewTypeModule_result_fields iprot record
      1 -> if _t221 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_missingFields=Just s}
        else do
          skip iprot _t221
          read_NewTypeModule_result_fields iprot record
      _ -> do
        skip iprot _t221
        readFieldEnd iprot
        read_NewTypeModule_result_fields iprot record
read_NewTypeModule_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_result_fields iprot (NewTypeModule_result{f_NewTypeModule_result_success=Nothing,f_NewTypeModule_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_args = NewTypeClass_args{f_NewTypeClass_args_name :: Maybe Text,f_NewTypeClass_args_typeparams :: Maybe (Vector.Vector Text),f_NewTypeClass_args_params :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_args_name record   `hashWithSalt` f_NewTypeClass_args_typeparams record   `hashWithSalt` f_NewTypeClass_args_params record  
write_NewTypeClass_args oprot record = do
  writeStructBegin oprot "NewTypeClass_args"
  case f_NewTypeClass_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_args_typeparams record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("typeparams",T_LIST,2)
    (let f = Vector.mapM_ (\_viter225 -> writeString oprot _viter225) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NewTypeClass_args_params record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("params",T_LIST,3)
    (let f = Vector.mapM_ (\_viter226 -> Types_Types.write_Type oprot _viter226) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_args_fields iprot record = do
  (_,_t228,_id229) <- readFieldBegin iprot
  if _t228 == T_STOP then return record else
    case _id229 of 
      1 -> if _t228 == T_STRING then do
        s <- readString iprot
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_name=Just s}
        else do
          skip iprot _t228
          read_NewTypeClass_args_fields iprot record
      2 -> if _t228 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype233,_size230) <- readListBegin iprot; f _size230})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_typeparams=Just s}
        else do
          skip iprot _t228
          read_NewTypeClass_args_fields iprot record
      3 -> if _t228 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype238,_size235) <- readListBegin iprot; f _size235})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_params=Just s}
        else do
          skip iprot _t228
          read_NewTypeClass_args_fields iprot record
      _ -> do
        skip iprot _t228
        readFieldEnd iprot
        read_NewTypeClass_args_fields iprot record
read_NewTypeClass_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_args_fields iprot (NewTypeClass_args{f_NewTypeClass_args_name=Nothing,f_NewTypeClass_args_typeparams=Nothing,f_NewTypeClass_args_params=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_result = NewTypeClass_result{f_NewTypeClass_result_success :: Maybe Types_Types.Type,f_NewTypeClass_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_result_success record   `hashWithSalt` f_NewTypeClass_result_missingFields record  
write_NewTypeClass_result oprot record = do
  writeStructBegin oprot "NewTypeClass_result"
  case f_NewTypeClass_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_result_fields iprot record = do
  (_,_t243,_id244) <- readFieldBegin iprot
  if _t243 == T_STOP then return record else
    case _id244 of 
      0 -> if _t243 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_success=Just s}
        else do
          skip iprot _t243
          read_NewTypeClass_result_fields iprot record
      1 -> if _t243 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_missingFields=Just s}
        else do
          skip iprot _t243
          read_NewTypeClass_result_fields iprot record
      _ -> do
        skip iprot _t243
        readFieldEnd iprot
        read_NewTypeClass_result_fields iprot record
read_NewTypeClass_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_result_fields iprot (NewTypeClass_result{f_NewTypeClass_result_success=Nothing,f_NewTypeClass_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_args = NewTypeFunction_args{f_NewTypeFunction_args_name :: Maybe Text,f_NewTypeFunction_args_inputs :: Maybe Types_Types.Type,f_NewTypeFunction_args_outputs :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_args_name record   `hashWithSalt` f_NewTypeFunction_args_inputs record   `hashWithSalt` f_NewTypeFunction_args_outputs record  
write_NewTypeFunction_args oprot record = do
  writeStructBegin oprot "NewTypeFunction_args"
  case f_NewTypeFunction_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_inputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inputs",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_outputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("outputs",T_STRUCT,3)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_args_fields iprot record = do
  (_,_t248,_id249) <- readFieldBegin iprot
  if _t248 == T_STOP then return record else
    case _id249 of 
      1 -> if _t248 == T_STRING then do
        s <- readString iprot
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_name=Just s}
        else do
          skip iprot _t248
          read_NewTypeFunction_args_fields iprot record
      2 -> if _t248 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_inputs=Just s}
        else do
          skip iprot _t248
          read_NewTypeFunction_args_fields iprot record
      3 -> if _t248 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_outputs=Just s}
        else do
          skip iprot _t248
          read_NewTypeFunction_args_fields iprot record
      _ -> do
        skip iprot _t248
        readFieldEnd iprot
        read_NewTypeFunction_args_fields iprot record
read_NewTypeFunction_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_args_fields iprot (NewTypeFunction_args{f_NewTypeFunction_args_name=Nothing,f_NewTypeFunction_args_inputs=Nothing,f_NewTypeFunction_args_outputs=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_result = NewTypeFunction_result{f_NewTypeFunction_result_success :: Maybe Types_Types.Type,f_NewTypeFunction_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_result_success record   `hashWithSalt` f_NewTypeFunction_result_missingFields record  
write_NewTypeFunction_result oprot record = do
  writeStructBegin oprot "NewTypeFunction_result"
  case f_NewTypeFunction_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_result_fields iprot record = do
  (_,_t253,_id254) <- readFieldBegin iprot
  if _t253 == T_STOP then return record else
    case _id254 of 
      0 -> if _t253 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_success=Just s}
        else do
          skip iprot _t253
          read_NewTypeFunction_result_fields iprot record
      1 -> if _t253 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_missingFields=Just s}
        else do
          skip iprot _t253
          read_NewTypeFunction_result_fields iprot record
      _ -> do
        skip iprot _t253
        readFieldEnd iprot
        read_NewTypeFunction_result_fields iprot record
read_NewTypeFunction_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_result_fields iprot (NewTypeFunction_result{f_NewTypeFunction_result_success=Nothing,f_NewTypeFunction_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeUdefined_args = NewTypeUdefined_args deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_args where
  hashWithSalt salt record = salt  
write_NewTypeUdefined_args oprot record = do
  writeStructBegin oprot "NewTypeUdefined_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_args_fields iprot record = do
  (_,_t258,_id259) <- readFieldBegin iprot
  if _t258 == T_STOP then return record else
    case _id259 of 
      _ -> do
        skip iprot _t258
        readFieldEnd iprot
        read_NewTypeUdefined_args_fields iprot record
read_NewTypeUdefined_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_args_fields iprot (NewTypeUdefined_args{})
  readStructEnd iprot
  return record
data NewTypeUdefined_result = NewTypeUdefined_result{f_NewTypeUdefined_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeUdefined_result_success record  
write_NewTypeUdefined_result oprot record = do
  writeStructBegin oprot "NewTypeUdefined_result"
  case f_NewTypeUdefined_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_result_fields iprot record = do
  (_,_t263,_id264) <- readFieldBegin iprot
  if _t263 == T_STOP then return record else
    case _id264 of 
      0 -> if _t263 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_success=Just s}
        else do
          skip iprot _t263
          read_NewTypeUdefined_result_fields iprot record
      _ -> do
        skip iprot _t263
        readFieldEnd iprot
        read_NewTypeUdefined_result_fields iprot record
read_NewTypeUdefined_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_result_fields iprot (NewTypeUdefined_result{f_NewTypeUdefined_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_args = NewTypeNamed_args{f_NewTypeNamed_args_name :: Maybe Text,f_NewTypeNamed_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_args_name record   `hashWithSalt` f_NewTypeNamed_args_type record  
write_NewTypeNamed_args oprot record = do
  writeStructBegin oprot "NewTypeNamed_args"
  case f_NewTypeNamed_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_args_fields iprot record = do
  (_,_t268,_id269) <- readFieldBegin iprot
  if _t268 == T_STOP then return record else
    case _id269 of 
      1 -> if _t268 == T_STRING then do
        s <- readString iprot
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_name=Just s}
        else do
          skip iprot _t268
          read_NewTypeNamed_args_fields iprot record
      2 -> if _t268 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_type=Just s}
        else do
          skip iprot _t268
          read_NewTypeNamed_args_fields iprot record
      _ -> do
        skip iprot _t268
        readFieldEnd iprot
        read_NewTypeNamed_args_fields iprot record
read_NewTypeNamed_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_args_fields iprot (NewTypeNamed_args{f_NewTypeNamed_args_name=Nothing,f_NewTypeNamed_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_result = NewTypeNamed_result{f_NewTypeNamed_result_success :: Maybe Types_Types.Type,f_NewTypeNamed_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_result_success record   `hashWithSalt` f_NewTypeNamed_result_missingFields record  
write_NewTypeNamed_result oprot record = do
  writeStructBegin oprot "NewTypeNamed_result"
  case f_NewTypeNamed_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_result_fields iprot record = do
  (_,_t273,_id274) <- readFieldBegin iprot
  if _t273 == T_STOP then return record else
    case _id274 of 
      0 -> if _t273 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_success=Just s}
        else do
          skip iprot _t273
          read_NewTypeNamed_result_fields iprot record
      1 -> if _t273 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_missingFields=Just s}
        else do
          skip iprot _t273
          read_NewTypeNamed_result_fields iprot record
      _ -> do
        skip iprot _t273
        readFieldEnd iprot
        read_NewTypeNamed_result_fields iprot record
read_NewTypeNamed_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_result_fields iprot (NewTypeNamed_result{f_NewTypeNamed_result_success=Nothing,f_NewTypeNamed_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_args = NewTypeVariable_args{f_NewTypeVariable_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_args_name record  
write_NewTypeVariable_args oprot record = do
  writeStructBegin oprot "NewTypeVariable_args"
  case f_NewTypeVariable_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_args_fields iprot record = do
  (_,_t278,_id279) <- readFieldBegin iprot
  if _t278 == T_STOP then return record else
    case _id279 of 
      1 -> if _t278 == T_STRING then do
        s <- readString iprot
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_name=Just s}
        else do
          skip iprot _t278
          read_NewTypeVariable_args_fields iprot record
      _ -> do
        skip iprot _t278
        readFieldEnd iprot
        read_NewTypeVariable_args_fields iprot record
read_NewTypeVariable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_args_fields iprot (NewTypeVariable_args{f_NewTypeVariable_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_result = NewTypeVariable_result{f_NewTypeVariable_result_success :: Maybe Types_Types.Type,f_NewTypeVariable_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_result_success record   `hashWithSalt` f_NewTypeVariable_result_missingFields record  
write_NewTypeVariable_result oprot record = do
  writeStructBegin oprot "NewTypeVariable_result"
  case f_NewTypeVariable_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeVariable_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_result_fields iprot record = do
  (_,_t283,_id284) <- readFieldBegin iprot
  if _t283 == T_STOP then return record else
    case _id284 of 
      0 -> if _t283 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_success=Just s}
        else do
          skip iprot _t283
          read_NewTypeVariable_result_fields iprot record
      1 -> if _t283 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_missingFields=Just s}
        else do
          skip iprot _t283
          read_NewTypeVariable_result_fields iprot record
      _ -> do
        skip iprot _t283
        readFieldEnd iprot
        read_NewTypeVariable_result_fields iprot record
read_NewTypeVariable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_result_fields iprot (NewTypeVariable_result{f_NewTypeVariable_result_success=Nothing,f_NewTypeVariable_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_args = NewTypeList_args{f_NewTypeList_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_args_type record  
write_NewTypeList_args oprot record = do
  writeStructBegin oprot "NewTypeList_args"
  case f_NewTypeList_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_args_fields iprot record = do
  (_,_t288,_id289) <- readFieldBegin iprot
  if _t288 == T_STOP then return record else
    case _id289 of 
      1 -> if _t288 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_args_fields iprot record{f_NewTypeList_args_type=Just s}
        else do
          skip iprot _t288
          read_NewTypeList_args_fields iprot record
      _ -> do
        skip iprot _t288
        readFieldEnd iprot
        read_NewTypeList_args_fields iprot record
read_NewTypeList_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_args_fields iprot (NewTypeList_args{f_NewTypeList_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_result = NewTypeList_result{f_NewTypeList_result_success :: Maybe Types_Types.Type,f_NewTypeList_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_result_success record   `hashWithSalt` f_NewTypeList_result_missingFields record  
write_NewTypeList_result oprot record = do
  writeStructBegin oprot "NewTypeList_result"
  case f_NewTypeList_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeList_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_result_fields iprot record = do
  (_,_t293,_id294) <- readFieldBegin iprot
  if _t293 == T_STOP then return record else
    case _id294 of 
      0 -> if _t293 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_success=Just s}
        else do
          skip iprot _t293
          read_NewTypeList_result_fields iprot record
      1 -> if _t293 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_missingFields=Just s}
        else do
          skip iprot _t293
          read_NewTypeList_result_fields iprot record
      _ -> do
        skip iprot _t293
        readFieldEnd iprot
        read_NewTypeList_result_fields iprot record
read_NewTypeList_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_result_fields iprot (NewTypeList_result{f_NewTypeList_result_success=Nothing,f_NewTypeList_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_args = NewTypeTuple_args{f_NewTypeTuple_args_types :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_args_types record  
write_NewTypeTuple_args oprot record = do
  writeStructBegin oprot "NewTypeTuple_args"
  case f_NewTypeTuple_args_types record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("types",T_LIST,1)
    (let f = Vector.mapM_ (\_viter297 -> Types_Types.write_Type oprot _viter297) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_args_fields iprot record = do
  (_,_t299,_id300) <- readFieldBegin iprot
  if _t299 == T_STOP then return record else
    case _id300 of 
      1 -> if _t299 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype304,_size301) <- readListBegin iprot; f _size301})
        read_NewTypeTuple_args_fields iprot record{f_NewTypeTuple_args_types=Just s}
        else do
          skip iprot _t299
          read_NewTypeTuple_args_fields iprot record
      _ -> do
        skip iprot _t299
        readFieldEnd iprot
        read_NewTypeTuple_args_fields iprot record
read_NewTypeTuple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_args_fields iprot (NewTypeTuple_args{f_NewTypeTuple_args_types=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_result = NewTypeTuple_result{f_NewTypeTuple_result_success :: Maybe Types_Types.Type,f_NewTypeTuple_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_result_success record   `hashWithSalt` f_NewTypeTuple_result_missingFields record  
write_NewTypeTuple_result oprot record = do
  writeStructBegin oprot "NewTypeTuple_result"
  case f_NewTypeTuple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeTuple_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_result_fields iprot record = do
  (_,_t309,_id310) <- readFieldBegin iprot
  if _t309 == T_STOP then return record else
    case _id310 of 
      0 -> if _t309 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_success=Just s}
        else do
          skip iprot _t309
          read_NewTypeTuple_result_fields iprot record
      1 -> if _t309 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_missingFields=Just s}
        else do
          skip iprot _t309
          read_NewTypeTuple_result_fields iprot record
      _ -> do
        skip iprot _t309
        readFieldEnd iprot
        read_NewTypeTuple_result_fields iprot record
read_NewTypeTuple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_result_fields iprot (NewTypeTuple_result{f_NewTypeTuple_result_success=Nothing,f_NewTypeTuple_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NodesGraph_args = NodesGraph_args{f_NodesGraph_args_defID :: Maybe Int32,f_NodesGraph_args_libID :: Maybe Int32,f_NodesGraph_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable NodesGraph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodesGraph_args_defID record   `hashWithSalt` f_NodesGraph_args_libID record   `hashWithSalt` f_NodesGraph_args_projectID record  
write_NodesGraph_args oprot record = do
  writeStructBegin oprot "NodesGraph_args"
  case f_NodesGraph_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodesGraph_args_fields iprot record = do
  (_,_t314,_id315) <- readFieldBegin iprot
  if _t314 == T_STOP then return record else
    case _id315 of 
      1 -> if _t314 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_defID=Just s}
        else do
          skip iprot _t314
          read_NodesGraph_args_fields iprot record
      2 -> if _t314 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_libID=Just s}
        else do
          skip iprot _t314
          read_NodesGraph_args_fields iprot record
      3 -> if _t314 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_projectID=Just s}
        else do
          skip iprot _t314
          read_NodesGraph_args_fields iprot record
      _ -> do
        skip iprot _t314
        readFieldEnd iprot
        read_NodesGraph_args_fields iprot record
read_NodesGraph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NodesGraph_args_fields iprot (NodesGraph_args{f_NodesGraph_args_defID=Nothing,f_NodesGraph_args_libID=Nothing,f_NodesGraph_args_projectID=Nothing})
  readStructEnd iprot
  return record
data NodesGraph_result = NodesGraph_result{f_NodesGraph_result_success :: Maybe Graphview_Types.GraphView,f_NodesGraph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NodesGraph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodesGraph_result_success record   `hashWithSalt` f_NodesGraph_result_missingFields record  
write_NodesGraph_result oprot record = do
  writeStructBegin oprot "NodesGraph_result"
  case f_NodesGraph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graphview_Types.write_GraphView oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodesGraph_result_fields iprot record = do
  (_,_t319,_id320) <- readFieldBegin iprot
  if _t319 == T_STOP then return record else
    case _id320 of 
      0 -> if _t319 == T_STRUCT then do
        s <- (read_GraphView iprot)
        read_NodesGraph_result_fields iprot record{f_NodesGraph_result_success=Just s}
        else do
          skip iprot _t319
          read_NodesGraph_result_fields iprot record
      1 -> if _t319 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NodesGraph_result_fields iprot record{f_NodesGraph_result_missingFields=Just s}
        else do
          skip iprot _t319
          read_NodesGraph_result_fields iprot record
      _ -> do
        skip iprot _t319
        readFieldEnd iprot
        read_NodesGraph_result_fields iprot record
read_NodesGraph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NodesGraph_result_fields iprot (NodesGraph_result{f_NodesGraph_result_success=Nothing,f_NodesGraph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NodeByID_args = NodeByID_args{f_NodeByID_args_nodeID :: Maybe Int32,f_NodeByID_args_defID :: Maybe Int32,f_NodeByID_args_libID :: Maybe Int32,f_NodeByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable NodeByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeByID_args_nodeID record   `hashWithSalt` f_NodeByID_args_defID record   `hashWithSalt` f_NodeByID_args_libID record   `hashWithSalt` f_NodeByID_args_projectID record  
write_NodeByID_args oprot record = do
  writeStructBegin oprot "NodeByID_args"
  case f_NodeByID_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeByID_args_fields iprot record = do
  (_,_t324,_id325) <- readFieldBegin iprot
  if _t324 == T_STOP then return record else
    case _id325 of 
      1 -> if _t324 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_nodeID=Just s}
        else do
          skip iprot _t324
          read_NodeByID_args_fields iprot record
      2 -> if _t324 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_defID=Just s}
        else do
          skip iprot _t324
          read_NodeByID_args_fields iprot record
      3 -> if _t324 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_libID=Just s}
        else do
          skip iprot _t324
          read_NodeByID_args_fields iprot record
      4 -> if _t324 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_projectID=Just s}
        else do
          skip iprot _t324
          read_NodeByID_args_fields iprot record
      _ -> do
        skip iprot _t324
        readFieldEnd iprot
        read_NodeByID_args_fields iprot record
read_NodeByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeByID_args_fields iprot (NodeByID_args{f_NodeByID_args_nodeID=Nothing,f_NodeByID_args_defID=Nothing,f_NodeByID_args_libID=Nothing,f_NodeByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data NodeByID_result = NodeByID_result{f_NodeByID_result_success :: Maybe Graph_Types.Node,f_NodeByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NodeByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeByID_result_success record   `hashWithSalt` f_NodeByID_result_missingFields record  
write_NodeByID_result oprot record = do
  writeStructBegin oprot "NodeByID_result"
  case f_NodeByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeByID_result_fields iprot record = do
  (_,_t329,_id330) <- readFieldBegin iprot
  if _t329 == T_STOP then return record else
    case _id330 of 
      0 -> if _t329 == T_STRUCT then do
        s <- (read_Node iprot)
        read_NodeByID_result_fields iprot record{f_NodeByID_result_success=Just s}
        else do
          skip iprot _t329
          read_NodeByID_result_fields iprot record
      1 -> if _t329 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NodeByID_result_fields iprot record{f_NodeByID_result_missingFields=Just s}
        else do
          skip iprot _t329
          read_NodeByID_result_fields iprot record
      _ -> do
        skip iprot _t329
        readFieldEnd iprot
        read_NodeByID_result_fields iprot record
read_NodeByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeByID_result_fields iprot (NodeByID_result{f_NodeByID_result_success=Nothing,f_NodeByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddNode_args = AddNode_args{f_AddNode_args_node :: Maybe Graph_Types.Node,f_AddNode_args_defID :: Maybe Int32,f_AddNode_args_libID :: Maybe Int32,f_AddNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable AddNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_args_node record   `hashWithSalt` f_AddNode_args_defID record   `hashWithSalt` f_AddNode_args_libID record   `hashWithSalt` f_AddNode_args_projectID record  
write_AddNode_args oprot record = do
  writeStructBegin oprot "AddNode_args"
  case f_AddNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_args_fields iprot record = do
  (_,_t334,_id335) <- readFieldBegin iprot
  if _t334 == T_STOP then return record else
    case _id335 of 
      1 -> if _t334 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_node=Just s}
        else do
          skip iprot _t334
          read_AddNode_args_fields iprot record
      2 -> if _t334 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_defID=Just s}
        else do
          skip iprot _t334
          read_AddNode_args_fields iprot record
      3 -> if _t334 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_libID=Just s}
        else do
          skip iprot _t334
          read_AddNode_args_fields iprot record
      4 -> if _t334 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_projectID=Just s}
        else do
          skip iprot _t334
          read_AddNode_args_fields iprot record
      _ -> do
        skip iprot _t334
        readFieldEnd iprot
        read_AddNode_args_fields iprot record
read_AddNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_args_fields iprot (AddNode_args{f_AddNode_args_node=Nothing,f_AddNode_args_defID=Nothing,f_AddNode_args_libID=Nothing,f_AddNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data AddNode_result = AddNode_result{f_AddNode_result_success :: Maybe Graph_Types.Node,f_AddNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_result_success record   `hashWithSalt` f_AddNode_result_missingFields record  
write_AddNode_result oprot record = do
  writeStructBegin oprot "AddNode_result"
  case f_AddNode_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_result_fields iprot record = do
  (_,_t339,_id340) <- readFieldBegin iprot
  if _t339 == T_STOP then return record else
    case _id340 of 
      0 -> if _t339 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_success=Just s}
        else do
          skip iprot _t339
          read_AddNode_result_fields iprot record
      1 -> if _t339 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_missingFields=Just s}
        else do
          skip iprot _t339
          read_AddNode_result_fields iprot record
      _ -> do
        skip iprot _t339
        readFieldEnd iprot
        read_AddNode_result_fields iprot record
read_AddNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_result_fields iprot (AddNode_result{f_AddNode_result_success=Nothing,f_AddNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_args = UpdateNode_args{f_UpdateNode_args_node :: Maybe Graph_Types.Node,f_UpdateNode_args_defID :: Maybe Int32,f_UpdateNode_args_libID :: Maybe Int32,f_UpdateNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_args_node record   `hashWithSalt` f_UpdateNode_args_defID record   `hashWithSalt` f_UpdateNode_args_libID record   `hashWithSalt` f_UpdateNode_args_projectID record  
write_UpdateNode_args oprot record = do
  writeStructBegin oprot "UpdateNode_args"
  case f_UpdateNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_args_fields iprot record = do
  (_,_t344,_id345) <- readFieldBegin iprot
  if _t344 == T_STOP then return record else
    case _id345 of 
      1 -> if _t344 == T_STRUCT then do
        s <- (read_Node iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_node=Just s}
        else do
          skip iprot _t344
          read_UpdateNode_args_fields iprot record
      2 -> if _t344 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_defID=Just s}
        else do
          skip iprot _t344
          read_UpdateNode_args_fields iprot record
      3 -> if _t344 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_libID=Just s}
        else do
          skip iprot _t344
          read_UpdateNode_args_fields iprot record
      4 -> if _t344 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_projectID=Just s}
        else do
          skip iprot _t344
          read_UpdateNode_args_fields iprot record
      _ -> do
        skip iprot _t344
        readFieldEnd iprot
        read_UpdateNode_args_fields iprot record
read_UpdateNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_args_fields iprot (UpdateNode_args{f_UpdateNode_args_node=Nothing,f_UpdateNode_args_defID=Nothing,f_UpdateNode_args_libID=Nothing,f_UpdateNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_result = UpdateNode_result{f_UpdateNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_result_missingFields record  
write_UpdateNode_result oprot record = do
  writeStructBegin oprot "UpdateNode_result"
  case f_UpdateNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_result_fields iprot record = do
  (_,_t349,_id350) <- readFieldBegin iprot
  if _t349 == T_STOP then return record else
    case _id350 of 
      1 -> if _t349 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateNode_result_fields iprot record{f_UpdateNode_result_missingFields=Just s}
        else do
          skip iprot _t349
          read_UpdateNode_result_fields iprot record
      _ -> do
        skip iprot _t349
        readFieldEnd iprot
        read_UpdateNode_result_fields iprot record
read_UpdateNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_result_fields iprot (UpdateNode_result{f_UpdateNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_args = RemoveNode_args{f_RemoveNode_args_nodeID :: Maybe Int32,f_RemoveNode_args_defID :: Maybe Int32,f_RemoveNode_args_libID :: Maybe Int32,f_RemoveNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_args_nodeID record   `hashWithSalt` f_RemoveNode_args_defID record   `hashWithSalt` f_RemoveNode_args_libID record   `hashWithSalt` f_RemoveNode_args_projectID record  
write_RemoveNode_args oprot record = do
  writeStructBegin oprot "RemoveNode_args"
  case f_RemoveNode_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_args_fields iprot record = do
  (_,_t354,_id355) <- readFieldBegin iprot
  if _t354 == T_STOP then return record else
    case _id355 of 
      1 -> if _t354 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_nodeID=Just s}
        else do
          skip iprot _t354
          read_RemoveNode_args_fields iprot record
      2 -> if _t354 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_defID=Just s}
        else do
          skip iprot _t354
          read_RemoveNode_args_fields iprot record
      3 -> if _t354 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_libID=Just s}
        else do
          skip iprot _t354
          read_RemoveNode_args_fields iprot record
      4 -> if _t354 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_projectID=Just s}
        else do
          skip iprot _t354
          read_RemoveNode_args_fields iprot record
      _ -> do
        skip iprot _t354
        readFieldEnd iprot
        read_RemoveNode_args_fields iprot record
read_RemoveNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_args_fields iprot (RemoveNode_args{f_RemoveNode_args_nodeID=Nothing,f_RemoveNode_args_defID=Nothing,f_RemoveNode_args_libID=Nothing,f_RemoveNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_result = RemoveNode_result{f_RemoveNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_result_missingFields record  
write_RemoveNode_result oprot record = do
  writeStructBegin oprot "RemoveNode_result"
  case f_RemoveNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_result_fields iprot record = do
  (_,_t359,_id360) <- readFieldBegin iprot
  if _t359 == T_STOP then return record else
    case _id360 of 
      1 -> if _t359 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveNode_result_fields iprot record{f_RemoveNode_result_missingFields=Just s}
        else do
          skip iprot _t359
          read_RemoveNode_result_fields iprot record
      _ -> do
        skip iprot _t359
        readFieldEnd iprot
        read_RemoveNode_result_fields iprot record
read_RemoveNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_result_fields iprot (RemoveNode_result{f_RemoveNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Connect_args = Connect_args{f_Connect_args_srcNodeID :: Maybe Int32,f_Connect_args_srcPort :: Maybe (Vector.Vector Int32),f_Connect_args_dstNodeID :: Maybe Int32,f_Connect_args_dstPort :: Maybe (Vector.Vector Int32),f_Connect_args_defID :: Maybe Int32,f_Connect_args_libID :: Maybe Int32,f_Connect_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Connect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_args_srcNodeID record   `hashWithSalt` f_Connect_args_srcPort record   `hashWithSalt` f_Connect_args_dstNodeID record   `hashWithSalt` f_Connect_args_dstPort record   `hashWithSalt` f_Connect_args_defID record   `hashWithSalt` f_Connect_args_libID record   `hashWithSalt` f_Connect_args_projectID record  
write_Connect_args oprot record = do
  writeStructBegin oprot "Connect_args"
  case f_Connect_args_srcNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter363 -> writeI32 oprot _viter363) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_dstNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNodeID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter364 -> writeI32 oprot _viter364) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,7)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_args_fields iprot record = do
  (_,_t366,_id367) <- readFieldBegin iprot
  if _t366 == T_STOP then return record else
    case _id367 of 
      1 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_srcNodeID=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      2 -> if _t366 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype371,_size368) <- readListBegin iprot; f _size368})
        read_Connect_args_fields iprot record{f_Connect_args_srcPort=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      3 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_dstNodeID=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      4 -> if _t366 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype376,_size373) <- readListBegin iprot; f _size373})
        read_Connect_args_fields iprot record{f_Connect_args_dstPort=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      5 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_defID=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      6 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_libID=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      7 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_projectID=Just s}
        else do
          skip iprot _t366
          read_Connect_args_fields iprot record
      _ -> do
        skip iprot _t366
        readFieldEnd iprot
        read_Connect_args_fields iprot record
read_Connect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_args_fields iprot (Connect_args{f_Connect_args_srcNodeID=Nothing,f_Connect_args_srcPort=Nothing,f_Connect_args_dstNodeID=Nothing,f_Connect_args_dstPort=Nothing,f_Connect_args_defID=Nothing,f_Connect_args_libID=Nothing,f_Connect_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Connect_result = Connect_result{f_Connect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Connect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_result_missingFields record  
write_Connect_result oprot record = do
  writeStructBegin oprot "Connect_result"
  case f_Connect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_result_fields iprot record = do
  (_,_t381,_id382) <- readFieldBegin iprot
  if _t381 == T_STOP then return record else
    case _id382 of 
      1 -> if _t381 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Connect_result_fields iprot record{f_Connect_result_missingFields=Just s}
        else do
          skip iprot _t381
          read_Connect_result_fields iprot record
      _ -> do
        skip iprot _t381
        readFieldEnd iprot
        read_Connect_result_fields iprot record
read_Connect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_result_fields iprot (Connect_result{f_Connect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Disconnect_args = Disconnect_args{f_Disconnect_args_srcNodeID :: Maybe Int32,f_Disconnect_args_srcPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_dstNodeID :: Maybe Int32,f_Disconnect_args_dstPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_defID :: Maybe Int32,f_Disconnect_args_libID :: Maybe Int32,f_Disconnect_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_args_srcNodeID record   `hashWithSalt` f_Disconnect_args_srcPort record   `hashWithSalt` f_Disconnect_args_dstNodeID record   `hashWithSalt` f_Disconnect_args_dstPort record   `hashWithSalt` f_Disconnect_args_defID record   `hashWithSalt` f_Disconnect_args_libID record   `hashWithSalt` f_Disconnect_args_projectID record  
write_Disconnect_args oprot record = do
  writeStructBegin oprot "Disconnect_args"
  case f_Disconnect_args_srcNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter385 -> writeI32 oprot _viter385) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_dstNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNodeID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter386 -> writeI32 oprot _viter386) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,7)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_args_fields iprot record = do
  (_,_t388,_id389) <- readFieldBegin iprot
  if _t388 == T_STOP then return record else
    case _id389 of 
      1 -> if _t388 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcNodeID=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      2 -> if _t388 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype393,_size390) <- readListBegin iprot; f _size390})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcPort=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      3 -> if _t388 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstNodeID=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      4 -> if _t388 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype398,_size395) <- readListBegin iprot; f _size395})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstPort=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      5 -> if _t388 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_defID=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      6 -> if _t388 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_libID=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      7 -> if _t388 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_projectID=Just s}
        else do
          skip iprot _t388
          read_Disconnect_args_fields iprot record
      _ -> do
        skip iprot _t388
        readFieldEnd iprot
        read_Disconnect_args_fields iprot record
read_Disconnect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_args_fields iprot (Disconnect_args{f_Disconnect_args_srcNodeID=Nothing,f_Disconnect_args_srcPort=Nothing,f_Disconnect_args_dstNodeID=Nothing,f_Disconnect_args_dstPort=Nothing,f_Disconnect_args_defID=Nothing,f_Disconnect_args_libID=Nothing,f_Disconnect_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Disconnect_result = Disconnect_result{f_Disconnect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_result_missingFields record  
write_Disconnect_result oprot record = do
  writeStructBegin oprot "Disconnect_result"
  case f_Disconnect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_result_fields iprot record = do
  (_,_t403,_id404) <- readFieldBegin iprot
  if _t403 == T_STOP then return record else
    case _id404 of 
      1 -> if _t403 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Disconnect_result_fields iprot record{f_Disconnect_result_missingFields=Just s}
        else do
          skip iprot _t403
          read_Disconnect_result_fields iprot record
      _ -> do
        skip iprot _t403
        readFieldEnd iprot
        read_Disconnect_result_fields iprot record
read_Disconnect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_result_fields iprot (Disconnect_result{f_Disconnect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_ls_args = FS_ls_args{f_FS_ls_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_ls_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_ls_args_path record  
write_FS_ls_args oprot record = do
  writeStructBegin oprot "FS_ls_args"
  case f_FS_ls_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_ls_args_fields iprot record = do
  (_,_t408,_id409) <- readFieldBegin iprot
  if _t408 == T_STOP then return record else
    case _id409 of 
      1 -> if _t408 == T_STRING then do
        s <- readString iprot
        read_FS_ls_args_fields iprot record{f_FS_ls_args_path=Just s}
        else do
          skip iprot _t408
          read_FS_ls_args_fields iprot record
      _ -> do
        skip iprot _t408
        readFieldEnd iprot
        read_FS_ls_args_fields iprot record
read_FS_ls_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_ls_args_fields iprot (FS_ls_args{f_FS_ls_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_ls_result = FS_ls_result{f_FS_ls_result_success :: Maybe (Vector.Vector Fs_Types.FSItem),f_FS_ls_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_ls_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_ls_result_success record   `hashWithSalt` f_FS_ls_result_missingFields record  
write_FS_ls_result oprot record = do
  writeStructBegin oprot "FS_ls_result"
  case f_FS_ls_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter412 -> Fs_Types.write_FSItem oprot _viter412) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_FS_ls_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_ls_result_fields iprot record = do
  (_,_t414,_id415) <- readFieldBegin iprot
  if _t414 == T_STOP then return record else
    case _id415 of 
      0 -> if _t414 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_FSItem iprot)) in do {(_etype419,_size416) <- readListBegin iprot; f _size416})
        read_FS_ls_result_fields iprot record{f_FS_ls_result_success=Just s}
        else do
          skip iprot _t414
          read_FS_ls_result_fields iprot record
      1 -> if _t414 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_ls_result_fields iprot record{f_FS_ls_result_missingFields=Just s}
        else do
          skip iprot _t414
          read_FS_ls_result_fields iprot record
      _ -> do
        skip iprot _t414
        readFieldEnd iprot
        read_FS_ls_result_fields iprot record
read_FS_ls_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_ls_result_fields iprot (FS_ls_result{f_FS_ls_result_success=Nothing,f_FS_ls_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_stat_args = FS_stat_args{f_FS_stat_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_stat_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_stat_args_path record  
write_FS_stat_args oprot record = do
  writeStructBegin oprot "FS_stat_args"
  case f_FS_stat_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_stat_args_fields iprot record = do
  (_,_t424,_id425) <- readFieldBegin iprot
  if _t424 == T_STOP then return record else
    case _id425 of 
      1 -> if _t424 == T_STRING then do
        s <- readString iprot
        read_FS_stat_args_fields iprot record{f_FS_stat_args_path=Just s}
        else do
          skip iprot _t424
          read_FS_stat_args_fields iprot record
      _ -> do
        skip iprot _t424
        readFieldEnd iprot
        read_FS_stat_args_fields iprot record
read_FS_stat_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_stat_args_fields iprot (FS_stat_args{f_FS_stat_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_stat_result = FS_stat_result{f_FS_stat_result_success :: Maybe Fs_Types.FSItem,f_FS_stat_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_stat_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_stat_result_success record   `hashWithSalt` f_FS_stat_result_missingFields record  
write_FS_stat_result oprot record = do
  writeStructBegin oprot "FS_stat_result"
  case f_FS_stat_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Fs_Types.write_FSItem oprot _v
    writeFieldEnd oprot}
  case f_FS_stat_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_stat_result_fields iprot record = do
  (_,_t429,_id430) <- readFieldBegin iprot
  if _t429 == T_STOP then return record else
    case _id430 of 
      0 -> if _t429 == T_STRUCT then do
        s <- (read_FSItem iprot)
        read_FS_stat_result_fields iprot record{f_FS_stat_result_success=Just s}
        else do
          skip iprot _t429
          read_FS_stat_result_fields iprot record
      1 -> if _t429 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_stat_result_fields iprot record{f_FS_stat_result_missingFields=Just s}
        else do
          skip iprot _t429
          read_FS_stat_result_fields iprot record
      _ -> do
        skip iprot _t429
        readFieldEnd iprot
        read_FS_stat_result_fields iprot record
read_FS_stat_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_stat_result_fields iprot (FS_stat_result{f_FS_stat_result_success=Nothing,f_FS_stat_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_mkdir_args = FS_mkdir_args{f_FS_mkdir_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_mkdir_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mkdir_args_path record  
write_FS_mkdir_args oprot record = do
  writeStructBegin oprot "FS_mkdir_args"
  case f_FS_mkdir_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mkdir_args_fields iprot record = do
  (_,_t434,_id435) <- readFieldBegin iprot
  if _t434 == T_STOP then return record else
    case _id435 of 
      1 -> if _t434 == T_STRING then do
        s <- readString iprot
        read_FS_mkdir_args_fields iprot record{f_FS_mkdir_args_path=Just s}
        else do
          skip iprot _t434
          read_FS_mkdir_args_fields iprot record
      _ -> do
        skip iprot _t434
        readFieldEnd iprot
        read_FS_mkdir_args_fields iprot record
read_FS_mkdir_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mkdir_args_fields iprot (FS_mkdir_args{f_FS_mkdir_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_mkdir_result = FS_mkdir_result{f_FS_mkdir_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_mkdir_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mkdir_result_missingFields record  
write_FS_mkdir_result oprot record = do
  writeStructBegin oprot "FS_mkdir_result"
  case f_FS_mkdir_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mkdir_result_fields iprot record = do
  (_,_t439,_id440) <- readFieldBegin iprot
  if _t439 == T_STOP then return record else
    case _id440 of 
      1 -> if _t439 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_mkdir_result_fields iprot record{f_FS_mkdir_result_missingFields=Just s}
        else do
          skip iprot _t439
          read_FS_mkdir_result_fields iprot record
      _ -> do
        skip iprot _t439
        readFieldEnd iprot
        read_FS_mkdir_result_fields iprot record
read_FS_mkdir_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mkdir_result_fields iprot (FS_mkdir_result{f_FS_mkdir_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_touch_args = FS_touch_args{f_FS_touch_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_touch_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_touch_args_path record  
write_FS_touch_args oprot record = do
  writeStructBegin oprot "FS_touch_args"
  case f_FS_touch_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_touch_args_fields iprot record = do
  (_,_t444,_id445) <- readFieldBegin iprot
  if _t444 == T_STOP then return record else
    case _id445 of 
      1 -> if _t444 == T_STRING then do
        s <- readString iprot
        read_FS_touch_args_fields iprot record{f_FS_touch_args_path=Just s}
        else do
          skip iprot _t444
          read_FS_touch_args_fields iprot record
      _ -> do
        skip iprot _t444
        readFieldEnd iprot
        read_FS_touch_args_fields iprot record
read_FS_touch_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_touch_args_fields iprot (FS_touch_args{f_FS_touch_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_touch_result = FS_touch_result{f_FS_touch_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_touch_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_touch_result_missingFields record  
write_FS_touch_result oprot record = do
  writeStructBegin oprot "FS_touch_result"
  case f_FS_touch_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_touch_result_fields iprot record = do
  (_,_t449,_id450) <- readFieldBegin iprot
  if _t449 == T_STOP then return record else
    case _id450 of 
      1 -> if _t449 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_touch_result_fields iprot record{f_FS_touch_result_missingFields=Just s}
        else do
          skip iprot _t449
          read_FS_touch_result_fields iprot record
      _ -> do
        skip iprot _t449
        readFieldEnd iprot
        read_FS_touch_result_fields iprot record
read_FS_touch_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_touch_result_fields iprot (FS_touch_result{f_FS_touch_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_rm_args = FS_rm_args{f_FS_rm_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_rm_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_rm_args_path record  
write_FS_rm_args oprot record = do
  writeStructBegin oprot "FS_rm_args"
  case f_FS_rm_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_rm_args_fields iprot record = do
  (_,_t454,_id455) <- readFieldBegin iprot
  if _t454 == T_STOP then return record else
    case _id455 of 
      1 -> if _t454 == T_STRING then do
        s <- readString iprot
        read_FS_rm_args_fields iprot record{f_FS_rm_args_path=Just s}
        else do
          skip iprot _t454
          read_FS_rm_args_fields iprot record
      _ -> do
        skip iprot _t454
        readFieldEnd iprot
        read_FS_rm_args_fields iprot record
read_FS_rm_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_rm_args_fields iprot (FS_rm_args{f_FS_rm_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_rm_result = FS_rm_result{f_FS_rm_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_rm_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_rm_result_missingFields record  
write_FS_rm_result oprot record = do
  writeStructBegin oprot "FS_rm_result"
  case f_FS_rm_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_rm_result_fields iprot record = do
  (_,_t459,_id460) <- readFieldBegin iprot
  if _t459 == T_STOP then return record else
    case _id460 of 
      1 -> if _t459 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_rm_result_fields iprot record{f_FS_rm_result_missingFields=Just s}
        else do
          skip iprot _t459
          read_FS_rm_result_fields iprot record
      _ -> do
        skip iprot _t459
        readFieldEnd iprot
        read_FS_rm_result_fields iprot record
read_FS_rm_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_rm_result_fields iprot (FS_rm_result{f_FS_rm_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_cp_args = FS_cp_args{f_FS_cp_args_src :: Maybe Text,f_FS_cp_args_dst :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_cp_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_cp_args_src record   `hashWithSalt` f_FS_cp_args_dst record  
write_FS_cp_args oprot record = do
  writeStructBegin oprot "FS_cp_args"
  case f_FS_cp_args_src record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("src",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_FS_cp_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_cp_args_fields iprot record = do
  (_,_t464,_id465) <- readFieldBegin iprot
  if _t464 == T_STOP then return record else
    case _id465 of 
      1 -> if _t464 == T_STRING then do
        s <- readString iprot
        read_FS_cp_args_fields iprot record{f_FS_cp_args_src=Just s}
        else do
          skip iprot _t464
          read_FS_cp_args_fields iprot record
      2 -> if _t464 == T_STRING then do
        s <- readString iprot
        read_FS_cp_args_fields iprot record{f_FS_cp_args_dst=Just s}
        else do
          skip iprot _t464
          read_FS_cp_args_fields iprot record
      _ -> do
        skip iprot _t464
        readFieldEnd iprot
        read_FS_cp_args_fields iprot record
read_FS_cp_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_cp_args_fields iprot (FS_cp_args{f_FS_cp_args_src=Nothing,f_FS_cp_args_dst=Nothing})
  readStructEnd iprot
  return record
data FS_cp_result = FS_cp_result{f_FS_cp_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_cp_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_cp_result_missingFields record  
write_FS_cp_result oprot record = do
  writeStructBegin oprot "FS_cp_result"
  case f_FS_cp_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_cp_result_fields iprot record = do
  (_,_t469,_id470) <- readFieldBegin iprot
  if _t469 == T_STOP then return record else
    case _id470 of 
      1 -> if _t469 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_cp_result_fields iprot record{f_FS_cp_result_missingFields=Just s}
        else do
          skip iprot _t469
          read_FS_cp_result_fields iprot record
      _ -> do
        skip iprot _t469
        readFieldEnd iprot
        read_FS_cp_result_fields iprot record
read_FS_cp_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_cp_result_fields iprot (FS_cp_result{f_FS_cp_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_mv_args = FS_mv_args{f_FS_mv_args_src :: Maybe Text,f_FS_mv_args_dst :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_mv_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mv_args_src record   `hashWithSalt` f_FS_mv_args_dst record  
write_FS_mv_args oprot record = do
  writeStructBegin oprot "FS_mv_args"
  case f_FS_mv_args_src record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("src",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_FS_mv_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mv_args_fields iprot record = do
  (_,_t474,_id475) <- readFieldBegin iprot
  if _t474 == T_STOP then return record else
    case _id475 of 
      1 -> if _t474 == T_STRING then do
        s <- readString iprot
        read_FS_mv_args_fields iprot record{f_FS_mv_args_src=Just s}
        else do
          skip iprot _t474
          read_FS_mv_args_fields iprot record
      2 -> if _t474 == T_STRING then do
        s <- readString iprot
        read_FS_mv_args_fields iprot record{f_FS_mv_args_dst=Just s}
        else do
          skip iprot _t474
          read_FS_mv_args_fields iprot record
      _ -> do
        skip iprot _t474
        readFieldEnd iprot
        read_FS_mv_args_fields iprot record
read_FS_mv_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mv_args_fields iprot (FS_mv_args{f_FS_mv_args_src=Nothing,f_FS_mv_args_dst=Nothing})
  readStructEnd iprot
  return record
data FS_mv_result = FS_mv_result{f_FS_mv_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_mv_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mv_result_missingFields record  
write_FS_mv_result oprot record = do
  writeStructBegin oprot "FS_mv_result"
  case f_FS_mv_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mv_result_fields iprot record = do
  (_,_t479,_id480) <- readFieldBegin iprot
  if _t479 == T_STOP then return record else
    case _id480 of 
      1 -> if _t479 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_mv_result_fields iprot record{f_FS_mv_result_missingFields=Just s}
        else do
          skip iprot _t479
          read_FS_mv_result_fields iprot record
      _ -> do
        skip iprot _t479
        readFieldEnd iprot
        read_FS_mv_result_fields iprot record
read_FS_mv_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mv_result_fields iprot (FS_mv_result{f_FS_mv_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Ping_args = Ping_args deriving (Show,Eq,Typeable)
instance Hashable Ping_args where
  hashWithSalt salt record = salt  
write_Ping_args oprot record = do
  writeStructBegin oprot "Ping_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_args_fields iprot record = do
  (_,_t484,_id485) <- readFieldBegin iprot
  if _t484 == T_STOP then return record else
    case _id485 of 
      _ -> do
        skip iprot _t484
        readFieldEnd iprot
        read_Ping_args_fields iprot record
read_Ping_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_args_fields iprot (Ping_args{})
  readStructEnd iprot
  return record
data Ping_result = Ping_result deriving (Show,Eq,Typeable)
instance Hashable Ping_result where
  hashWithSalt salt record = salt  
write_Ping_result oprot record = do
  writeStructBegin oprot "Ping_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_result_fields iprot record = do
  (_,_t489,_id490) <- readFieldBegin iprot
  if _t489 == T_STOP then return record else
    case _id490 of 
      _ -> do
        skip iprot _t489
        readFieldEnd iprot
        read_Ping_result_fields iprot record
read_Ping_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_result_fields iprot (Ping_result{})
  readStructEnd iprot
  return record
data Dump_args = Dump_args deriving (Show,Eq,Typeable)
instance Hashable Dump_args where
  hashWithSalt salt record = salt  
write_Dump_args oprot record = do
  writeStructBegin oprot "Dump_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Dump_args_fields iprot record = do
  (_,_t494,_id495) <- readFieldBegin iprot
  if _t494 == T_STOP then return record else
    case _id495 of 
      _ -> do
        skip iprot _t494
        readFieldEnd iprot
        read_Dump_args_fields iprot record
read_Dump_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Dump_args_fields iprot (Dump_args{})
  readStructEnd iprot
  return record
data Dump_result = Dump_result deriving (Show,Eq,Typeable)
instance Hashable Dump_result where
  hashWithSalt salt record = salt  
write_Dump_result oprot record = do
  writeStructBegin oprot "Dump_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Dump_result_fields iprot record = do
  (_,_t499,_id500) <- readFieldBegin iprot
  if _t499 == T_STOP then return record else
    case _id500 of 
      _ -> do
        skip iprot _t499
        readFieldEnd iprot
        read_Dump_result_fields iprot record
read_Dump_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Dump_result_fields iprot (Dump_result{})
  readStructEnd iprot
  return record
process_projects (seqid, iprot, oprot, handler) = do
  args <- read_Projects_args iprot
  readMessageEnd iprot
  rs <- return (Projects_result Nothing)
  res <- (do
    res <- Iface.projects handler
    return rs{f_Projects_result_success= Just res})
  writeMessageBegin oprot ("projects", M_REPLY, seqid);
  write_Projects_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createProject (seqid, iprot, oprot, handler) = do
  args <- read_CreateProject_args iprot
  readMessageEnd iprot
  rs <- return (CreateProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createProject handler (f_CreateProject_args_project args)
      return rs{f_CreateProject_result_success= Just res})
    (\e  -> 
      return rs{f_CreateProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("createProject", M_REPLY, seqid);
  write_CreateProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_openProject (seqid, iprot, oprot, handler) = do
  args <- read_OpenProject_args iprot
  readMessageEnd iprot
  rs <- return (OpenProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.openProject handler (f_OpenProject_args_path args)
      return rs{f_OpenProject_result_success= Just res})
    (\e  -> 
      return rs{f_OpenProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("openProject", M_REPLY, seqid);
  write_OpenProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_closeProject (seqid, iprot, oprot, handler) = do
  args <- read_CloseProject_args iprot
  readMessageEnd iprot
  rs <- return (CloseProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.closeProject handler (f_CloseProject_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_CloseProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("closeProject", M_REPLY, seqid);
  write_CloseProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_storeProject (seqid, iprot, oprot, handler) = do
  args <- read_StoreProject_args iprot
  readMessageEnd iprot
  rs <- return (StoreProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.storeProject handler (f_StoreProject_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_StoreProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("storeProject", M_REPLY, seqid);
  write_StoreProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraries (seqid, iprot, oprot, handler) = do
  args <- read_Libraries_args iprot
  readMessageEnd iprot
  rs <- return (Libraries_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraries handler (f_Libraries_args_projectID args)
      return rs{f_Libraries_result_success= Just res})
    (\e  -> 
      return rs{f_Libraries_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraries", M_REPLY, seqid);
  write_Libraries_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createLibrary (seqid, iprot, oprot, handler) = do
  args <- read_CreateLibrary_args iprot
  readMessageEnd iprot
  rs <- return (CreateLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createLibrary handler (f_CreateLibrary_args_library args) (f_CreateLibrary_args_projectID args)
      return rs{f_CreateLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_CreateLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("createLibrary", M_REPLY, seqid);
  write_CreateLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_loadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_LoadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (LoadLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.loadLibrary handler (f_LoadLibrary_args_path args) (f_LoadLibrary_args_projectID args)
      return rs{f_LoadLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_LoadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("loadLibrary", M_REPLY, seqid);
  write_LoadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_unloadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_UnloadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (UnloadLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.unloadLibrary handler (f_UnloadLibrary_args_libID args) (f_UnloadLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UnloadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("unloadLibrary", M_REPLY, seqid);
  write_UnloadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_storeLibrary (seqid, iprot, oprot, handler) = do
  args <- read_StoreLibrary_args iprot
  readMessageEnd iprot
  rs <- return (StoreLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.storeLibrary handler (f_StoreLibrary_args_libID args) (f_StoreLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_StoreLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("storeLibrary", M_REPLY, seqid);
  write_StoreLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_buildLibrary (seqid, iprot, oprot, handler) = do
  args <- read_BuildLibrary_args iprot
  readMessageEnd iprot
  rs <- return (BuildLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.buildLibrary handler (f_BuildLibrary_args_libID args) (f_BuildLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_BuildLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("buildLibrary", M_REPLY, seqid);
  write_BuildLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraryRootDef (seqid, iprot, oprot, handler) = do
  args <- read_LibraryRootDef_args iprot
  readMessageEnd iprot
  rs <- return (LibraryRootDef_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraryRootDef handler (f_LibraryRootDef_args_libID args) (f_LibraryRootDef_args_projectID args)
      return rs{f_LibraryRootDef_result_success= Just res})
    (\e  -> 
      return rs{f_LibraryRootDef_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraryRootDef", M_REPLY, seqid);
  write_LibraryRootDef_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_defsGraph (seqid, iprot, oprot, handler) = do
  args <- read_DefsGraph_args iprot
  readMessageEnd iprot
  rs <- return (DefsGraph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.defsGraph handler (f_DefsGraph_args_libID args) (f_DefsGraph_args_projectID args)
      return rs{f_DefsGraph_result_success= Just res})
    (\e  -> 
      return rs{f_DefsGraph_result_missingFields =Just e}))
  writeMessageBegin oprot ("defsGraph", M_REPLY, seqid);
  write_DefsGraph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_defByID (seqid, iprot, oprot, handler) = do
  args <- read_DefByID_args iprot
  readMessageEnd iprot
  rs <- return (DefByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.defByID handler (f_DefByID_args_defID args) (f_DefByID_args_libID args) (f_DefByID_args_projectID args)
      return rs{f_DefByID_result_success= Just res})
    (\e  -> 
      return rs{f_DefByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("defByID", M_REPLY, seqid);
  write_DefByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addDefinition (seqid, iprot, oprot, handler) = do
  args <- read_AddDefinition_args iprot
  readMessageEnd iprot
  rs <- return (AddDefinition_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addDefinition handler (f_AddDefinition_args_definition args) (f_AddDefinition_args_parentID args) (f_AddDefinition_args_libID args) (f_AddDefinition_args_projectID args)
      return rs{f_AddDefinition_result_success= Just res})
    (\e  -> 
      return rs{f_AddDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("addDefinition", M_REPLY, seqid);
  write_AddDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateDefinition (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDefinition_args iprot
  readMessageEnd iprot
  rs <- return (UpdateDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateDefinition handler (f_UpdateDefinition_args_definition args) (f_UpdateDefinition_args_libID args) (f_UpdateDefinition_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UpdateDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateDefinition", M_REPLY, seqid);
  write_UpdateDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeDefinition (seqid, iprot, oprot, handler) = do
  args <- read_RemoveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (RemoveDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeDefinition handler (f_RemoveDefinition_args_defID args) (f_RemoveDefinition_args_libID args) (f_RemoveDefinition_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_RemoveDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeDefinition", M_REPLY, seqid);
  write_RemoveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionChildren (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionChildren_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionChildren_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionChildren handler (f_DefinitionChildren_args_defID args) (f_DefinitionChildren_args_libID args) (f_DefinitionChildren_args_projectID args)
      return rs{f_DefinitionChildren_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionChildren_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionChildren", M_REPLY, seqid);
  write_DefinitionChildren_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionParent (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionParent_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionParent_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionParent handler (f_DefinitionParent_args_defID args) (f_DefinitionParent_args_libID args) (f_DefinitionParent_args_projectID args)
      return rs{f_DefinitionParent_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionParent_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionParent", M_REPLY, seqid);
  write_DefinitionParent_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeModule (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeModule_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeModule_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeModule handler (f_NewTypeModule_args_name args)
      return rs{f_NewTypeModule_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeModule_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeModule", M_REPLY, seqid);
  write_NewTypeModule_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeClass (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeClass_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeClass_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeClass handler (f_NewTypeClass_args_name args) (f_NewTypeClass_args_typeparams args) (f_NewTypeClass_args_params args)
      return rs{f_NewTypeClass_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeClass_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeClass", M_REPLY, seqid);
  write_NewTypeClass_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeFunction (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeFunction_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeFunction_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeFunction handler (f_NewTypeFunction_args_name args) (f_NewTypeFunction_args_inputs args) (f_NewTypeFunction_args_outputs args)
      return rs{f_NewTypeFunction_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeFunction_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeFunction", M_REPLY, seqid);
  write_NewTypeFunction_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeUdefined (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeUdefined_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeUdefined_result Nothing)
  res <- (do
    res <- Iface.newTypeUdefined handler
    return rs{f_NewTypeUdefined_result_success= Just res})
  writeMessageBegin oprot ("newTypeUdefined", M_REPLY, seqid);
  write_NewTypeUdefined_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeNamed (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeNamed_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeNamed_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeNamed handler (f_NewTypeNamed_args_name args) (f_NewTypeNamed_args_type args)
      return rs{f_NewTypeNamed_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeNamed_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeNamed", M_REPLY, seqid);
  write_NewTypeNamed_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeVariable (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeVariable_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeVariable_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeVariable handler (f_NewTypeVariable_args_name args)
      return rs{f_NewTypeVariable_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeVariable_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeVariable", M_REPLY, seqid);
  write_NewTypeVariable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeList (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeList_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeList_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeList handler (f_NewTypeList_args_type args)
      return rs{f_NewTypeList_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeList_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeList", M_REPLY, seqid);
  write_NewTypeList_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeTuple (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeTuple_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeTuple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeTuple handler (f_NewTypeTuple_args_types args)
      return rs{f_NewTypeTuple_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeTuple_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeTuple", M_REPLY, seqid);
  write_NewTypeTuple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_nodesGraph (seqid, iprot, oprot, handler) = do
  args <- read_NodesGraph_args iprot
  readMessageEnd iprot
  rs <- return (NodesGraph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.nodesGraph handler (f_NodesGraph_args_defID args) (f_NodesGraph_args_libID args) (f_NodesGraph_args_projectID args)
      return rs{f_NodesGraph_result_success= Just res})
    (\e  -> 
      return rs{f_NodesGraph_result_missingFields =Just e}))
  writeMessageBegin oprot ("nodesGraph", M_REPLY, seqid);
  write_NodesGraph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_nodeByID (seqid, iprot, oprot, handler) = do
  args <- read_NodeByID_args iprot
  readMessageEnd iprot
  rs <- return (NodeByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.nodeByID handler (f_NodeByID_args_nodeID args) (f_NodeByID_args_defID args) (f_NodeByID_args_libID args) (f_NodeByID_args_projectID args)
      return rs{f_NodeByID_result_success= Just res})
    (\e  -> 
      return rs{f_NodeByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("nodeByID", M_REPLY, seqid);
  write_NodeByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addNode (seqid, iprot, oprot, handler) = do
  args <- read_AddNode_args iprot
  readMessageEnd iprot
  rs <- return (AddNode_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addNode handler (f_AddNode_args_node args) (f_AddNode_args_defID args) (f_AddNode_args_libID args) (f_AddNode_args_projectID args)
      return rs{f_AddNode_result_success= Just res})
    (\e  -> 
      return rs{f_AddNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("addNode", M_REPLY, seqid);
  write_AddNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateNode (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNode_args iprot
  readMessageEnd iprot
  rs <- return (UpdateNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateNode handler (f_UpdateNode_args_node args) (f_UpdateNode_args_defID args) (f_UpdateNode_args_libID args) (f_UpdateNode_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UpdateNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateNode", M_REPLY, seqid);
  write_UpdateNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNode (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNode_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeNode handler (f_RemoveNode_args_nodeID args) (f_RemoveNode_args_defID args) (f_RemoveNode_args_libID args) (f_RemoveNode_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_RemoveNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeNode", M_REPLY, seqid);
  write_RemoveNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_connect (seqid, iprot, oprot, handler) = do
  args <- read_Connect_args iprot
  readMessageEnd iprot
  rs <- return (Connect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.connect handler (f_Connect_args_srcNodeID args) (f_Connect_args_srcPort args) (f_Connect_args_dstNodeID args) (f_Connect_args_dstPort args) (f_Connect_args_defID args) (f_Connect_args_libID args) (f_Connect_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_Connect_result_missingFields =Just e}))
  writeMessageBegin oprot ("connect", M_REPLY, seqid);
  write_Connect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disconnect (seqid, iprot, oprot, handler) = do
  args <- read_Disconnect_args iprot
  readMessageEnd iprot
  rs <- return (Disconnect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.disconnect handler (f_Disconnect_args_srcNodeID args) (f_Disconnect_args_srcPort args) (f_Disconnect_args_dstNodeID args) (f_Disconnect_args_dstPort args) (f_Disconnect_args_defID args) (f_Disconnect_args_libID args) (f_Disconnect_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_Disconnect_result_missingFields =Just e}))
  writeMessageBegin oprot ("disconnect", M_REPLY, seqid);
  write_Disconnect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_ls (seqid, iprot, oprot, handler) = do
  args <- read_FS_ls_args iprot
  readMessageEnd iprot
  rs <- return (FS_ls_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.fS_ls handler (f_FS_ls_args_path args)
      return rs{f_FS_ls_result_success= Just res})
    (\e  -> 
      return rs{f_FS_ls_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_ls", M_REPLY, seqid);
  write_FS_ls_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_stat (seqid, iprot, oprot, handler) = do
  args <- read_FS_stat_args iprot
  readMessageEnd iprot
  rs <- return (FS_stat_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.fS_stat handler (f_FS_stat_args_path args)
      return rs{f_FS_stat_result_success= Just res})
    (\e  -> 
      return rs{f_FS_stat_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_stat", M_REPLY, seqid);
  write_FS_stat_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_mkdir (seqid, iprot, oprot, handler) = do
  args <- read_FS_mkdir_args iprot
  readMessageEnd iprot
  rs <- return (FS_mkdir_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_mkdir handler (f_FS_mkdir_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_mkdir_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_mkdir", M_REPLY, seqid);
  write_FS_mkdir_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_touch (seqid, iprot, oprot, handler) = do
  args <- read_FS_touch_args iprot
  readMessageEnd iprot
  rs <- return (FS_touch_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_touch handler (f_FS_touch_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_touch_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_touch", M_REPLY, seqid);
  write_FS_touch_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_rm (seqid, iprot, oprot, handler) = do
  args <- read_FS_rm_args iprot
  readMessageEnd iprot
  rs <- return (FS_rm_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_rm handler (f_FS_rm_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_rm_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_rm", M_REPLY, seqid);
  write_FS_rm_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_cp (seqid, iprot, oprot, handler) = do
  args <- read_FS_cp_args iprot
  readMessageEnd iprot
  rs <- return (FS_cp_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_cp handler (f_FS_cp_args_src args) (f_FS_cp_args_dst args)
      return rs)
    (\e  -> 
      return rs{f_FS_cp_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_cp", M_REPLY, seqid);
  write_FS_cp_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_mv (seqid, iprot, oprot, handler) = do
  args <- read_FS_mv_args iprot
  readMessageEnd iprot
  rs <- return (FS_mv_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_mv handler (f_FS_mv_args_src args) (f_FS_mv_args_dst args)
      return rs)
    (\e  -> 
      return rs{f_FS_mv_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_mv", M_REPLY, seqid);
  write_FS_mv_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  readMessageEnd iprot
  rs <- return (Ping_result)
  res <- (do
    Iface.ping handler
    return rs)
  writeMessageBegin oprot ("ping", M_REPLY, seqid);
  write_Ping_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_dump (seqid, iprot, oprot, handler) = do
  args <- read_Dump_args iprot
  readMessageEnd iprot
  rs <- return (Dump_result)
  res <- (do
    Iface.dump handler
    return rs)
  writeMessageBegin oprot ("dump", M_REPLY, seqid);
  write_Dump_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "projects" -> process_projects (seqid,iprot,oprot,handler)
  "createProject" -> process_createProject (seqid,iprot,oprot,handler)
  "openProject" -> process_openProject (seqid,iprot,oprot,handler)
  "closeProject" -> process_closeProject (seqid,iprot,oprot,handler)
  "storeProject" -> process_storeProject (seqid,iprot,oprot,handler)
  "libraries" -> process_libraries (seqid,iprot,oprot,handler)
  "createLibrary" -> process_createLibrary (seqid,iprot,oprot,handler)
  "loadLibrary" -> process_loadLibrary (seqid,iprot,oprot,handler)
  "unloadLibrary" -> process_unloadLibrary (seqid,iprot,oprot,handler)
  "storeLibrary" -> process_storeLibrary (seqid,iprot,oprot,handler)
  "buildLibrary" -> process_buildLibrary (seqid,iprot,oprot,handler)
  "libraryRootDef" -> process_libraryRootDef (seqid,iprot,oprot,handler)
  "defsGraph" -> process_defsGraph (seqid,iprot,oprot,handler)
  "defByID" -> process_defByID (seqid,iprot,oprot,handler)
  "addDefinition" -> process_addDefinition (seqid,iprot,oprot,handler)
  "updateDefinition" -> process_updateDefinition (seqid,iprot,oprot,handler)
  "removeDefinition" -> process_removeDefinition (seqid,iprot,oprot,handler)
  "definitionChildren" -> process_definitionChildren (seqid,iprot,oprot,handler)
  "definitionParent" -> process_definitionParent (seqid,iprot,oprot,handler)
  "newTypeModule" -> process_newTypeModule (seqid,iprot,oprot,handler)
  "newTypeClass" -> process_newTypeClass (seqid,iprot,oprot,handler)
  "newTypeFunction" -> process_newTypeFunction (seqid,iprot,oprot,handler)
  "newTypeUdefined" -> process_newTypeUdefined (seqid,iprot,oprot,handler)
  "newTypeNamed" -> process_newTypeNamed (seqid,iprot,oprot,handler)
  "newTypeVariable" -> process_newTypeVariable (seqid,iprot,oprot,handler)
  "newTypeList" -> process_newTypeList (seqid,iprot,oprot,handler)
  "newTypeTuple" -> process_newTypeTuple (seqid,iprot,oprot,handler)
  "nodesGraph" -> process_nodesGraph (seqid,iprot,oprot,handler)
  "nodeByID" -> process_nodeByID (seqid,iprot,oprot,handler)
  "addNode" -> process_addNode (seqid,iprot,oprot,handler)
  "updateNode" -> process_updateNode (seqid,iprot,oprot,handler)
  "removeNode" -> process_removeNode (seqid,iprot,oprot,handler)
  "connect" -> process_connect (seqid,iprot,oprot,handler)
  "disconnect" -> process_disconnect (seqid,iprot,oprot,handler)
  "FS_ls" -> process_fS_ls (seqid,iprot,oprot,handler)
  "FS_stat" -> process_fS_stat (seqid,iprot,oprot,handler)
  "FS_mkdir" -> process_fS_mkdir (seqid,iprot,oprot,handler)
  "FS_touch" -> process_fS_touch (seqid,iprot,oprot,handler)
  "FS_rm" -> process_fS_rm (seqid,iprot,oprot,handler)
  "FS_cp" -> process_fS_cp (seqid,iprot,oprot,handler)
  "FS_mv" -> process_fS_mv (seqid,iprot,oprot,handler)
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  "dump" -> process_dump (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
