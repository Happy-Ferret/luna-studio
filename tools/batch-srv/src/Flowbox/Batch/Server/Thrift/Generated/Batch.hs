{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import           Control.Exception      
import           Data.ByteString.Lazy   
import           Data.Hashable          
import           Data.Int               
import           Data.Text.Lazy         ( Text )
import qualified Data.Text.Lazy       as TL
import           Data.Typeable          ( Typeable )
import qualified Data.HashMap.Strict  as Map
import qualified Data.HashSet         as Set
import qualified Data.Vector          as Vector

import           Thrift                 
import           Thrift.Types           ()

import           Fs_Types               
import           Graphview_Types        
import           Projects_Types         
import           Attrs_Types            
import           Defs_Types             
import           Graph_Types            
import           Libs_Types             
import           Types_Types            


import           Batch_Types            
import qualified Batch_Iface          as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Projects_args = Projects_args deriving (Show,Eq,Typeable)
instance Hashable Projects_args where
  hashWithSalt salt record = salt  
write_Projects_args oprot record = do
  writeStructBegin oprot "Projects_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_args_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Projects_args_fields iprot record
read_Projects_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_args_fields iprot (Projects_args{})
  readStructEnd iprot
  return record
data Projects_result = Projects_result{f_Projects_result_success :: Maybe (Vector.Vector Projects_Types.Project)} deriving (Show,Eq,Typeable)
instance Hashable Projects_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Projects_result_success record  
write_Projects_result oprot record = do
  writeStructBegin oprot "Projects_result"
  case f_Projects_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter12 -> Projects_Types.write_Project oprot _viter12) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_result_fields iprot record = do
  (_,_t14,_id15) <- readFieldBegin iprot
  if _t14 == T_STOP then return record else
    case _id15 of 
      0 -> if _t14 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Project iprot)) in do {(_etype19,_size16) <- readListBegin iprot; f _size16})
        read_Projects_result_fields iprot record{f_Projects_result_success=Just s}
        else do
          skip iprot _t14
          read_Projects_result_fields iprot record
      _ -> do
        skip iprot _t14
        readFieldEnd iprot
        read_Projects_result_fields iprot record
read_Projects_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_result_fields iprot (Projects_result{f_Projects_result_success=Nothing})
  readStructEnd iprot
  return record
data ProjectByID_args = ProjectByID_args{f_ProjectByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable ProjectByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ProjectByID_args_projectID record  
write_ProjectByID_args oprot record = do
  writeStructBegin oprot "ProjectByID_args"
  case f_ProjectByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ProjectByID_args_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_I32 then do
        s <- readI32 iprot
        read_ProjectByID_args_fields iprot record{f_ProjectByID_args_projectID=Just s}
        else do
          skip iprot _t24
          read_ProjectByID_args_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_ProjectByID_args_fields iprot record
read_ProjectByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ProjectByID_args_fields iprot (ProjectByID_args{f_ProjectByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data ProjectByID_result = ProjectByID_result{f_ProjectByID_result_success :: Maybe Projects_Types.Project,f_ProjectByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable ProjectByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ProjectByID_result_success record   `hashWithSalt` f_ProjectByID_result_missingFields record  
write_ProjectByID_result oprot record = do
  writeStructBegin oprot "ProjectByID_result"
  case f_ProjectByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_ProjectByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ProjectByID_result_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      0 -> if _t29 == T_STRUCT then do
        s <- (read_Project iprot)
        read_ProjectByID_result_fields iprot record{f_ProjectByID_result_success=Just s}
        else do
          skip iprot _t29
          read_ProjectByID_result_fields iprot record
      1 -> if _t29 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_ProjectByID_result_fields iprot record{f_ProjectByID_result_missingFields=Just s}
        else do
          skip iprot _t29
          read_ProjectByID_result_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_ProjectByID_result_fields iprot record
read_ProjectByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ProjectByID_result_fields iprot (ProjectByID_result{f_ProjectByID_result_success=Nothing,f_ProjectByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CreateProject_args = CreateProject_args{f_CreateProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_args_project record  
write_CreateProject_args oprot record = do
  writeStructBegin oprot "CreateProject_args"
  case f_CreateProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_args_fields iprot record = do
  (_,_t34,_id35) <- readFieldBegin iprot
  if _t34 == T_STOP then return record else
    case _id35 of 
      1 -> if _t34 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_args_fields iprot record{f_CreateProject_args_project=Just s}
        else do
          skip iprot _t34
          read_CreateProject_args_fields iprot record
      _ -> do
        skip iprot _t34
        readFieldEnd iprot
        read_CreateProject_args_fields iprot record
read_CreateProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_args_fields iprot (CreateProject_args{f_CreateProject_args_project=Nothing})
  readStructEnd iprot
  return record
data CreateProject_result = CreateProject_result{f_CreateProject_result_success :: Maybe Projects_Types.Project,f_CreateProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_result_success record   `hashWithSalt` f_CreateProject_result_missingFields record  
write_CreateProject_result oprot record = do
  writeStructBegin oprot "CreateProject_result"
  case f_CreateProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_CreateProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_result_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      0 -> if _t39 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_success=Just s}
        else do
          skip iprot _t39
          read_CreateProject_result_fields iprot record
      1 -> if _t39 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_missingFields=Just s}
        else do
          skip iprot _t39
          read_CreateProject_result_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_CreateProject_result_fields iprot record
read_CreateProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_result_fields iprot (CreateProject_result{f_CreateProject_result_success=Nothing,f_CreateProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data OpenProject_args = OpenProject_args{f_OpenProject_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_args_path record  
write_OpenProject_args oprot record = do
  writeStructBegin oprot "OpenProject_args"
  case f_OpenProject_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_args_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_STRING then do
        s <- readString iprot
        read_OpenProject_args_fields iprot record{f_OpenProject_args_path=Just s}
        else do
          skip iprot _t44
          read_OpenProject_args_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_OpenProject_args_fields iprot record
read_OpenProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_args_fields iprot (OpenProject_args{f_OpenProject_args_path=Nothing})
  readStructEnd iprot
  return record
data OpenProject_result = OpenProject_result{f_OpenProject_result_success :: Maybe Projects_Types.Project,f_OpenProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_result_success record   `hashWithSalt` f_OpenProject_result_missingFields record  
write_OpenProject_result oprot record = do
  writeStructBegin oprot "OpenProject_result"
  case f_OpenProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_OpenProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_result_fields iprot record = do
  (_,_t49,_id50) <- readFieldBegin iprot
  if _t49 == T_STOP then return record else
    case _id50 of 
      0 -> if _t49 == T_STRUCT then do
        s <- (read_Project iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_success=Just s}
        else do
          skip iprot _t49
          read_OpenProject_result_fields iprot record
      1 -> if _t49 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_missingFields=Just s}
        else do
          skip iprot _t49
          read_OpenProject_result_fields iprot record
      _ -> do
        skip iprot _t49
        readFieldEnd iprot
        read_OpenProject_result_fields iprot record
read_OpenProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_result_fields iprot (OpenProject_result{f_OpenProject_result_success=Nothing,f_OpenProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateProject_args = UpdateProject_args{f_UpdateProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable UpdateProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateProject_args_project record  
write_UpdateProject_args oprot record = do
  writeStructBegin oprot "UpdateProject_args"
  case f_UpdateProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateProject_args_fields iprot record = do
  (_,_t54,_id55) <- readFieldBegin iprot
  if _t54 == T_STOP then return record else
    case _id55 of 
      1 -> if _t54 == T_STRUCT then do
        s <- (read_Project iprot)
        read_UpdateProject_args_fields iprot record{f_UpdateProject_args_project=Just s}
        else do
          skip iprot _t54
          read_UpdateProject_args_fields iprot record
      _ -> do
        skip iprot _t54
        readFieldEnd iprot
        read_UpdateProject_args_fields iprot record
read_UpdateProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateProject_args_fields iprot (UpdateProject_args{f_UpdateProject_args_project=Nothing})
  readStructEnd iprot
  return record
data UpdateProject_result = UpdateProject_result{f_UpdateProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateProject_result_missingFields record  
write_UpdateProject_result oprot record = do
  writeStructBegin oprot "UpdateProject_result"
  case f_UpdateProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateProject_result_fields iprot record = do
  (_,_t59,_id60) <- readFieldBegin iprot
  if _t59 == T_STOP then return record else
    case _id60 of 
      1 -> if _t59 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateProject_result_fields iprot record{f_UpdateProject_result_missingFields=Just s}
        else do
          skip iprot _t59
          read_UpdateProject_result_fields iprot record
      _ -> do
        skip iprot _t59
        readFieldEnd iprot
        read_UpdateProject_result_fields iprot record
read_UpdateProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateProject_result_fields iprot (UpdateProject_result{f_UpdateProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CloseProject_args = CloseProject_args{f_CloseProject_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_args_projectID record  
write_CloseProject_args oprot record = do
  writeStructBegin oprot "CloseProject_args"
  case f_CloseProject_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_args_fields iprot record = do
  (_,_t64,_id65) <- readFieldBegin iprot
  if _t64 == T_STOP then return record else
    case _id65 of 
      1 -> if _t64 == T_I32 then do
        s <- readI32 iprot
        read_CloseProject_args_fields iprot record{f_CloseProject_args_projectID=Just s}
        else do
          skip iprot _t64
          read_CloseProject_args_fields iprot record
      _ -> do
        skip iprot _t64
        readFieldEnd iprot
        read_CloseProject_args_fields iprot record
read_CloseProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_args_fields iprot (CloseProject_args{f_CloseProject_args_projectID=Nothing})
  readStructEnd iprot
  return record
data CloseProject_result = CloseProject_result{f_CloseProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_result_missingFields record  
write_CloseProject_result oprot record = do
  writeStructBegin oprot "CloseProject_result"
  case f_CloseProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_result_fields iprot record = do
  (_,_t69,_id70) <- readFieldBegin iprot
  if _t69 == T_STOP then return record else
    case _id70 of 
      1 -> if _t69 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CloseProject_result_fields iprot record{f_CloseProject_result_missingFields=Just s}
        else do
          skip iprot _t69
          read_CloseProject_result_fields iprot record
      _ -> do
        skip iprot _t69
        readFieldEnd iprot
        read_CloseProject_result_fields iprot record
read_CloseProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_result_fields iprot (CloseProject_result{f_CloseProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data StoreProject_args = StoreProject_args{f_StoreProject_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable StoreProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreProject_args_projectID record  
write_StoreProject_args oprot record = do
  writeStructBegin oprot "StoreProject_args"
  case f_StoreProject_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreProject_args_fields iprot record = do
  (_,_t74,_id75) <- readFieldBegin iprot
  if _t74 == T_STOP then return record else
    case _id75 of 
      1 -> if _t74 == T_I32 then do
        s <- readI32 iprot
        read_StoreProject_args_fields iprot record{f_StoreProject_args_projectID=Just s}
        else do
          skip iprot _t74
          read_StoreProject_args_fields iprot record
      _ -> do
        skip iprot _t74
        readFieldEnd iprot
        read_StoreProject_args_fields iprot record
read_StoreProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreProject_args_fields iprot (StoreProject_args{f_StoreProject_args_projectID=Nothing})
  readStructEnd iprot
  return record
data StoreProject_result = StoreProject_result{f_StoreProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable StoreProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreProject_result_missingFields record  
write_StoreProject_result oprot record = do
  writeStructBegin oprot "StoreProject_result"
  case f_StoreProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreProject_result_fields iprot record = do
  (_,_t79,_id80) <- readFieldBegin iprot
  if _t79 == T_STOP then return record else
    case _id80 of 
      1 -> if _t79 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_StoreProject_result_fields iprot record{f_StoreProject_result_missingFields=Just s}
        else do
          skip iprot _t79
          read_StoreProject_result_fields iprot record
      _ -> do
        skip iprot _t79
        readFieldEnd iprot
        read_StoreProject_result_fields iprot record
read_StoreProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreProject_result_fields iprot (StoreProject_result{f_StoreProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Libraries_args = Libraries_args{f_Libraries_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Libraries_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_args_projectID record  
write_Libraries_args oprot record = do
  writeStructBegin oprot "Libraries_args"
  case f_Libraries_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_args_fields iprot record = do
  (_,_t84,_id85) <- readFieldBegin iprot
  if _t84 == T_STOP then return record else
    case _id85 of 
      1 -> if _t84 == T_I32 then do
        s <- readI32 iprot
        read_Libraries_args_fields iprot record{f_Libraries_args_projectID=Just s}
        else do
          skip iprot _t84
          read_Libraries_args_fields iprot record
      _ -> do
        skip iprot _t84
        readFieldEnd iprot
        read_Libraries_args_fields iprot record
read_Libraries_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_args_fields iprot (Libraries_args{f_Libraries_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Libraries_result = Libraries_result{f_Libraries_result_success :: Maybe (Vector.Vector Libs_Types.Library),f_Libraries_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Libraries_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_result_success record   `hashWithSalt` f_Libraries_result_missingFields record  
write_Libraries_result oprot record = do
  writeStructBegin oprot "Libraries_result"
  case f_Libraries_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter88 -> Libs_Types.write_Library oprot _viter88) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Libraries_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_result_fields iprot record = do
  (_,_t90,_id91) <- readFieldBegin iprot
  if _t90 == T_STOP then return record else
    case _id91 of 
      0 -> if _t90 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Library iprot)) in do {(_etype95,_size92) <- readListBegin iprot; f _size92})
        read_Libraries_result_fields iprot record{f_Libraries_result_success=Just s}
        else do
          skip iprot _t90
          read_Libraries_result_fields iprot record
      1 -> if _t90 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Libraries_result_fields iprot record{f_Libraries_result_missingFields=Just s}
        else do
          skip iprot _t90
          read_Libraries_result_fields iprot record
      _ -> do
        skip iprot _t90
        readFieldEnd iprot
        read_Libraries_result_fields iprot record
read_Libraries_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_result_fields iprot (Libraries_result{f_Libraries_result_success=Nothing,f_Libraries_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LibraryByID_args = LibraryByID_args{f_LibraryByID_args_libraryID :: Maybe Int32,f_LibraryByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable LibraryByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryByID_args_libraryID record   `hashWithSalt` f_LibraryByID_args_projectID record  
write_LibraryByID_args oprot record = do
  writeStructBegin oprot "LibraryByID_args"
  case f_LibraryByID_args_libraryID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libraryID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_LibraryByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryByID_args_fields iprot record = do
  (_,_t100,_id101) <- readFieldBegin iprot
  if _t100 == T_STOP then return record else
    case _id101 of 
      1 -> if _t100 == T_I32 then do
        s <- readI32 iprot
        read_LibraryByID_args_fields iprot record{f_LibraryByID_args_libraryID=Just s}
        else do
          skip iprot _t100
          read_LibraryByID_args_fields iprot record
      2 -> if _t100 == T_I32 then do
        s <- readI32 iprot
        read_LibraryByID_args_fields iprot record{f_LibraryByID_args_projectID=Just s}
        else do
          skip iprot _t100
          read_LibraryByID_args_fields iprot record
      _ -> do
        skip iprot _t100
        readFieldEnd iprot
        read_LibraryByID_args_fields iprot record
read_LibraryByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryByID_args_fields iprot (LibraryByID_args{f_LibraryByID_args_libraryID=Nothing,f_LibraryByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data LibraryByID_result = LibraryByID_result{f_LibraryByID_result_success :: Maybe Libs_Types.Library,f_LibraryByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LibraryByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryByID_result_success record   `hashWithSalt` f_LibraryByID_result_missingFields record  
write_LibraryByID_result oprot record = do
  writeStructBegin oprot "LibraryByID_result"
  case f_LibraryByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LibraryByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryByID_result_fields iprot record = do
  (_,_t105,_id106) <- readFieldBegin iprot
  if _t105 == T_STOP then return record else
    case _id106 of 
      0 -> if _t105 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LibraryByID_result_fields iprot record{f_LibraryByID_result_success=Just s}
        else do
          skip iprot _t105
          read_LibraryByID_result_fields iprot record
      1 -> if _t105 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LibraryByID_result_fields iprot record{f_LibraryByID_result_missingFields=Just s}
        else do
          skip iprot _t105
          read_LibraryByID_result_fields iprot record
      _ -> do
        skip iprot _t105
        readFieldEnd iprot
        read_LibraryByID_result_fields iprot record
read_LibraryByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryByID_result_fields iprot (LibraryByID_result{f_LibraryByID_result_success=Nothing,f_LibraryByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_args = CreateLibrary_args{f_CreateLibrary_args_library :: Maybe Libs_Types.Library,f_CreateLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_args_library record   `hashWithSalt` f_CreateLibrary_args_projectID record  
write_CreateLibrary_args oprot record = do
  writeStructBegin oprot "CreateLibrary_args"
  case f_CreateLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_CreateLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_args_fields iprot record = do
  (_,_t110,_id111) <- readFieldBegin iprot
  if _t110 == T_STOP then return record else
    case _id111 of 
      1 -> if _t110 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_args_fields iprot record{f_CreateLibrary_args_library=Just s}
        else do
          skip iprot _t110
          read_CreateLibrary_args_fields iprot record
      2 -> if _t110 == T_I32 then do
        s <- readI32 iprot
        read_CreateLibrary_args_fields iprot record{f_CreateLibrary_args_projectID=Just s}
        else do
          skip iprot _t110
          read_CreateLibrary_args_fields iprot record
      _ -> do
        skip iprot _t110
        readFieldEnd iprot
        read_CreateLibrary_args_fields iprot record
read_CreateLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_args_fields iprot (CreateLibrary_args{f_CreateLibrary_args_library=Nothing,f_CreateLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_result = CreateLibrary_result{f_CreateLibrary_result_success :: Maybe Libs_Types.Library,f_CreateLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_result_success record   `hashWithSalt` f_CreateLibrary_result_missingFields record  
write_CreateLibrary_result oprot record = do
  writeStructBegin oprot "CreateLibrary_result"
  case f_CreateLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_CreateLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_result_fields iprot record = do
  (_,_t115,_id116) <- readFieldBegin iprot
  if _t115 == T_STOP then return record else
    case _id116 of 
      0 -> if _t115 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_success=Just s}
        else do
          skip iprot _t115
          read_CreateLibrary_result_fields iprot record
      1 -> if _t115 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_missingFields=Just s}
        else do
          skip iprot _t115
          read_CreateLibrary_result_fields iprot record
      _ -> do
        skip iprot _t115
        readFieldEnd iprot
        read_CreateLibrary_result_fields iprot record
read_CreateLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_result_fields iprot (CreateLibrary_result{f_CreateLibrary_result_success=Nothing,f_CreateLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_args = LoadLibrary_args{f_LoadLibrary_args_path :: Maybe Text,f_LoadLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_args_path record   `hashWithSalt` f_LoadLibrary_args_projectID record  
write_LoadLibrary_args oprot record = do
  writeStructBegin oprot "LoadLibrary_args"
  case f_LoadLibrary_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_args_fields iprot record = do
  (_,_t120,_id121) <- readFieldBegin iprot
  if _t120 == T_STOP then return record else
    case _id121 of 
      1 -> if _t120 == T_STRING then do
        s <- readString iprot
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_path=Just s}
        else do
          skip iprot _t120
          read_LoadLibrary_args_fields iprot record
      2 -> if _t120 == T_I32 then do
        s <- readI32 iprot
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_projectID=Just s}
        else do
          skip iprot _t120
          read_LoadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t120
        readFieldEnd iprot
        read_LoadLibrary_args_fields iprot record
read_LoadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_args_fields iprot (LoadLibrary_args{f_LoadLibrary_args_path=Nothing,f_LoadLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_result = LoadLibrary_result{f_LoadLibrary_result_success :: Maybe Libs_Types.Library,f_LoadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_result_success record   `hashWithSalt` f_LoadLibrary_result_missingFields record  
write_LoadLibrary_result oprot record = do
  writeStructBegin oprot "LoadLibrary_result"
  case f_LoadLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_result_fields iprot record = do
  (_,_t125,_id126) <- readFieldBegin iprot
  if _t125 == T_STOP then return record else
    case _id126 of 
      0 -> if _t125 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_success=Just s}
        else do
          skip iprot _t125
          read_LoadLibrary_result_fields iprot record
      1 -> if _t125 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t125
          read_LoadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t125
        readFieldEnd iprot
        read_LoadLibrary_result_fields iprot record
read_LoadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_result_fields iprot (LoadLibrary_result{f_LoadLibrary_result_success=Nothing,f_LoadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_args = UnloadLibrary_args{f_UnloadLibrary_args_libID :: Maybe Int32,f_UnloadLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_args_libID record   `hashWithSalt` f_UnloadLibrary_args_projectID record  
write_UnloadLibrary_args oprot record = do
  writeStructBegin oprot "UnloadLibrary_args"
  case f_UnloadLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UnloadLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_args_fields iprot record = do
  (_,_t130,_id131) <- readFieldBegin iprot
  if _t130 == T_STOP then return record else
    case _id131 of 
      1 -> if _t130 == T_I32 then do
        s <- readI32 iprot
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_libID=Just s}
        else do
          skip iprot _t130
          read_UnloadLibrary_args_fields iprot record
      2 -> if _t130 == T_I32 then do
        s <- readI32 iprot
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_projectID=Just s}
        else do
          skip iprot _t130
          read_UnloadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t130
        readFieldEnd iprot
        read_UnloadLibrary_args_fields iprot record
read_UnloadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_args_fields iprot (UnloadLibrary_args{f_UnloadLibrary_args_libID=Nothing,f_UnloadLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_result = UnloadLibrary_result{f_UnloadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_result_missingFields record  
write_UnloadLibrary_result oprot record = do
  writeStructBegin oprot "UnloadLibrary_result"
  case f_UnloadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_result_fields iprot record = do
  (_,_t135,_id136) <- readFieldBegin iprot
  if _t135 == T_STOP then return record else
    case _id136 of 
      1 -> if _t135 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UnloadLibrary_result_fields iprot record{f_UnloadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t135
          read_UnloadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t135
        readFieldEnd iprot
        read_UnloadLibrary_result_fields iprot record
read_UnloadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_result_fields iprot (UnloadLibrary_result{f_UnloadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_args = StoreLibrary_args{f_StoreLibrary_args_libID :: Maybe Int32,f_StoreLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_args_libID record   `hashWithSalt` f_StoreLibrary_args_projectID record  
write_StoreLibrary_args oprot record = do
  writeStructBegin oprot "StoreLibrary_args"
  case f_StoreLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_StoreLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_args_fields iprot record = do
  (_,_t140,_id141) <- readFieldBegin iprot
  if _t140 == T_STOP then return record else
    case _id141 of 
      1 -> if _t140 == T_I32 then do
        s <- readI32 iprot
        read_StoreLibrary_args_fields iprot record{f_StoreLibrary_args_libID=Just s}
        else do
          skip iprot _t140
          read_StoreLibrary_args_fields iprot record
      2 -> if _t140 == T_I32 then do
        s <- readI32 iprot
        read_StoreLibrary_args_fields iprot record{f_StoreLibrary_args_projectID=Just s}
        else do
          skip iprot _t140
          read_StoreLibrary_args_fields iprot record
      _ -> do
        skip iprot _t140
        readFieldEnd iprot
        read_StoreLibrary_args_fields iprot record
read_StoreLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_args_fields iprot (StoreLibrary_args{f_StoreLibrary_args_libID=Nothing,f_StoreLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_result = StoreLibrary_result{f_StoreLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_result_missingFields record  
write_StoreLibrary_result oprot record = do
  writeStructBegin oprot "StoreLibrary_result"
  case f_StoreLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_result_fields iprot record = do
  (_,_t145,_id146) <- readFieldBegin iprot
  if _t145 == T_STOP then return record else
    case _id146 of 
      1 -> if _t145 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_StoreLibrary_result_fields iprot record{f_StoreLibrary_result_missingFields=Just s}
        else do
          skip iprot _t145
          read_StoreLibrary_result_fields iprot record
      _ -> do
        skip iprot _t145
        readFieldEnd iprot
        read_StoreLibrary_result_fields iprot record
read_StoreLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_result_fields iprot (StoreLibrary_result{f_StoreLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data BuildLibrary_args = BuildLibrary_args{f_BuildLibrary_args_libID :: Maybe Int32,f_BuildLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable BuildLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_BuildLibrary_args_libID record   `hashWithSalt` f_BuildLibrary_args_projectID record  
write_BuildLibrary_args oprot record = do
  writeStructBegin oprot "BuildLibrary_args"
  case f_BuildLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_BuildLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_BuildLibrary_args_fields iprot record = do
  (_,_t150,_id151) <- readFieldBegin iprot
  if _t150 == T_STOP then return record else
    case _id151 of 
      1 -> if _t150 == T_I32 then do
        s <- readI32 iprot
        read_BuildLibrary_args_fields iprot record{f_BuildLibrary_args_libID=Just s}
        else do
          skip iprot _t150
          read_BuildLibrary_args_fields iprot record
      2 -> if _t150 == T_I32 then do
        s <- readI32 iprot
        read_BuildLibrary_args_fields iprot record{f_BuildLibrary_args_projectID=Just s}
        else do
          skip iprot _t150
          read_BuildLibrary_args_fields iprot record
      _ -> do
        skip iprot _t150
        readFieldEnd iprot
        read_BuildLibrary_args_fields iprot record
read_BuildLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_BuildLibrary_args_fields iprot (BuildLibrary_args{f_BuildLibrary_args_libID=Nothing,f_BuildLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data BuildLibrary_result = BuildLibrary_result{f_BuildLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable BuildLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_BuildLibrary_result_missingFields record  
write_BuildLibrary_result oprot record = do
  writeStructBegin oprot "BuildLibrary_result"
  case f_BuildLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_BuildLibrary_result_fields iprot record = do
  (_,_t155,_id156) <- readFieldBegin iprot
  if _t155 == T_STOP then return record else
    case _id156 of 
      1 -> if _t155 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_BuildLibrary_result_fields iprot record{f_BuildLibrary_result_missingFields=Just s}
        else do
          skip iprot _t155
          read_BuildLibrary_result_fields iprot record
      _ -> do
        skip iprot _t155
        readFieldEnd iprot
        read_BuildLibrary_result_fields iprot record
read_BuildLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_BuildLibrary_result_fields iprot (BuildLibrary_result{f_BuildLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RunLibrary_args = RunLibrary_args{f_RunLibrary_args_libID :: Maybe Int32,f_RunLibrary_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RunLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RunLibrary_args_libID record   `hashWithSalt` f_RunLibrary_args_projectID record  
write_RunLibrary_args oprot record = do
  writeStructBegin oprot "RunLibrary_args"
  case f_RunLibrary_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RunLibrary_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RunLibrary_args_fields iprot record = do
  (_,_t160,_id161) <- readFieldBegin iprot
  if _t160 == T_STOP then return record else
    case _id161 of 
      1 -> if _t160 == T_I32 then do
        s <- readI32 iprot
        read_RunLibrary_args_fields iprot record{f_RunLibrary_args_libID=Just s}
        else do
          skip iprot _t160
          read_RunLibrary_args_fields iprot record
      2 -> if _t160 == T_I32 then do
        s <- readI32 iprot
        read_RunLibrary_args_fields iprot record{f_RunLibrary_args_projectID=Just s}
        else do
          skip iprot _t160
          read_RunLibrary_args_fields iprot record
      _ -> do
        skip iprot _t160
        readFieldEnd iprot
        read_RunLibrary_args_fields iprot record
read_RunLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RunLibrary_args_fields iprot (RunLibrary_args{f_RunLibrary_args_libID=Nothing,f_RunLibrary_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RunLibrary_result = RunLibrary_result{f_RunLibrary_result_success :: Maybe Text,f_RunLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RunLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RunLibrary_result_success record   `hashWithSalt` f_RunLibrary_result_missingFields record  
write_RunLibrary_result oprot record = do
  writeStructBegin oprot "RunLibrary_result"
  case f_RunLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRING,0)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_RunLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RunLibrary_result_fields iprot record = do
  (_,_t165,_id166) <- readFieldBegin iprot
  if _t165 == T_STOP then return record else
    case _id166 of 
      0 -> if _t165 == T_STRING then do
        s <- readString iprot
        read_RunLibrary_result_fields iprot record{f_RunLibrary_result_success=Just s}
        else do
          skip iprot _t165
          read_RunLibrary_result_fields iprot record
      1 -> if _t165 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RunLibrary_result_fields iprot record{f_RunLibrary_result_missingFields=Just s}
        else do
          skip iprot _t165
          read_RunLibrary_result_fields iprot record
      _ -> do
        skip iprot _t165
        readFieldEnd iprot
        read_RunLibrary_result_fields iprot record
read_RunLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RunLibrary_result_fields iprot (RunLibrary_result{f_RunLibrary_result_success=Nothing,f_RunLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_args = LibraryRootDef_args{f_LibraryRootDef_args_libID :: Maybe Int32,f_LibraryRootDef_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_args_libID record   `hashWithSalt` f_LibraryRootDef_args_projectID record  
write_LibraryRootDef_args oprot record = do
  writeStructBegin oprot "LibraryRootDef_args"
  case f_LibraryRootDef_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_args_fields iprot record = do
  (_,_t170,_id171) <- readFieldBegin iprot
  if _t170 == T_STOP then return record else
    case _id171 of 
      1 -> if _t170 == T_I32 then do
        s <- readI32 iprot
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_libID=Just s}
        else do
          skip iprot _t170
          read_LibraryRootDef_args_fields iprot record
      2 -> if _t170 == T_I32 then do
        s <- readI32 iprot
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_projectID=Just s}
        else do
          skip iprot _t170
          read_LibraryRootDef_args_fields iprot record
      _ -> do
        skip iprot _t170
        readFieldEnd iprot
        read_LibraryRootDef_args_fields iprot record
read_LibraryRootDef_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_args_fields iprot (LibraryRootDef_args{f_LibraryRootDef_args_libID=Nothing,f_LibraryRootDef_args_projectID=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_result = LibraryRootDef_result{f_LibraryRootDef_result_success :: Maybe Defs_Types.Definition,f_LibraryRootDef_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_result_success record   `hashWithSalt` f_LibraryRootDef_result_missingFields record  
write_LibraryRootDef_result oprot record = do
  writeStructBegin oprot "LibraryRootDef_result"
  case f_LibraryRootDef_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_result_fields iprot record = do
  (_,_t175,_id176) <- readFieldBegin iprot
  if _t175 == T_STOP then return record else
    case _id176 of 
      0 -> if _t175 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_success=Just s}
        else do
          skip iprot _t175
          read_LibraryRootDef_result_fields iprot record
      1 -> if _t175 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_missingFields=Just s}
        else do
          skip iprot _t175
          read_LibraryRootDef_result_fields iprot record
      _ -> do
        skip iprot _t175
        readFieldEnd iprot
        read_LibraryRootDef_result_fields iprot record
read_LibraryRootDef_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_result_fields iprot (LibraryRootDef_result{f_LibraryRootDef_result_success=Nothing,f_LibraryRootDef_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefsGraph_args = DefsGraph_args{f_DefsGraph_args_libID :: Maybe Int32,f_DefsGraph_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefsGraph_args_libID record   `hashWithSalt` f_DefsGraph_args_projectID record  
write_DefsGraph_args oprot record = do
  writeStructBegin oprot "DefsGraph_args"
  case f_DefsGraph_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefsGraph_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_args_fields iprot record = do
  (_,_t180,_id181) <- readFieldBegin iprot
  if _t180 == T_STOP then return record else
    case _id181 of 
      1 -> if _t180 == T_I32 then do
        s <- readI32 iprot
        read_DefsGraph_args_fields iprot record{f_DefsGraph_args_libID=Just s}
        else do
          skip iprot _t180
          read_DefsGraph_args_fields iprot record
      2 -> if _t180 == T_I32 then do
        s <- readI32 iprot
        read_DefsGraph_args_fields iprot record{f_DefsGraph_args_projectID=Just s}
        else do
          skip iprot _t180
          read_DefsGraph_args_fields iprot record
      _ -> do
        skip iprot _t180
        readFieldEnd iprot
        read_DefsGraph_args_fields iprot record
read_DefsGraph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_args_fields iprot (DefsGraph_args{f_DefsGraph_args_libID=Nothing,f_DefsGraph_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefsGraph_result = DefsGraph_result{f_DefsGraph_result_success :: Maybe Defs_Types.DefsGraph,f_DefsGraph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefsGraph_result_success record   `hashWithSalt` f_DefsGraph_result_missingFields record  
write_DefsGraph_result oprot record = do
  writeStructBegin oprot "DefsGraph_result"
  case f_DefsGraph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_DefsGraph oprot _v
    writeFieldEnd oprot}
  case f_DefsGraph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_result_fields iprot record = do
  (_,_t185,_id186) <- readFieldBegin iprot
  if _t185 == T_STOP then return record else
    case _id186 of 
      0 -> if _t185 == T_STRUCT then do
        s <- (read_DefsGraph iprot)
        read_DefsGraph_result_fields iprot record{f_DefsGraph_result_success=Just s}
        else do
          skip iprot _t185
          read_DefsGraph_result_fields iprot record
      1 -> if _t185 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefsGraph_result_fields iprot record{f_DefsGraph_result_missingFields=Just s}
        else do
          skip iprot _t185
          read_DefsGraph_result_fields iprot record
      _ -> do
        skip iprot _t185
        readFieldEnd iprot
        read_DefsGraph_result_fields iprot record
read_DefsGraph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_result_fields iprot (DefsGraph_result{f_DefsGraph_result_success=Nothing,f_DefsGraph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefByID_args = DefByID_args{f_DefByID_args_defID :: Maybe Int32,f_DefByID_args_libID :: Maybe Int32,f_DefByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefByID_args_defID record   `hashWithSalt` f_DefByID_args_libID record   `hashWithSalt` f_DefByID_args_projectID record  
write_DefByID_args oprot record = do
  writeStructBegin oprot "DefByID_args"
  case f_DefByID_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefByID_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefByID_args_fields iprot record = do
  (_,_t190,_id191) <- readFieldBegin iprot
  if _t190 == T_STOP then return record else
    case _id191 of 
      1 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_defID=Just s}
        else do
          skip iprot _t190
          read_DefByID_args_fields iprot record
      2 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_libID=Just s}
        else do
          skip iprot _t190
          read_DefByID_args_fields iprot record
      3 -> if _t190 == T_I32 then do
        s <- readI32 iprot
        read_DefByID_args_fields iprot record{f_DefByID_args_projectID=Just s}
        else do
          skip iprot _t190
          read_DefByID_args_fields iprot record
      _ -> do
        skip iprot _t190
        readFieldEnd iprot
        read_DefByID_args_fields iprot record
read_DefByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefByID_args_fields iprot (DefByID_args{f_DefByID_args_defID=Nothing,f_DefByID_args_libID=Nothing,f_DefByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefByID_result = DefByID_result{f_DefByID_result_success :: Maybe Defs_Types.Definition,f_DefByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefByID_result_success record   `hashWithSalt` f_DefByID_result_missingFields record  
write_DefByID_result oprot record = do
  writeStructBegin oprot "DefByID_result"
  case f_DefByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_DefByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefByID_result_fields iprot record = do
  (_,_t195,_id196) <- readFieldBegin iprot
  if _t195 == T_STOP then return record else
    case _id196 of 
      0 -> if _t195 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefByID_result_fields iprot record{f_DefByID_result_success=Just s}
        else do
          skip iprot _t195
          read_DefByID_result_fields iprot record
      1 -> if _t195 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefByID_result_fields iprot record{f_DefByID_result_missingFields=Just s}
        else do
          skip iprot _t195
          read_DefByID_result_fields iprot record
      _ -> do
        skip iprot _t195
        readFieldEnd iprot
        read_DefByID_result_fields iprot record
read_DefByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefByID_result_fields iprot (DefByID_result{f_DefByID_result_success=Nothing,f_DefByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_args = AddDefinition_args{f_AddDefinition_args_definition :: Maybe Defs_Types.Definition,f_AddDefinition_args_parentID :: Maybe Int32,f_AddDefinition_args_libID :: Maybe Int32,f_AddDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_args_definition record   `hashWithSalt` f_AddDefinition_args_parentID record   `hashWithSalt` f_AddDefinition_args_libID record   `hashWithSalt` f_AddDefinition_args_projectID record  
write_AddDefinition_args oprot record = do
  writeStructBegin oprot "AddDefinition_args"
  case f_AddDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_parentID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parentID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_args_fields iprot record = do
  (_,_t200,_id201) <- readFieldBegin iprot
  if _t200 == T_STOP then return record else
    case _id201 of 
      1 -> if _t200 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_definition=Just s}
        else do
          skip iprot _t200
          read_AddDefinition_args_fields iprot record
      2 -> if _t200 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_parentID=Just s}
        else do
          skip iprot _t200
          read_AddDefinition_args_fields iprot record
      3 -> if _t200 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_libID=Just s}
        else do
          skip iprot _t200
          read_AddDefinition_args_fields iprot record
      4 -> if _t200 == T_I32 then do
        s <- readI32 iprot
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_projectID=Just s}
        else do
          skip iprot _t200
          read_AddDefinition_args_fields iprot record
      _ -> do
        skip iprot _t200
        readFieldEnd iprot
        read_AddDefinition_args_fields iprot record
read_AddDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_args_fields iprot (AddDefinition_args{f_AddDefinition_args_definition=Nothing,f_AddDefinition_args_parentID=Nothing,f_AddDefinition_args_libID=Nothing,f_AddDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_result = AddDefinition_result{f_AddDefinition_result_success :: Maybe Defs_Types.Definition,f_AddDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_result_success record   `hashWithSalt` f_AddDefinition_result_missingFields record  
write_AddDefinition_result oprot record = do
  writeStructBegin oprot "AddDefinition_result"
  case f_AddDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_result_fields iprot record = do
  (_,_t205,_id206) <- readFieldBegin iprot
  if _t205 == T_STOP then return record else
    case _id206 of 
      0 -> if _t205 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_success=Just s}
        else do
          skip iprot _t205
          read_AddDefinition_result_fields iprot record
      1 -> if _t205 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_missingFields=Just s}
        else do
          skip iprot _t205
          read_AddDefinition_result_fields iprot record
      _ -> do
        skip iprot _t205
        readFieldEnd iprot
        read_AddDefinition_result_fields iprot record
read_AddDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_result_fields iprot (AddDefinition_result{f_AddDefinition_result_success=Nothing,f_AddDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_args = UpdateDefinition_args{f_UpdateDefinition_args_definition :: Maybe Defs_Types.Definition,f_UpdateDefinition_args_libID :: Maybe Int32,f_UpdateDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_args_definition record   `hashWithSalt` f_UpdateDefinition_args_libID record   `hashWithSalt` f_UpdateDefinition_args_projectID record  
write_UpdateDefinition_args oprot record = do
  writeStructBegin oprot "UpdateDefinition_args"
  case f_UpdateDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_UpdateDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_args_fields iprot record = do
  (_,_t210,_id211) <- readFieldBegin iprot
  if _t210 == T_STOP then return record else
    case _id211 of 
      1 -> if _t210 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_definition=Just s}
        else do
          skip iprot _t210
          read_UpdateDefinition_args_fields iprot record
      2 -> if _t210 == T_I32 then do
        s <- readI32 iprot
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_libID=Just s}
        else do
          skip iprot _t210
          read_UpdateDefinition_args_fields iprot record
      3 -> if _t210 == T_I32 then do
        s <- readI32 iprot
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_projectID=Just s}
        else do
          skip iprot _t210
          read_UpdateDefinition_args_fields iprot record
      _ -> do
        skip iprot _t210
        readFieldEnd iprot
        read_UpdateDefinition_args_fields iprot record
read_UpdateDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_args_fields iprot (UpdateDefinition_args{f_UpdateDefinition_args_definition=Nothing,f_UpdateDefinition_args_libID=Nothing,f_UpdateDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_result = UpdateDefinition_result{f_UpdateDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_result_missingFields record  
write_UpdateDefinition_result oprot record = do
  writeStructBegin oprot "UpdateDefinition_result"
  case f_UpdateDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_result_fields iprot record = do
  (_,_t215,_id216) <- readFieldBegin iprot
  if _t215 == T_STOP then return record else
    case _id216 of 
      1 -> if _t215 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateDefinition_result_fields iprot record{f_UpdateDefinition_result_missingFields=Just s}
        else do
          skip iprot _t215
          read_UpdateDefinition_result_fields iprot record
      _ -> do
        skip iprot _t215
        readFieldEnd iprot
        read_UpdateDefinition_result_fields iprot record
read_UpdateDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_result_fields iprot (UpdateDefinition_result{f_UpdateDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_args = RemoveDefinition_args{f_RemoveDefinition_args_defID :: Maybe Int32,f_RemoveDefinition_args_libID :: Maybe Int32,f_RemoveDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_args_defID record   `hashWithSalt` f_RemoveDefinition_args_libID record   `hashWithSalt` f_RemoveDefinition_args_projectID record  
write_RemoveDefinition_args oprot record = do
  writeStructBegin oprot "RemoveDefinition_args"
  case f_RemoveDefinition_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_args_fields iprot record = do
  (_,_t220,_id221) <- readFieldBegin iprot
  if _t220 == T_STOP then return record else
    case _id221 of 
      1 -> if _t220 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_defID=Just s}
        else do
          skip iprot _t220
          read_RemoveDefinition_args_fields iprot record
      2 -> if _t220 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_libID=Just s}
        else do
          skip iprot _t220
          read_RemoveDefinition_args_fields iprot record
      3 -> if _t220 == T_I32 then do
        s <- readI32 iprot
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_projectID=Just s}
        else do
          skip iprot _t220
          read_RemoveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t220
        readFieldEnd iprot
        read_RemoveDefinition_args_fields iprot record
read_RemoveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_args_fields iprot (RemoveDefinition_args{f_RemoveDefinition_args_defID=Nothing,f_RemoveDefinition_args_libID=Nothing,f_RemoveDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_result = RemoveDefinition_result{f_RemoveDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_result_missingFields record  
write_RemoveDefinition_result oprot record = do
  writeStructBegin oprot "RemoveDefinition_result"
  case f_RemoveDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_result_fields iprot record = do
  (_,_t225,_id226) <- readFieldBegin iprot
  if _t225 == T_STOP then return record else
    case _id226 of 
      1 -> if _t225 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveDefinition_result_fields iprot record{f_RemoveDefinition_result_missingFields=Just s}
        else do
          skip iprot _t225
          read_RemoveDefinition_result_fields iprot record
      _ -> do
        skip iprot _t225
        readFieldEnd iprot
        read_RemoveDefinition_result_fields iprot record
read_RemoveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_result_fields iprot (RemoveDefinition_result{f_RemoveDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_args = DefinitionChildren_args{f_DefinitionChildren_args_defID :: Maybe Int32,f_DefinitionChildren_args_libID :: Maybe Int32,f_DefinitionChildren_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_args_defID record   `hashWithSalt` f_DefinitionChildren_args_libID record   `hashWithSalt` f_DefinitionChildren_args_projectID record  
write_DefinitionChildren_args oprot record = do
  writeStructBegin oprot "DefinitionChildren_args"
  case f_DefinitionChildren_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionChildren_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionChildren_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_args_fields iprot record = do
  (_,_t230,_id231) <- readFieldBegin iprot
  if _t230 == T_STOP then return record else
    case _id231 of 
      1 -> if _t230 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_defID=Just s}
        else do
          skip iprot _t230
          read_DefinitionChildren_args_fields iprot record
      2 -> if _t230 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_libID=Just s}
        else do
          skip iprot _t230
          read_DefinitionChildren_args_fields iprot record
      3 -> if _t230 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_projectID=Just s}
        else do
          skip iprot _t230
          read_DefinitionChildren_args_fields iprot record
      _ -> do
        skip iprot _t230
        readFieldEnd iprot
        read_DefinitionChildren_args_fields iprot record
read_DefinitionChildren_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_args_fields iprot (DefinitionChildren_args{f_DefinitionChildren_args_defID=Nothing,f_DefinitionChildren_args_libID=Nothing,f_DefinitionChildren_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_result = DefinitionChildren_result{f_DefinitionChildren_result_success :: Maybe (Vector.Vector Defs_Types.Definition),f_DefinitionChildren_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_result_success record   `hashWithSalt` f_DefinitionChildren_result_missingFields record  
write_DefinitionChildren_result oprot record = do
  writeStructBegin oprot "DefinitionChildren_result"
  case f_DefinitionChildren_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter234 -> Defs_Types.write_Definition oprot _viter234) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_DefinitionChildren_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_result_fields iprot record = do
  (_,_t236,_id237) <- readFieldBegin iprot
  if _t236 == T_STOP then return record else
    case _id237 of 
      0 -> if _t236 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Definition iprot)) in do {(_etype241,_size238) <- readListBegin iprot; f _size238})
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_success=Just s}
        else do
          skip iprot _t236
          read_DefinitionChildren_result_fields iprot record
      1 -> if _t236 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_missingFields=Just s}
        else do
          skip iprot _t236
          read_DefinitionChildren_result_fields iprot record
      _ -> do
        skip iprot _t236
        readFieldEnd iprot
        read_DefinitionChildren_result_fields iprot record
read_DefinitionChildren_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_result_fields iprot (DefinitionChildren_result{f_DefinitionChildren_result_success=Nothing,f_DefinitionChildren_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_args = DefinitionParent_args{f_DefinitionParent_args_defID :: Maybe Int32,f_DefinitionParent_args_libID :: Maybe Int32,f_DefinitionParent_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_args_defID record   `hashWithSalt` f_DefinitionParent_args_libID record   `hashWithSalt` f_DefinitionParent_args_projectID record  
write_DefinitionParent_args oprot record = do
  writeStructBegin oprot "DefinitionParent_args"
  case f_DefinitionParent_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_args_fields iprot record = do
  (_,_t246,_id247) <- readFieldBegin iprot
  if _t246 == T_STOP then return record else
    case _id247 of 
      1 -> if _t246 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_defID=Just s}
        else do
          skip iprot _t246
          read_DefinitionParent_args_fields iprot record
      2 -> if _t246 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_libID=Just s}
        else do
          skip iprot _t246
          read_DefinitionParent_args_fields iprot record
      3 -> if _t246 == T_I32 then do
        s <- readI32 iprot
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_projectID=Just s}
        else do
          skip iprot _t246
          read_DefinitionParent_args_fields iprot record
      _ -> do
        skip iprot _t246
        readFieldEnd iprot
        read_DefinitionParent_args_fields iprot record
read_DefinitionParent_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_args_fields iprot (DefinitionParent_args{f_DefinitionParent_args_defID=Nothing,f_DefinitionParent_args_libID=Nothing,f_DefinitionParent_args_projectID=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_result = DefinitionParent_result{f_DefinitionParent_result_success :: Maybe Defs_Types.Definition,f_DefinitionParent_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_result_success record   `hashWithSalt` f_DefinitionParent_result_missingFields record  
write_DefinitionParent_result oprot record = do
  writeStructBegin oprot "DefinitionParent_result"
  case f_DefinitionParent_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_result_fields iprot record = do
  (_,_t251,_id252) <- readFieldBegin iprot
  if _t251 == T_STOP then return record else
    case _id252 of 
      0 -> if _t251 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_success=Just s}
        else do
          skip iprot _t251
          read_DefinitionParent_result_fields iprot record
      1 -> if _t251 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_missingFields=Just s}
        else do
          skip iprot _t251
          read_DefinitionParent_result_fields iprot record
      _ -> do
        skip iprot _t251
        readFieldEnd iprot
        read_DefinitionParent_result_fields iprot record
read_DefinitionParent_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_result_fields iprot (DefinitionParent_result{f_DefinitionParent_result_success=Nothing,f_DefinitionParent_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data ResolveDefinition_args = ResolveDefinition_args{f_ResolveDefinition_args_name :: Maybe Text,f_ResolveDefinition_args_parentID :: Maybe Int32,f_ResolveDefinition_args_libID :: Maybe Int32,f_ResolveDefinition_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable ResolveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_ResolveDefinition_args_name record   `hashWithSalt` f_ResolveDefinition_args_parentID record   `hashWithSalt` f_ResolveDefinition_args_libID record   `hashWithSalt` f_ResolveDefinition_args_projectID record  
write_ResolveDefinition_args oprot record = do
  writeStructBegin oprot "ResolveDefinition_args"
  case f_ResolveDefinition_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_ResolveDefinition_args_parentID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parentID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ResolveDefinition_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_ResolveDefinition_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ResolveDefinition_args_fields iprot record = do
  (_,_t256,_id257) <- readFieldBegin iprot
  if _t256 == T_STOP then return record else
    case _id257 of 
      1 -> if _t256 == T_STRING then do
        s <- readString iprot
        read_ResolveDefinition_args_fields iprot record{f_ResolveDefinition_args_name=Just s}
        else do
          skip iprot _t256
          read_ResolveDefinition_args_fields iprot record
      2 -> if _t256 == T_I32 then do
        s <- readI32 iprot
        read_ResolveDefinition_args_fields iprot record{f_ResolveDefinition_args_parentID=Just s}
        else do
          skip iprot _t256
          read_ResolveDefinition_args_fields iprot record
      3 -> if _t256 == T_I32 then do
        s <- readI32 iprot
        read_ResolveDefinition_args_fields iprot record{f_ResolveDefinition_args_libID=Just s}
        else do
          skip iprot _t256
          read_ResolveDefinition_args_fields iprot record
      4 -> if _t256 == T_I32 then do
        s <- readI32 iprot
        read_ResolveDefinition_args_fields iprot record{f_ResolveDefinition_args_projectID=Just s}
        else do
          skip iprot _t256
          read_ResolveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t256
        readFieldEnd iprot
        read_ResolveDefinition_args_fields iprot record
read_ResolveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_ResolveDefinition_args_fields iprot (ResolveDefinition_args{f_ResolveDefinition_args_name=Nothing,f_ResolveDefinition_args_parentID=Nothing,f_ResolveDefinition_args_libID=Nothing,f_ResolveDefinition_args_projectID=Nothing})
  readStructEnd iprot
  return record
data ResolveDefinition_result = ResolveDefinition_result{f_ResolveDefinition_result_success :: Maybe (Vector.Vector Defs_Types.DefPtr),f_ResolveDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable ResolveDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_ResolveDefinition_result_success record   `hashWithSalt` f_ResolveDefinition_result_missingFields record  
write_ResolveDefinition_result oprot record = do
  writeStructBegin oprot "ResolveDefinition_result"
  case f_ResolveDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter260 -> Defs_Types.write_DefPtr oprot _viter260) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_ResolveDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_ResolveDefinition_result_fields iprot record = do
  (_,_t262,_id263) <- readFieldBegin iprot
  if _t262 == T_STOP then return record else
    case _id263 of 
      0 -> if _t262 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_DefPtr iprot)) in do {(_etype267,_size264) <- readListBegin iprot; f _size264})
        read_ResolveDefinition_result_fields iprot record{f_ResolveDefinition_result_success=Just s}
        else do
          skip iprot _t262
          read_ResolveDefinition_result_fields iprot record
      1 -> if _t262 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_ResolveDefinition_result_fields iprot record{f_ResolveDefinition_result_missingFields=Just s}
        else do
          skip iprot _t262
          read_ResolveDefinition_result_fields iprot record
      _ -> do
        skip iprot _t262
        readFieldEnd iprot
        read_ResolveDefinition_result_fields iprot record
read_ResolveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_ResolveDefinition_result_fields iprot (ResolveDefinition_result{f_ResolveDefinition_result_success=Nothing,f_ResolveDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_args = NewTypeModule_args{f_NewTypeModule_args_name :: Maybe Text,f_NewTypeModule_args_fields :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_args_name record   `hashWithSalt` f_NewTypeModule_args_fields record  
write_NewTypeModule_args oprot record = do
  writeStructBegin oprot "NewTypeModule_args"
  case f_NewTypeModule_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeModule_args_fields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("fields",T_LIST,2)
    (let f = Vector.mapM_ (\_viter271 -> Types_Types.write_Type oprot _viter271) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_args_fields iprot record = do
  (_,_t273,_id274) <- readFieldBegin iprot
  if _t273 == T_STOP then return record else
    case _id274 of 
      1 -> if _t273 == T_STRING then do
        s <- readString iprot
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_name=Just s}
        else do
          skip iprot _t273
          read_NewTypeModule_args_fields iprot record
      2 -> if _t273 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype278,_size275) <- readListBegin iprot; f _size275})
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_fields=Just s}
        else do
          skip iprot _t273
          read_NewTypeModule_args_fields iprot record
      _ -> do
        skip iprot _t273
        readFieldEnd iprot
        read_NewTypeModule_args_fields iprot record
read_NewTypeModule_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_args_fields iprot (NewTypeModule_args{f_NewTypeModule_args_name=Nothing,f_NewTypeModule_args_fields=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_result = NewTypeModule_result{f_NewTypeModule_result_success :: Maybe Types_Types.Type,f_NewTypeModule_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_result_success record   `hashWithSalt` f_NewTypeModule_result_missingFields record  
write_NewTypeModule_result oprot record = do
  writeStructBegin oprot "NewTypeModule_result"
  case f_NewTypeModule_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeModule_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_result_fields iprot record = do
  (_,_t283,_id284) <- readFieldBegin iprot
  if _t283 == T_STOP then return record else
    case _id284 of 
      0 -> if _t283 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_success=Just s}
        else do
          skip iprot _t283
          read_NewTypeModule_result_fields iprot record
      1 -> if _t283 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_missingFields=Just s}
        else do
          skip iprot _t283
          read_NewTypeModule_result_fields iprot record
      _ -> do
        skip iprot _t283
        readFieldEnd iprot
        read_NewTypeModule_result_fields iprot record
read_NewTypeModule_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_result_fields iprot (NewTypeModule_result{f_NewTypeModule_result_success=Nothing,f_NewTypeModule_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_args = NewTypeClass_args{f_NewTypeClass_args_name :: Maybe Text,f_NewTypeClass_args_params :: Maybe (Vector.Vector Text),f_NewTypeClass_args_fields :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_args_name record   `hashWithSalt` f_NewTypeClass_args_params record   `hashWithSalt` f_NewTypeClass_args_fields record  
write_NewTypeClass_args oprot record = do
  writeStructBegin oprot "NewTypeClass_args"
  case f_NewTypeClass_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_args_params record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("params",T_LIST,2)
    (let f = Vector.mapM_ (\_viter287 -> writeString oprot _viter287) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NewTypeClass_args_fields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("fields",T_LIST,3)
    (let f = Vector.mapM_ (\_viter288 -> Types_Types.write_Type oprot _viter288) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_args_fields iprot record = do
  (_,_t290,_id291) <- readFieldBegin iprot
  if _t290 == T_STOP then return record else
    case _id291 of 
      1 -> if _t290 == T_STRING then do
        s <- readString iprot
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_name=Just s}
        else do
          skip iprot _t290
          read_NewTypeClass_args_fields iprot record
      2 -> if _t290 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype295,_size292) <- readListBegin iprot; f _size292})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_params=Just s}
        else do
          skip iprot _t290
          read_NewTypeClass_args_fields iprot record
      3 -> if _t290 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype300,_size297) <- readListBegin iprot; f _size297})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_fields=Just s}
        else do
          skip iprot _t290
          read_NewTypeClass_args_fields iprot record
      _ -> do
        skip iprot _t290
        readFieldEnd iprot
        read_NewTypeClass_args_fields iprot record
read_NewTypeClass_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_args_fields iprot (NewTypeClass_args{f_NewTypeClass_args_name=Nothing,f_NewTypeClass_args_params=Nothing,f_NewTypeClass_args_fields=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_result = NewTypeClass_result{f_NewTypeClass_result_success :: Maybe Types_Types.Type,f_NewTypeClass_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_result_success record   `hashWithSalt` f_NewTypeClass_result_missingFields record  
write_NewTypeClass_result oprot record = do
  writeStructBegin oprot "NewTypeClass_result"
  case f_NewTypeClass_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_result_fields iprot record = do
  (_,_t305,_id306) <- readFieldBegin iprot
  if _t305 == T_STOP then return record else
    case _id306 of 
      0 -> if _t305 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_success=Just s}
        else do
          skip iprot _t305
          read_NewTypeClass_result_fields iprot record
      1 -> if _t305 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_missingFields=Just s}
        else do
          skip iprot _t305
          read_NewTypeClass_result_fields iprot record
      _ -> do
        skip iprot _t305
        readFieldEnd iprot
        read_NewTypeClass_result_fields iprot record
read_NewTypeClass_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_result_fields iprot (NewTypeClass_result{f_NewTypeClass_result_success=Nothing,f_NewTypeClass_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_args = NewTypeFunction_args{f_NewTypeFunction_args_name :: Maybe Text,f_NewTypeFunction_args_inputs :: Maybe Types_Types.Type,f_NewTypeFunction_args_outputs :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_args_name record   `hashWithSalt` f_NewTypeFunction_args_inputs record   `hashWithSalt` f_NewTypeFunction_args_outputs record  
write_NewTypeFunction_args oprot record = do
  writeStructBegin oprot "NewTypeFunction_args"
  case f_NewTypeFunction_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_inputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inputs",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_outputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("outputs",T_STRUCT,3)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_args_fields iprot record = do
  (_,_t310,_id311) <- readFieldBegin iprot
  if _t310 == T_STOP then return record else
    case _id311 of 
      1 -> if _t310 == T_STRING then do
        s <- readString iprot
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_name=Just s}
        else do
          skip iprot _t310
          read_NewTypeFunction_args_fields iprot record
      2 -> if _t310 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_inputs=Just s}
        else do
          skip iprot _t310
          read_NewTypeFunction_args_fields iprot record
      3 -> if _t310 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_outputs=Just s}
        else do
          skip iprot _t310
          read_NewTypeFunction_args_fields iprot record
      _ -> do
        skip iprot _t310
        readFieldEnd iprot
        read_NewTypeFunction_args_fields iprot record
read_NewTypeFunction_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_args_fields iprot (NewTypeFunction_args{f_NewTypeFunction_args_name=Nothing,f_NewTypeFunction_args_inputs=Nothing,f_NewTypeFunction_args_outputs=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_result = NewTypeFunction_result{f_NewTypeFunction_result_success :: Maybe Types_Types.Type,f_NewTypeFunction_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_result_success record   `hashWithSalt` f_NewTypeFunction_result_missingFields record  
write_NewTypeFunction_result oprot record = do
  writeStructBegin oprot "NewTypeFunction_result"
  case f_NewTypeFunction_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_result_fields iprot record = do
  (_,_t315,_id316) <- readFieldBegin iprot
  if _t315 == T_STOP then return record else
    case _id316 of 
      0 -> if _t315 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_success=Just s}
        else do
          skip iprot _t315
          read_NewTypeFunction_result_fields iprot record
      1 -> if _t315 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_missingFields=Just s}
        else do
          skip iprot _t315
          read_NewTypeFunction_result_fields iprot record
      _ -> do
        skip iprot _t315
        readFieldEnd iprot
        read_NewTypeFunction_result_fields iprot record
read_NewTypeFunction_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_result_fields iprot (NewTypeFunction_result{f_NewTypeFunction_result_success=Nothing,f_NewTypeFunction_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeUdefined_args = NewTypeUdefined_args deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_args where
  hashWithSalt salt record = salt  
write_NewTypeUdefined_args oprot record = do
  writeStructBegin oprot "NewTypeUdefined_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_args_fields iprot record = do
  (_,_t320,_id321) <- readFieldBegin iprot
  if _t320 == T_STOP then return record else
    case _id321 of 
      _ -> do
        skip iprot _t320
        readFieldEnd iprot
        read_NewTypeUdefined_args_fields iprot record
read_NewTypeUdefined_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_args_fields iprot (NewTypeUdefined_args{})
  readStructEnd iprot
  return record
data NewTypeUdefined_result = NewTypeUdefined_result{f_NewTypeUdefined_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeUdefined_result_success record  
write_NewTypeUdefined_result oprot record = do
  writeStructBegin oprot "NewTypeUdefined_result"
  case f_NewTypeUdefined_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_result_fields iprot record = do
  (_,_t325,_id326) <- readFieldBegin iprot
  if _t325 == T_STOP then return record else
    case _id326 of 
      0 -> if _t325 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_success=Just s}
        else do
          skip iprot _t325
          read_NewTypeUdefined_result_fields iprot record
      _ -> do
        skip iprot _t325
        readFieldEnd iprot
        read_NewTypeUdefined_result_fields iprot record
read_NewTypeUdefined_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_result_fields iprot (NewTypeUdefined_result{f_NewTypeUdefined_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_args = NewTypeNamed_args{f_NewTypeNamed_args_name :: Maybe Text,f_NewTypeNamed_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_args_name record   `hashWithSalt` f_NewTypeNamed_args_type record  
write_NewTypeNamed_args oprot record = do
  writeStructBegin oprot "NewTypeNamed_args"
  case f_NewTypeNamed_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_args_fields iprot record = do
  (_,_t330,_id331) <- readFieldBegin iprot
  if _t330 == T_STOP then return record else
    case _id331 of 
      1 -> if _t330 == T_STRING then do
        s <- readString iprot
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_name=Just s}
        else do
          skip iprot _t330
          read_NewTypeNamed_args_fields iprot record
      2 -> if _t330 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_type=Just s}
        else do
          skip iprot _t330
          read_NewTypeNamed_args_fields iprot record
      _ -> do
        skip iprot _t330
        readFieldEnd iprot
        read_NewTypeNamed_args_fields iprot record
read_NewTypeNamed_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_args_fields iprot (NewTypeNamed_args{f_NewTypeNamed_args_name=Nothing,f_NewTypeNamed_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_result = NewTypeNamed_result{f_NewTypeNamed_result_success :: Maybe Types_Types.Type,f_NewTypeNamed_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_result_success record   `hashWithSalt` f_NewTypeNamed_result_missingFields record  
write_NewTypeNamed_result oprot record = do
  writeStructBegin oprot "NewTypeNamed_result"
  case f_NewTypeNamed_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_result_fields iprot record = do
  (_,_t335,_id336) <- readFieldBegin iprot
  if _t335 == T_STOP then return record else
    case _id336 of 
      0 -> if _t335 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_success=Just s}
        else do
          skip iprot _t335
          read_NewTypeNamed_result_fields iprot record
      1 -> if _t335 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_missingFields=Just s}
        else do
          skip iprot _t335
          read_NewTypeNamed_result_fields iprot record
      _ -> do
        skip iprot _t335
        readFieldEnd iprot
        read_NewTypeNamed_result_fields iprot record
read_NewTypeNamed_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_result_fields iprot (NewTypeNamed_result{f_NewTypeNamed_result_success=Nothing,f_NewTypeNamed_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeName_args = NewTypeName_args{f_NewTypeName_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeName_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeName_args_name record  
write_NewTypeName_args oprot record = do
  writeStructBegin oprot "NewTypeName_args"
  case f_NewTypeName_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeName_args_fields iprot record = do
  (_,_t340,_id341) <- readFieldBegin iprot
  if _t340 == T_STOP then return record else
    case _id341 of 
      1 -> if _t340 == T_STRING then do
        s <- readString iprot
        read_NewTypeName_args_fields iprot record{f_NewTypeName_args_name=Just s}
        else do
          skip iprot _t340
          read_NewTypeName_args_fields iprot record
      _ -> do
        skip iprot _t340
        readFieldEnd iprot
        read_NewTypeName_args_fields iprot record
read_NewTypeName_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeName_args_fields iprot (NewTypeName_args{f_NewTypeName_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeName_result = NewTypeName_result{f_NewTypeName_result_success :: Maybe Types_Types.Type,f_NewTypeName_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeName_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeName_result_success record   `hashWithSalt` f_NewTypeName_result_missingFields record  
write_NewTypeName_result oprot record = do
  writeStructBegin oprot "NewTypeName_result"
  case f_NewTypeName_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeName_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeName_result_fields iprot record = do
  (_,_t345,_id346) <- readFieldBegin iprot
  if _t345 == T_STOP then return record else
    case _id346 of 
      0 -> if _t345 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeName_result_fields iprot record{f_NewTypeName_result_success=Just s}
        else do
          skip iprot _t345
          read_NewTypeName_result_fields iprot record
      1 -> if _t345 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeName_result_fields iprot record{f_NewTypeName_result_missingFields=Just s}
        else do
          skip iprot _t345
          read_NewTypeName_result_fields iprot record
      _ -> do
        skip iprot _t345
        readFieldEnd iprot
        read_NewTypeName_result_fields iprot record
read_NewTypeName_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeName_result_fields iprot (NewTypeName_result{f_NewTypeName_result_success=Nothing,f_NewTypeName_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_args = NewTypeTuple_args{f_NewTypeTuple_args_types :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_args_types record  
write_NewTypeTuple_args oprot record = do
  writeStructBegin oprot "NewTypeTuple_args"
  case f_NewTypeTuple_args_types record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("types",T_LIST,1)
    (let f = Vector.mapM_ (\_viter349 -> Types_Types.write_Type oprot _viter349) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_args_fields iprot record = do
  (_,_t351,_id352) <- readFieldBegin iprot
  if _t351 == T_STOP then return record else
    case _id352 of 
      1 -> if _t351 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype356,_size353) <- readListBegin iprot; f _size353})
        read_NewTypeTuple_args_fields iprot record{f_NewTypeTuple_args_types=Just s}
        else do
          skip iprot _t351
          read_NewTypeTuple_args_fields iprot record
      _ -> do
        skip iprot _t351
        readFieldEnd iprot
        read_NewTypeTuple_args_fields iprot record
read_NewTypeTuple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_args_fields iprot (NewTypeTuple_args{f_NewTypeTuple_args_types=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_result = NewTypeTuple_result{f_NewTypeTuple_result_success :: Maybe Types_Types.Type,f_NewTypeTuple_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_result_success record   `hashWithSalt` f_NewTypeTuple_result_missingFields record  
write_NewTypeTuple_result oprot record = do
  writeStructBegin oprot "NewTypeTuple_result"
  case f_NewTypeTuple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeTuple_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_result_fields iprot record = do
  (_,_t361,_id362) <- readFieldBegin iprot
  if _t361 == T_STOP then return record else
    case _id362 of 
      0 -> if _t361 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_success=Just s}
        else do
          skip iprot _t361
          read_NewTypeTuple_result_fields iprot record
      1 -> if _t361 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_missingFields=Just s}
        else do
          skip iprot _t361
          read_NewTypeTuple_result_fields iprot record
      _ -> do
        skip iprot _t361
        readFieldEnd iprot
        read_NewTypeTuple_result_fields iprot record
read_NewTypeTuple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_result_fields iprot (NewTypeTuple_result{f_NewTypeTuple_result_success=Nothing,f_NewTypeTuple_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NodesGraph_args = NodesGraph_args{f_NodesGraph_args_defID :: Maybe Int32,f_NodesGraph_args_libID :: Maybe Int32,f_NodesGraph_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable NodesGraph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodesGraph_args_defID record   `hashWithSalt` f_NodesGraph_args_libID record   `hashWithSalt` f_NodesGraph_args_projectID record  
write_NodesGraph_args oprot record = do
  writeStructBegin oprot "NodesGraph_args"
  case f_NodesGraph_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodesGraph_args_fields iprot record = do
  (_,_t366,_id367) <- readFieldBegin iprot
  if _t366 == T_STOP then return record else
    case _id367 of 
      1 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_defID=Just s}
        else do
          skip iprot _t366
          read_NodesGraph_args_fields iprot record
      2 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_libID=Just s}
        else do
          skip iprot _t366
          read_NodesGraph_args_fields iprot record
      3 -> if _t366 == T_I32 then do
        s <- readI32 iprot
        read_NodesGraph_args_fields iprot record{f_NodesGraph_args_projectID=Just s}
        else do
          skip iprot _t366
          read_NodesGraph_args_fields iprot record
      _ -> do
        skip iprot _t366
        readFieldEnd iprot
        read_NodesGraph_args_fields iprot record
read_NodesGraph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NodesGraph_args_fields iprot (NodesGraph_args{f_NodesGraph_args_defID=Nothing,f_NodesGraph_args_libID=Nothing,f_NodesGraph_args_projectID=Nothing})
  readStructEnd iprot
  return record
data NodesGraph_result = NodesGraph_result{f_NodesGraph_result_success :: Maybe Graphview_Types.GraphView,f_NodesGraph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NodesGraph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodesGraph_result_success record   `hashWithSalt` f_NodesGraph_result_missingFields record  
write_NodesGraph_result oprot record = do
  writeStructBegin oprot "NodesGraph_result"
  case f_NodesGraph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graphview_Types.write_GraphView oprot _v
    writeFieldEnd oprot}
  case f_NodesGraph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodesGraph_result_fields iprot record = do
  (_,_t371,_id372) <- readFieldBegin iprot
  if _t371 == T_STOP then return record else
    case _id372 of 
      0 -> if _t371 == T_STRUCT then do
        s <- (read_GraphView iprot)
        read_NodesGraph_result_fields iprot record{f_NodesGraph_result_success=Just s}
        else do
          skip iprot _t371
          read_NodesGraph_result_fields iprot record
      1 -> if _t371 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NodesGraph_result_fields iprot record{f_NodesGraph_result_missingFields=Just s}
        else do
          skip iprot _t371
          read_NodesGraph_result_fields iprot record
      _ -> do
        skip iprot _t371
        readFieldEnd iprot
        read_NodesGraph_result_fields iprot record
read_NodesGraph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NodesGraph_result_fields iprot (NodesGraph_result{f_NodesGraph_result_success=Nothing,f_NodesGraph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NodeByID_args = NodeByID_args{f_NodeByID_args_nodeID :: Maybe Int32,f_NodeByID_args_defID :: Maybe Int32,f_NodeByID_args_libID :: Maybe Int32,f_NodeByID_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable NodeByID_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeByID_args_nodeID record   `hashWithSalt` f_NodeByID_args_defID record   `hashWithSalt` f_NodeByID_args_libID record   `hashWithSalt` f_NodeByID_args_projectID record  
write_NodeByID_args oprot record = do
  writeStructBegin oprot "NodeByID_args"
  case f_NodeByID_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeByID_args_fields iprot record = do
  (_,_t376,_id377) <- readFieldBegin iprot
  if _t376 == T_STOP then return record else
    case _id377 of 
      1 -> if _t376 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_nodeID=Just s}
        else do
          skip iprot _t376
          read_NodeByID_args_fields iprot record
      2 -> if _t376 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_defID=Just s}
        else do
          skip iprot _t376
          read_NodeByID_args_fields iprot record
      3 -> if _t376 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_libID=Just s}
        else do
          skip iprot _t376
          read_NodeByID_args_fields iprot record
      4 -> if _t376 == T_I32 then do
        s <- readI32 iprot
        read_NodeByID_args_fields iprot record{f_NodeByID_args_projectID=Just s}
        else do
          skip iprot _t376
          read_NodeByID_args_fields iprot record
      _ -> do
        skip iprot _t376
        readFieldEnd iprot
        read_NodeByID_args_fields iprot record
read_NodeByID_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeByID_args_fields iprot (NodeByID_args{f_NodeByID_args_nodeID=Nothing,f_NodeByID_args_defID=Nothing,f_NodeByID_args_libID=Nothing,f_NodeByID_args_projectID=Nothing})
  readStructEnd iprot
  return record
data NodeByID_result = NodeByID_result{f_NodeByID_result_success :: Maybe Graph_Types.Node,f_NodeByID_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NodeByID_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeByID_result_success record   `hashWithSalt` f_NodeByID_result_missingFields record  
write_NodeByID_result oprot record = do
  writeStructBegin oprot "NodeByID_result"
  case f_NodeByID_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_NodeByID_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeByID_result_fields iprot record = do
  (_,_t381,_id382) <- readFieldBegin iprot
  if _t381 == T_STOP then return record else
    case _id382 of 
      0 -> if _t381 == T_STRUCT then do
        s <- (read_Node iprot)
        read_NodeByID_result_fields iprot record{f_NodeByID_result_success=Just s}
        else do
          skip iprot _t381
          read_NodeByID_result_fields iprot record
      1 -> if _t381 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NodeByID_result_fields iprot record{f_NodeByID_result_missingFields=Just s}
        else do
          skip iprot _t381
          read_NodeByID_result_fields iprot record
      _ -> do
        skip iprot _t381
        readFieldEnd iprot
        read_NodeByID_result_fields iprot record
read_NodeByID_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeByID_result_fields iprot (NodeByID_result{f_NodeByID_result_success=Nothing,f_NodeByID_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddNode_args = AddNode_args{f_AddNode_args_node :: Maybe Graph_Types.Node,f_AddNode_args_defID :: Maybe Int32,f_AddNode_args_libID :: Maybe Int32,f_AddNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable AddNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_args_node record   `hashWithSalt` f_AddNode_args_defID record   `hashWithSalt` f_AddNode_args_libID record   `hashWithSalt` f_AddNode_args_projectID record  
write_AddNode_args oprot record = do
  writeStructBegin oprot "AddNode_args"
  case f_AddNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_args_fields iprot record = do
  (_,_t386,_id387) <- readFieldBegin iprot
  if _t386 == T_STOP then return record else
    case _id387 of 
      1 -> if _t386 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_node=Just s}
        else do
          skip iprot _t386
          read_AddNode_args_fields iprot record
      2 -> if _t386 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_defID=Just s}
        else do
          skip iprot _t386
          read_AddNode_args_fields iprot record
      3 -> if _t386 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_libID=Just s}
        else do
          skip iprot _t386
          read_AddNode_args_fields iprot record
      4 -> if _t386 == T_I32 then do
        s <- readI32 iprot
        read_AddNode_args_fields iprot record{f_AddNode_args_projectID=Just s}
        else do
          skip iprot _t386
          read_AddNode_args_fields iprot record
      _ -> do
        skip iprot _t386
        readFieldEnd iprot
        read_AddNode_args_fields iprot record
read_AddNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_args_fields iprot (AddNode_args{f_AddNode_args_node=Nothing,f_AddNode_args_defID=Nothing,f_AddNode_args_libID=Nothing,f_AddNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data AddNode_result = AddNode_result{f_AddNode_result_success :: Maybe Graph_Types.Node,f_AddNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_result_success record   `hashWithSalt` f_AddNode_result_missingFields record  
write_AddNode_result oprot record = do
  writeStructBegin oprot "AddNode_result"
  case f_AddNode_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_result_fields iprot record = do
  (_,_t391,_id392) <- readFieldBegin iprot
  if _t391 == T_STOP then return record else
    case _id392 of 
      0 -> if _t391 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_success=Just s}
        else do
          skip iprot _t391
          read_AddNode_result_fields iprot record
      1 -> if _t391 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_missingFields=Just s}
        else do
          skip iprot _t391
          read_AddNode_result_fields iprot record
      _ -> do
        skip iprot _t391
        readFieldEnd iprot
        read_AddNode_result_fields iprot record
read_AddNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_result_fields iprot (AddNode_result{f_AddNode_result_success=Nothing,f_AddNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_args = UpdateNode_args{f_UpdateNode_args_node :: Maybe Graph_Types.Node,f_UpdateNode_args_defID :: Maybe Int32,f_UpdateNode_args_libID :: Maybe Int32,f_UpdateNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_args_node record   `hashWithSalt` f_UpdateNode_args_defID record   `hashWithSalt` f_UpdateNode_args_libID record   `hashWithSalt` f_UpdateNode_args_projectID record  
write_UpdateNode_args oprot record = do
  writeStructBegin oprot "UpdateNode_args"
  case f_UpdateNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_args_fields iprot record = do
  (_,_t396,_id397) <- readFieldBegin iprot
  if _t396 == T_STOP then return record else
    case _id397 of 
      1 -> if _t396 == T_STRUCT then do
        s <- (read_Node iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_node=Just s}
        else do
          skip iprot _t396
          read_UpdateNode_args_fields iprot record
      2 -> if _t396 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_defID=Just s}
        else do
          skip iprot _t396
          read_UpdateNode_args_fields iprot record
      3 -> if _t396 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_libID=Just s}
        else do
          skip iprot _t396
          read_UpdateNode_args_fields iprot record
      4 -> if _t396 == T_I32 then do
        s <- readI32 iprot
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_projectID=Just s}
        else do
          skip iprot _t396
          read_UpdateNode_args_fields iprot record
      _ -> do
        skip iprot _t396
        readFieldEnd iprot
        read_UpdateNode_args_fields iprot record
read_UpdateNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_args_fields iprot (UpdateNode_args{f_UpdateNode_args_node=Nothing,f_UpdateNode_args_defID=Nothing,f_UpdateNode_args_libID=Nothing,f_UpdateNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_result = UpdateNode_result{f_UpdateNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_result_missingFields record  
write_UpdateNode_result oprot record = do
  writeStructBegin oprot "UpdateNode_result"
  case f_UpdateNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_result_fields iprot record = do
  (_,_t401,_id402) <- readFieldBegin iprot
  if _t401 == T_STOP then return record else
    case _id402 of 
      1 -> if _t401 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateNode_result_fields iprot record{f_UpdateNode_result_missingFields=Just s}
        else do
          skip iprot _t401
          read_UpdateNode_result_fields iprot record
      _ -> do
        skip iprot _t401
        readFieldEnd iprot
        read_UpdateNode_result_fields iprot record
read_UpdateNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_result_fields iprot (UpdateNode_result{f_UpdateNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_args = RemoveNode_args{f_RemoveNode_args_nodeID :: Maybe Int32,f_RemoveNode_args_defID :: Maybe Int32,f_RemoveNode_args_libID :: Maybe Int32,f_RemoveNode_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_args_nodeID record   `hashWithSalt` f_RemoveNode_args_defID record   `hashWithSalt` f_RemoveNode_args_libID record   `hashWithSalt` f_RemoveNode_args_projectID record  
write_RemoveNode_args oprot record = do
  writeStructBegin oprot "RemoveNode_args"
  case f_RemoveNode_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_args_fields iprot record = do
  (_,_t406,_id407) <- readFieldBegin iprot
  if _t406 == T_STOP then return record else
    case _id407 of 
      1 -> if _t406 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_nodeID=Just s}
        else do
          skip iprot _t406
          read_RemoveNode_args_fields iprot record
      2 -> if _t406 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_defID=Just s}
        else do
          skip iprot _t406
          read_RemoveNode_args_fields iprot record
      3 -> if _t406 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_libID=Just s}
        else do
          skip iprot _t406
          read_RemoveNode_args_fields iprot record
      4 -> if _t406 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_projectID=Just s}
        else do
          skip iprot _t406
          read_RemoveNode_args_fields iprot record
      _ -> do
        skip iprot _t406
        readFieldEnd iprot
        read_RemoveNode_args_fields iprot record
read_RemoveNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_args_fields iprot (RemoveNode_args{f_RemoveNode_args_nodeID=Nothing,f_RemoveNode_args_defID=Nothing,f_RemoveNode_args_libID=Nothing,f_RemoveNode_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_result = RemoveNode_result{f_RemoveNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_result_missingFields record  
write_RemoveNode_result oprot record = do
  writeStructBegin oprot "RemoveNode_result"
  case f_RemoveNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_result_fields iprot record = do
  (_,_t411,_id412) <- readFieldBegin iprot
  if _t411 == T_STOP then return record else
    case _id412 of 
      1 -> if _t411 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveNode_result_fields iprot record{f_RemoveNode_result_missingFields=Just s}
        else do
          skip iprot _t411
          read_RemoveNode_result_fields iprot record
      _ -> do
        skip iprot _t411
        readFieldEnd iprot
        read_RemoveNode_result_fields iprot record
read_RemoveNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_result_fields iprot (RemoveNode_result{f_RemoveNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Connect_args = Connect_args{f_Connect_args_srcNodeID :: Maybe Int32,f_Connect_args_srcPort :: Maybe (Vector.Vector Int32),f_Connect_args_dstNodeID :: Maybe Int32,f_Connect_args_dstPort :: Maybe (Vector.Vector Int32),f_Connect_args_defID :: Maybe Int32,f_Connect_args_libID :: Maybe Int32,f_Connect_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Connect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_args_srcNodeID record   `hashWithSalt` f_Connect_args_srcPort record   `hashWithSalt` f_Connect_args_dstNodeID record   `hashWithSalt` f_Connect_args_dstPort record   `hashWithSalt` f_Connect_args_defID record   `hashWithSalt` f_Connect_args_libID record   `hashWithSalt` f_Connect_args_projectID record  
write_Connect_args oprot record = do
  writeStructBegin oprot "Connect_args"
  case f_Connect_args_srcNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter415 -> writeI32 oprot _viter415) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_dstNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNodeID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter416 -> writeI32 oprot _viter416) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,7)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_args_fields iprot record = do
  (_,_t418,_id419) <- readFieldBegin iprot
  if _t418 == T_STOP then return record else
    case _id419 of 
      1 -> if _t418 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_srcNodeID=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      2 -> if _t418 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype423,_size420) <- readListBegin iprot; f _size420})
        read_Connect_args_fields iprot record{f_Connect_args_srcPort=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      3 -> if _t418 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_dstNodeID=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      4 -> if _t418 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype428,_size425) <- readListBegin iprot; f _size425})
        read_Connect_args_fields iprot record{f_Connect_args_dstPort=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      5 -> if _t418 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_defID=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      6 -> if _t418 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_libID=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      7 -> if _t418 == T_I32 then do
        s <- readI32 iprot
        read_Connect_args_fields iprot record{f_Connect_args_projectID=Just s}
        else do
          skip iprot _t418
          read_Connect_args_fields iprot record
      _ -> do
        skip iprot _t418
        readFieldEnd iprot
        read_Connect_args_fields iprot record
read_Connect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_args_fields iprot (Connect_args{f_Connect_args_srcNodeID=Nothing,f_Connect_args_srcPort=Nothing,f_Connect_args_dstNodeID=Nothing,f_Connect_args_dstPort=Nothing,f_Connect_args_defID=Nothing,f_Connect_args_libID=Nothing,f_Connect_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Connect_result = Connect_result{f_Connect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Connect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_result_missingFields record  
write_Connect_result oprot record = do
  writeStructBegin oprot "Connect_result"
  case f_Connect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_result_fields iprot record = do
  (_,_t433,_id434) <- readFieldBegin iprot
  if _t433 == T_STOP then return record else
    case _id434 of 
      1 -> if _t433 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Connect_result_fields iprot record{f_Connect_result_missingFields=Just s}
        else do
          skip iprot _t433
          read_Connect_result_fields iprot record
      _ -> do
        skip iprot _t433
        readFieldEnd iprot
        read_Connect_result_fields iprot record
read_Connect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_result_fields iprot (Connect_result{f_Connect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Disconnect_args = Disconnect_args{f_Disconnect_args_srcNodeID :: Maybe Int32,f_Disconnect_args_srcPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_dstNodeID :: Maybe Int32,f_Disconnect_args_dstPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_defID :: Maybe Int32,f_Disconnect_args_libID :: Maybe Int32,f_Disconnect_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_args_srcNodeID record   `hashWithSalt` f_Disconnect_args_srcPort record   `hashWithSalt` f_Disconnect_args_dstNodeID record   `hashWithSalt` f_Disconnect_args_dstPort record   `hashWithSalt` f_Disconnect_args_defID record   `hashWithSalt` f_Disconnect_args_libID record   `hashWithSalt` f_Disconnect_args_projectID record  
write_Disconnect_args oprot record = do
  writeStructBegin oprot "Disconnect_args"
  case f_Disconnect_args_srcNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter437 -> writeI32 oprot _viter437) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_dstNodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNodeID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter438 -> writeI32 oprot _viter438) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,7)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_args_fields iprot record = do
  (_,_t440,_id441) <- readFieldBegin iprot
  if _t440 == T_STOP then return record else
    case _id441 of 
      1 -> if _t440 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcNodeID=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      2 -> if _t440 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype445,_size442) <- readListBegin iprot; f _size442})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcPort=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      3 -> if _t440 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstNodeID=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      4 -> if _t440 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype450,_size447) <- readListBegin iprot; f _size447})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstPort=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      5 -> if _t440 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_defID=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      6 -> if _t440 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_libID=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      7 -> if _t440 == T_I32 then do
        s <- readI32 iprot
        read_Disconnect_args_fields iprot record{f_Disconnect_args_projectID=Just s}
        else do
          skip iprot _t440
          read_Disconnect_args_fields iprot record
      _ -> do
        skip iprot _t440
        readFieldEnd iprot
        read_Disconnect_args_fields iprot record
read_Disconnect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_args_fields iprot (Disconnect_args{f_Disconnect_args_srcNodeID=Nothing,f_Disconnect_args_srcPort=Nothing,f_Disconnect_args_dstNodeID=Nothing,f_Disconnect_args_dstPort=Nothing,f_Disconnect_args_defID=Nothing,f_Disconnect_args_libID=Nothing,f_Disconnect_args_projectID=Nothing})
  readStructEnd iprot
  return record
data Disconnect_result = Disconnect_result{f_Disconnect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_result_missingFields record  
write_Disconnect_result oprot record = do
  writeStructBegin oprot "Disconnect_result"
  case f_Disconnect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_result_fields iprot record = do
  (_,_t455,_id456) <- readFieldBegin iprot
  if _t455 == T_STOP then return record else
    case _id456 of 
      1 -> if _t455 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Disconnect_result_fields iprot record{f_Disconnect_result_missingFields=Just s}
        else do
          skip iprot _t455
          read_Disconnect_result_fields iprot record
      _ -> do
        skip iprot _t455
        readFieldEnd iprot
        read_Disconnect_result_fields iprot record
read_Disconnect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_result_fields iprot (Disconnect_result{f_Disconnect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NodeDefaults_args = NodeDefaults_args{f_NodeDefaults_args_nodeID :: Maybe Int32,f_NodeDefaults_args_defID :: Maybe Int32,f_NodeDefaults_args_libID :: Maybe Int32,f_NodeDefaults_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable NodeDefaults_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeDefaults_args_nodeID record   `hashWithSalt` f_NodeDefaults_args_defID record   `hashWithSalt` f_NodeDefaults_args_libID record   `hashWithSalt` f_NodeDefaults_args_projectID record  
write_NodeDefaults_args oprot record = do
  writeStructBegin oprot "NodeDefaults_args"
  case f_NodeDefaults_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,1)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeDefaults_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeDefaults_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_NodeDefaults_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeDefaults_args_fields iprot record = do
  (_,_t460,_id461) <- readFieldBegin iprot
  if _t460 == T_STOP then return record else
    case _id461 of 
      1 -> if _t460 == T_I32 then do
        s <- readI32 iprot
        read_NodeDefaults_args_fields iprot record{f_NodeDefaults_args_nodeID=Just s}
        else do
          skip iprot _t460
          read_NodeDefaults_args_fields iprot record
      2 -> if _t460 == T_I32 then do
        s <- readI32 iprot
        read_NodeDefaults_args_fields iprot record{f_NodeDefaults_args_defID=Just s}
        else do
          skip iprot _t460
          read_NodeDefaults_args_fields iprot record
      3 -> if _t460 == T_I32 then do
        s <- readI32 iprot
        read_NodeDefaults_args_fields iprot record{f_NodeDefaults_args_libID=Just s}
        else do
          skip iprot _t460
          read_NodeDefaults_args_fields iprot record
      4 -> if _t460 == T_I32 then do
        s <- readI32 iprot
        read_NodeDefaults_args_fields iprot record{f_NodeDefaults_args_projectID=Just s}
        else do
          skip iprot _t460
          read_NodeDefaults_args_fields iprot record
      _ -> do
        skip iprot _t460
        readFieldEnd iprot
        read_NodeDefaults_args_fields iprot record
read_NodeDefaults_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeDefaults_args_fields iprot (NodeDefaults_args{f_NodeDefaults_args_nodeID=Nothing,f_NodeDefaults_args_defID=Nothing,f_NodeDefaults_args_libID=Nothing,f_NodeDefaults_args_projectID=Nothing})
  readStructEnd iprot
  return record
data NodeDefaults_result = NodeDefaults_result{f_NodeDefaults_result_success :: Maybe (Map.HashMap (Vector.Vector Int32) Graph_Types.DefaultValue),f_NodeDefaults_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NodeDefaults_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NodeDefaults_result_success record   `hashWithSalt` f_NodeDefaults_result_missingFields record  
write_NodeDefaults_result oprot record = do
  writeStructBegin oprot "NodeDefaults_result"
  case f_NodeDefaults_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_MAP,0)
    (let {f [] = return (); f ((_kiter464,_viter465):t) = do {do {(let f = Vector.mapM_ (\_viter466 -> writeI32 oprot _viter466) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _kiter464); f _kiter464;writeListEnd oprot});Graph_Types.write_DefaultValue oprot _viter465};f t}} in do {writeMapBegin oprot (T_LIST,T_STRUCT,fromIntegral $ Map.size _v); f (Map.toList _v);writeMapEnd oprot})
    writeFieldEnd oprot}
  case f_NodeDefaults_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NodeDefaults_result_fields iprot record = do
  (_,_t468,_id469) <- readFieldBegin iprot
  if _t468 == T_STOP then return record else
    case _id469 of 
      0 -> if _t468 == T_MAP then do
        s <- (let {f 0 = return []; f n = do {k <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype478,_size475) <- readListBegin iprot; f _size475}); v <- (read_DefaultValue iprot);r <- f (n-1); return $ (k,v):r}} in do {(_ktype471,_vtype472,_size470) <- readMapBegin iprot; l <- f _size470; return $ Map.fromList l})
        read_NodeDefaults_result_fields iprot record{f_NodeDefaults_result_success=Just s}
        else do
          skip iprot _t468
          read_NodeDefaults_result_fields iprot record
      1 -> if _t468 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NodeDefaults_result_fields iprot record{f_NodeDefaults_result_missingFields=Just s}
        else do
          skip iprot _t468
          read_NodeDefaults_result_fields iprot record
      _ -> do
        skip iprot _t468
        readFieldEnd iprot
        read_NodeDefaults_result_fields iprot record
read_NodeDefaults_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NodeDefaults_result_fields iprot (NodeDefaults_result{f_NodeDefaults_result_success=Nothing,f_NodeDefaults_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data SetNodeDefault_args = SetNodeDefault_args{f_SetNodeDefault_args_dst :: Maybe (Vector.Vector Int32),f_SetNodeDefault_args_value :: Maybe Graph_Types.DefaultValue,f_SetNodeDefault_args_nodeID :: Maybe Int32,f_SetNodeDefault_args_defID :: Maybe Int32,f_SetNodeDefault_args_libID :: Maybe Int32,f_SetNodeDefault_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable SetNodeDefault_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_SetNodeDefault_args_dst record   `hashWithSalt` f_SetNodeDefault_args_value record   `hashWithSalt` f_SetNodeDefault_args_nodeID record   `hashWithSalt` f_SetNodeDefault_args_defID record   `hashWithSalt` f_SetNodeDefault_args_libID record   `hashWithSalt` f_SetNodeDefault_args_projectID record  
write_SetNodeDefault_args oprot record = do
  writeStructBegin oprot "SetNodeDefault_args"
  case f_SetNodeDefault_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_LIST,1)
    (let f = Vector.mapM_ (\_viter482 -> writeI32 oprot _viter482) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_SetNodeDefault_args_value record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("value",T_STRUCT,2)
    Graph_Types.write_DefaultValue oprot _v
    writeFieldEnd oprot}
  case f_SetNodeDefault_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SetNodeDefault_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SetNodeDefault_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_SetNodeDefault_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,6)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SetNodeDefault_args_fields iprot record = do
  (_,_t484,_id485) <- readFieldBegin iprot
  if _t484 == T_STOP then return record else
    case _id485 of 
      1 -> if _t484 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype489,_size486) <- readListBegin iprot; f _size486})
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_dst=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      2 -> if _t484 == T_STRUCT then do
        s <- (read_DefaultValue iprot)
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_value=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      3 -> if _t484 == T_I32 then do
        s <- readI32 iprot
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_nodeID=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      4 -> if _t484 == T_I32 then do
        s <- readI32 iprot
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_defID=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      5 -> if _t484 == T_I32 then do
        s <- readI32 iprot
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_libID=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      6 -> if _t484 == T_I32 then do
        s <- readI32 iprot
        read_SetNodeDefault_args_fields iprot record{f_SetNodeDefault_args_projectID=Just s}
        else do
          skip iprot _t484
          read_SetNodeDefault_args_fields iprot record
      _ -> do
        skip iprot _t484
        readFieldEnd iprot
        read_SetNodeDefault_args_fields iprot record
read_SetNodeDefault_args iprot = do
  _ <- readStructBegin iprot
  record <- read_SetNodeDefault_args_fields iprot (SetNodeDefault_args{f_SetNodeDefault_args_dst=Nothing,f_SetNodeDefault_args_value=Nothing,f_SetNodeDefault_args_nodeID=Nothing,f_SetNodeDefault_args_defID=Nothing,f_SetNodeDefault_args_libID=Nothing,f_SetNodeDefault_args_projectID=Nothing})
  readStructEnd iprot
  return record
data SetNodeDefault_result = SetNodeDefault_result{f_SetNodeDefault_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable SetNodeDefault_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_SetNodeDefault_result_missingFields record  
write_SetNodeDefault_result oprot record = do
  writeStructBegin oprot "SetNodeDefault_result"
  case f_SetNodeDefault_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SetNodeDefault_result_fields iprot record = do
  (_,_t494,_id495) <- readFieldBegin iprot
  if _t494 == T_STOP then return record else
    case _id495 of 
      1 -> if _t494 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_SetNodeDefault_result_fields iprot record{f_SetNodeDefault_result_missingFields=Just s}
        else do
          skip iprot _t494
          read_SetNodeDefault_result_fields iprot record
      _ -> do
        skip iprot _t494
        readFieldEnd iprot
        read_SetNodeDefault_result_fields iprot record
read_SetNodeDefault_result iprot = do
  _ <- readStructBegin iprot
  record <- read_SetNodeDefault_result_fields iprot (SetNodeDefault_result{f_SetNodeDefault_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveNodeDefault_args = RemoveNodeDefault_args{f_RemoveNodeDefault_args_dst :: Maybe (Vector.Vector Int32),f_RemoveNodeDefault_args_nodeID :: Maybe Int32,f_RemoveNodeDefault_args_defID :: Maybe Int32,f_RemoveNodeDefault_args_libID :: Maybe Int32,f_RemoveNodeDefault_args_projectID :: Maybe Int32} deriving (Show,Eq,Typeable)
instance Hashable RemoveNodeDefault_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNodeDefault_args_dst record   `hashWithSalt` f_RemoveNodeDefault_args_nodeID record   `hashWithSalt` f_RemoveNodeDefault_args_defID record   `hashWithSalt` f_RemoveNodeDefault_args_libID record   `hashWithSalt` f_RemoveNodeDefault_args_projectID record  
write_RemoveNodeDefault_args oprot record = do
  writeStructBegin oprot "RemoveNodeDefault_args"
  case f_RemoveNodeDefault_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_LIST,1)
    (let f = Vector.mapM_ (\_viter498 -> writeI32 oprot _viter498) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_RemoveNodeDefault_args_nodeID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("nodeID",T_I32,2)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNodeDefault_args_defID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("defID",T_I32,3)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNodeDefault_args_libID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("libID",T_I32,4)
    writeI32 oprot _v
    writeFieldEnd oprot}
  case f_RemoveNodeDefault_args_projectID record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("projectID",T_I32,5)
    writeI32 oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNodeDefault_args_fields iprot record = do
  (_,_t500,_id501) <- readFieldBegin iprot
  if _t500 == T_STOP then return record else
    case _id501 of 
      1 -> if _t500 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype505,_size502) <- readListBegin iprot; f _size502})
        read_RemoveNodeDefault_args_fields iprot record{f_RemoveNodeDefault_args_dst=Just s}
        else do
          skip iprot _t500
          read_RemoveNodeDefault_args_fields iprot record
      2 -> if _t500 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNodeDefault_args_fields iprot record{f_RemoveNodeDefault_args_nodeID=Just s}
        else do
          skip iprot _t500
          read_RemoveNodeDefault_args_fields iprot record
      3 -> if _t500 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNodeDefault_args_fields iprot record{f_RemoveNodeDefault_args_defID=Just s}
        else do
          skip iprot _t500
          read_RemoveNodeDefault_args_fields iprot record
      4 -> if _t500 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNodeDefault_args_fields iprot record{f_RemoveNodeDefault_args_libID=Just s}
        else do
          skip iprot _t500
          read_RemoveNodeDefault_args_fields iprot record
      5 -> if _t500 == T_I32 then do
        s <- readI32 iprot
        read_RemoveNodeDefault_args_fields iprot record{f_RemoveNodeDefault_args_projectID=Just s}
        else do
          skip iprot _t500
          read_RemoveNodeDefault_args_fields iprot record
      _ -> do
        skip iprot _t500
        readFieldEnd iprot
        read_RemoveNodeDefault_args_fields iprot record
read_RemoveNodeDefault_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNodeDefault_args_fields iprot (RemoveNodeDefault_args{f_RemoveNodeDefault_args_dst=Nothing,f_RemoveNodeDefault_args_nodeID=Nothing,f_RemoveNodeDefault_args_defID=Nothing,f_RemoveNodeDefault_args_libID=Nothing,f_RemoveNodeDefault_args_projectID=Nothing})
  readStructEnd iprot
  return record
data RemoveNodeDefault_result = RemoveNodeDefault_result{f_RemoveNodeDefault_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveNodeDefault_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNodeDefault_result_missingFields record  
write_RemoveNodeDefault_result oprot record = do
  writeStructBegin oprot "RemoveNodeDefault_result"
  case f_RemoveNodeDefault_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNodeDefault_result_fields iprot record = do
  (_,_t510,_id511) <- readFieldBegin iprot
  if _t510 == T_STOP then return record else
    case _id511 of 
      1 -> if _t510 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveNodeDefault_result_fields iprot record{f_RemoveNodeDefault_result_missingFields=Just s}
        else do
          skip iprot _t510
          read_RemoveNodeDefault_result_fields iprot record
      _ -> do
        skip iprot _t510
        readFieldEnd iprot
        read_RemoveNodeDefault_result_fields iprot record
read_RemoveNodeDefault_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNodeDefault_result_fields iprot (RemoveNodeDefault_result{f_RemoveNodeDefault_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_ls_args = FS_ls_args{f_FS_ls_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_ls_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_ls_args_path record  
write_FS_ls_args oprot record = do
  writeStructBegin oprot "FS_ls_args"
  case f_FS_ls_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_ls_args_fields iprot record = do
  (_,_t515,_id516) <- readFieldBegin iprot
  if _t515 == T_STOP then return record else
    case _id516 of 
      1 -> if _t515 == T_STRING then do
        s <- readString iprot
        read_FS_ls_args_fields iprot record{f_FS_ls_args_path=Just s}
        else do
          skip iprot _t515
          read_FS_ls_args_fields iprot record
      _ -> do
        skip iprot _t515
        readFieldEnd iprot
        read_FS_ls_args_fields iprot record
read_FS_ls_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_ls_args_fields iprot (FS_ls_args{f_FS_ls_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_ls_result = FS_ls_result{f_FS_ls_result_success :: Maybe (Vector.Vector Fs_Types.FSItem),f_FS_ls_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_ls_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_ls_result_success record   `hashWithSalt` f_FS_ls_result_missingFields record  
write_FS_ls_result oprot record = do
  writeStructBegin oprot "FS_ls_result"
  case f_FS_ls_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter519 -> Fs_Types.write_FSItem oprot _viter519) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_FS_ls_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_ls_result_fields iprot record = do
  (_,_t521,_id522) <- readFieldBegin iprot
  if _t521 == T_STOP then return record else
    case _id522 of 
      0 -> if _t521 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_FSItem iprot)) in do {(_etype526,_size523) <- readListBegin iprot; f _size523})
        read_FS_ls_result_fields iprot record{f_FS_ls_result_success=Just s}
        else do
          skip iprot _t521
          read_FS_ls_result_fields iprot record
      1 -> if _t521 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_ls_result_fields iprot record{f_FS_ls_result_missingFields=Just s}
        else do
          skip iprot _t521
          read_FS_ls_result_fields iprot record
      _ -> do
        skip iprot _t521
        readFieldEnd iprot
        read_FS_ls_result_fields iprot record
read_FS_ls_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_ls_result_fields iprot (FS_ls_result{f_FS_ls_result_success=Nothing,f_FS_ls_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_stat_args = FS_stat_args{f_FS_stat_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_stat_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_stat_args_path record  
write_FS_stat_args oprot record = do
  writeStructBegin oprot "FS_stat_args"
  case f_FS_stat_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_stat_args_fields iprot record = do
  (_,_t531,_id532) <- readFieldBegin iprot
  if _t531 == T_STOP then return record else
    case _id532 of 
      1 -> if _t531 == T_STRING then do
        s <- readString iprot
        read_FS_stat_args_fields iprot record{f_FS_stat_args_path=Just s}
        else do
          skip iprot _t531
          read_FS_stat_args_fields iprot record
      _ -> do
        skip iprot _t531
        readFieldEnd iprot
        read_FS_stat_args_fields iprot record
read_FS_stat_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_stat_args_fields iprot (FS_stat_args{f_FS_stat_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_stat_result = FS_stat_result{f_FS_stat_result_success :: Maybe Fs_Types.FSItem,f_FS_stat_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_stat_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_stat_result_success record   `hashWithSalt` f_FS_stat_result_missingFields record  
write_FS_stat_result oprot record = do
  writeStructBegin oprot "FS_stat_result"
  case f_FS_stat_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Fs_Types.write_FSItem oprot _v
    writeFieldEnd oprot}
  case f_FS_stat_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_stat_result_fields iprot record = do
  (_,_t536,_id537) <- readFieldBegin iprot
  if _t536 == T_STOP then return record else
    case _id537 of 
      0 -> if _t536 == T_STRUCT then do
        s <- (read_FSItem iprot)
        read_FS_stat_result_fields iprot record{f_FS_stat_result_success=Just s}
        else do
          skip iprot _t536
          read_FS_stat_result_fields iprot record
      1 -> if _t536 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_stat_result_fields iprot record{f_FS_stat_result_missingFields=Just s}
        else do
          skip iprot _t536
          read_FS_stat_result_fields iprot record
      _ -> do
        skip iprot _t536
        readFieldEnd iprot
        read_FS_stat_result_fields iprot record
read_FS_stat_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_stat_result_fields iprot (FS_stat_result{f_FS_stat_result_success=Nothing,f_FS_stat_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_mkdir_args = FS_mkdir_args{f_FS_mkdir_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_mkdir_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mkdir_args_path record  
write_FS_mkdir_args oprot record = do
  writeStructBegin oprot "FS_mkdir_args"
  case f_FS_mkdir_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mkdir_args_fields iprot record = do
  (_,_t541,_id542) <- readFieldBegin iprot
  if _t541 == T_STOP then return record else
    case _id542 of 
      1 -> if _t541 == T_STRING then do
        s <- readString iprot
        read_FS_mkdir_args_fields iprot record{f_FS_mkdir_args_path=Just s}
        else do
          skip iprot _t541
          read_FS_mkdir_args_fields iprot record
      _ -> do
        skip iprot _t541
        readFieldEnd iprot
        read_FS_mkdir_args_fields iprot record
read_FS_mkdir_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mkdir_args_fields iprot (FS_mkdir_args{f_FS_mkdir_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_mkdir_result = FS_mkdir_result{f_FS_mkdir_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_mkdir_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mkdir_result_missingFields record  
write_FS_mkdir_result oprot record = do
  writeStructBegin oprot "FS_mkdir_result"
  case f_FS_mkdir_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mkdir_result_fields iprot record = do
  (_,_t546,_id547) <- readFieldBegin iprot
  if _t546 == T_STOP then return record else
    case _id547 of 
      1 -> if _t546 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_mkdir_result_fields iprot record{f_FS_mkdir_result_missingFields=Just s}
        else do
          skip iprot _t546
          read_FS_mkdir_result_fields iprot record
      _ -> do
        skip iprot _t546
        readFieldEnd iprot
        read_FS_mkdir_result_fields iprot record
read_FS_mkdir_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mkdir_result_fields iprot (FS_mkdir_result{f_FS_mkdir_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_touch_args = FS_touch_args{f_FS_touch_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_touch_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_touch_args_path record  
write_FS_touch_args oprot record = do
  writeStructBegin oprot "FS_touch_args"
  case f_FS_touch_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_touch_args_fields iprot record = do
  (_,_t551,_id552) <- readFieldBegin iprot
  if _t551 == T_STOP then return record else
    case _id552 of 
      1 -> if _t551 == T_STRING then do
        s <- readString iprot
        read_FS_touch_args_fields iprot record{f_FS_touch_args_path=Just s}
        else do
          skip iprot _t551
          read_FS_touch_args_fields iprot record
      _ -> do
        skip iprot _t551
        readFieldEnd iprot
        read_FS_touch_args_fields iprot record
read_FS_touch_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_touch_args_fields iprot (FS_touch_args{f_FS_touch_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_touch_result = FS_touch_result{f_FS_touch_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_touch_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_touch_result_missingFields record  
write_FS_touch_result oprot record = do
  writeStructBegin oprot "FS_touch_result"
  case f_FS_touch_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_touch_result_fields iprot record = do
  (_,_t556,_id557) <- readFieldBegin iprot
  if _t556 == T_STOP then return record else
    case _id557 of 
      1 -> if _t556 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_touch_result_fields iprot record{f_FS_touch_result_missingFields=Just s}
        else do
          skip iprot _t556
          read_FS_touch_result_fields iprot record
      _ -> do
        skip iprot _t556
        readFieldEnd iprot
        read_FS_touch_result_fields iprot record
read_FS_touch_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_touch_result_fields iprot (FS_touch_result{f_FS_touch_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_rm_args = FS_rm_args{f_FS_rm_args_path :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_rm_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_rm_args_path record  
write_FS_rm_args oprot record = do
  writeStructBegin oprot "FS_rm_args"
  case f_FS_rm_args_path record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("path",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_rm_args_fields iprot record = do
  (_,_t561,_id562) <- readFieldBegin iprot
  if _t561 == T_STOP then return record else
    case _id562 of 
      1 -> if _t561 == T_STRING then do
        s <- readString iprot
        read_FS_rm_args_fields iprot record{f_FS_rm_args_path=Just s}
        else do
          skip iprot _t561
          read_FS_rm_args_fields iprot record
      _ -> do
        skip iprot _t561
        readFieldEnd iprot
        read_FS_rm_args_fields iprot record
read_FS_rm_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_rm_args_fields iprot (FS_rm_args{f_FS_rm_args_path=Nothing})
  readStructEnd iprot
  return record
data FS_rm_result = FS_rm_result{f_FS_rm_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_rm_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_rm_result_missingFields record  
write_FS_rm_result oprot record = do
  writeStructBegin oprot "FS_rm_result"
  case f_FS_rm_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_rm_result_fields iprot record = do
  (_,_t566,_id567) <- readFieldBegin iprot
  if _t566 == T_STOP then return record else
    case _id567 of 
      1 -> if _t566 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_rm_result_fields iprot record{f_FS_rm_result_missingFields=Just s}
        else do
          skip iprot _t566
          read_FS_rm_result_fields iprot record
      _ -> do
        skip iprot _t566
        readFieldEnd iprot
        read_FS_rm_result_fields iprot record
read_FS_rm_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_rm_result_fields iprot (FS_rm_result{f_FS_rm_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_cp_args = FS_cp_args{f_FS_cp_args_src :: Maybe Text,f_FS_cp_args_dst :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_cp_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_cp_args_src record   `hashWithSalt` f_FS_cp_args_dst record  
write_FS_cp_args oprot record = do
  writeStructBegin oprot "FS_cp_args"
  case f_FS_cp_args_src record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("src",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_FS_cp_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_cp_args_fields iprot record = do
  (_,_t571,_id572) <- readFieldBegin iprot
  if _t571 == T_STOP then return record else
    case _id572 of 
      1 -> if _t571 == T_STRING then do
        s <- readString iprot
        read_FS_cp_args_fields iprot record{f_FS_cp_args_src=Just s}
        else do
          skip iprot _t571
          read_FS_cp_args_fields iprot record
      2 -> if _t571 == T_STRING then do
        s <- readString iprot
        read_FS_cp_args_fields iprot record{f_FS_cp_args_dst=Just s}
        else do
          skip iprot _t571
          read_FS_cp_args_fields iprot record
      _ -> do
        skip iprot _t571
        readFieldEnd iprot
        read_FS_cp_args_fields iprot record
read_FS_cp_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_cp_args_fields iprot (FS_cp_args{f_FS_cp_args_src=Nothing,f_FS_cp_args_dst=Nothing})
  readStructEnd iprot
  return record
data FS_cp_result = FS_cp_result{f_FS_cp_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_cp_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_cp_result_missingFields record  
write_FS_cp_result oprot record = do
  writeStructBegin oprot "FS_cp_result"
  case f_FS_cp_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_cp_result_fields iprot record = do
  (_,_t576,_id577) <- readFieldBegin iprot
  if _t576 == T_STOP then return record else
    case _id577 of 
      1 -> if _t576 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_cp_result_fields iprot record{f_FS_cp_result_missingFields=Just s}
        else do
          skip iprot _t576
          read_FS_cp_result_fields iprot record
      _ -> do
        skip iprot _t576
        readFieldEnd iprot
        read_FS_cp_result_fields iprot record
read_FS_cp_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_cp_result_fields iprot (FS_cp_result{f_FS_cp_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data FS_mv_args = FS_mv_args{f_FS_mv_args_src :: Maybe Text,f_FS_mv_args_dst :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable FS_mv_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mv_args_src record   `hashWithSalt` f_FS_mv_args_dst record  
write_FS_mv_args oprot record = do
  writeStructBegin oprot "FS_mv_args"
  case f_FS_mv_args_src record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("src",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_FS_mv_args_dst record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dst",T_STRING,2)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mv_args_fields iprot record = do
  (_,_t581,_id582) <- readFieldBegin iprot
  if _t581 == T_STOP then return record else
    case _id582 of 
      1 -> if _t581 == T_STRING then do
        s <- readString iprot
        read_FS_mv_args_fields iprot record{f_FS_mv_args_src=Just s}
        else do
          skip iprot _t581
          read_FS_mv_args_fields iprot record
      2 -> if _t581 == T_STRING then do
        s <- readString iprot
        read_FS_mv_args_fields iprot record{f_FS_mv_args_dst=Just s}
        else do
          skip iprot _t581
          read_FS_mv_args_fields iprot record
      _ -> do
        skip iprot _t581
        readFieldEnd iprot
        read_FS_mv_args_fields iprot record
read_FS_mv_args iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mv_args_fields iprot (FS_mv_args{f_FS_mv_args_src=Nothing,f_FS_mv_args_dst=Nothing})
  readStructEnd iprot
  return record
data FS_mv_result = FS_mv_result{f_FS_mv_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable FS_mv_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_FS_mv_result_missingFields record  
write_FS_mv_result oprot record = do
  writeStructBegin oprot "FS_mv_result"
  case f_FS_mv_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_FS_mv_result_fields iprot record = do
  (_,_t586,_id587) <- readFieldBegin iprot
  if _t586 == T_STOP then return record else
    case _id587 of 
      1 -> if _t586 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_FS_mv_result_fields iprot record{f_FS_mv_result_missingFields=Just s}
        else do
          skip iprot _t586
          read_FS_mv_result_fields iprot record
      _ -> do
        skip iprot _t586
        readFieldEnd iprot
        read_FS_mv_result_fields iprot record
read_FS_mv_result iprot = do
  _ <- readStructBegin iprot
  record <- read_FS_mv_result_fields iprot (FS_mv_result{f_FS_mv_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Initialize_args = Initialize_args deriving (Show,Eq,Typeable)
instance Hashable Initialize_args where
  hashWithSalt salt record = salt  
write_Initialize_args oprot record = do
  writeStructBegin oprot "Initialize_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Initialize_args_fields iprot record = do
  (_,_t591,_id592) <- readFieldBegin iprot
  if _t591 == T_STOP then return record else
    case _id592 of 
      _ -> do
        skip iprot _t591
        readFieldEnd iprot
        read_Initialize_args_fields iprot record
read_Initialize_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Initialize_args_fields iprot (Initialize_args{})
  readStructEnd iprot
  return record
data Initialize_result = Initialize_result deriving (Show,Eq,Typeable)
instance Hashable Initialize_result where
  hashWithSalt salt record = salt  
write_Initialize_result oprot record = do
  writeStructBegin oprot "Initialize_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Initialize_result_fields iprot record = do
  (_,_t596,_id597) <- readFieldBegin iprot
  if _t596 == T_STOP then return record else
    case _id597 of 
      _ -> do
        skip iprot _t596
        readFieldEnd iprot
        read_Initialize_result_fields iprot record
read_Initialize_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Initialize_result_fields iprot (Initialize_result{})
  readStructEnd iprot
  return record
data Ping_args = Ping_args deriving (Show,Eq,Typeable)
instance Hashable Ping_args where
  hashWithSalt salt record = salt  
write_Ping_args oprot record = do
  writeStructBegin oprot "Ping_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_args_fields iprot record = do
  (_,_t601,_id602) <- readFieldBegin iprot
  if _t601 == T_STOP then return record else
    case _id602 of 
      _ -> do
        skip iprot _t601
        readFieldEnd iprot
        read_Ping_args_fields iprot record
read_Ping_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_args_fields iprot (Ping_args{})
  readStructEnd iprot
  return record
data Ping_result = Ping_result deriving (Show,Eq,Typeable)
instance Hashable Ping_result where
  hashWithSalt salt record = salt  
write_Ping_result oprot record = do
  writeStructBegin oprot "Ping_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_result_fields iprot record = do
  (_,_t606,_id607) <- readFieldBegin iprot
  if _t606 == T_STOP then return record else
    case _id607 of 
      _ -> do
        skip iprot _t606
        readFieldEnd iprot
        read_Ping_result_fields iprot record
read_Ping_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_result_fields iprot (Ping_result{})
  readStructEnd iprot
  return record
data Dump_args = Dump_args deriving (Show,Eq,Typeable)
instance Hashable Dump_args where
  hashWithSalt salt record = salt  
write_Dump_args oprot record = do
  writeStructBegin oprot "Dump_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Dump_args_fields iprot record = do
  (_,_t611,_id612) <- readFieldBegin iprot
  if _t611 == T_STOP then return record else
    case _id612 of 
      _ -> do
        skip iprot _t611
        readFieldEnd iprot
        read_Dump_args_fields iprot record
read_Dump_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Dump_args_fields iprot (Dump_args{})
  readStructEnd iprot
  return record
data Dump_result = Dump_result deriving (Show,Eq,Typeable)
instance Hashable Dump_result where
  hashWithSalt salt record = salt  
write_Dump_result oprot record = do
  writeStructBegin oprot "Dump_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Dump_result_fields iprot record = do
  (_,_t616,_id617) <- readFieldBegin iprot
  if _t616 == T_STOP then return record else
    case _id617 of 
      _ -> do
        skip iprot _t616
        readFieldEnd iprot
        read_Dump_result_fields iprot record
read_Dump_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Dump_result_fields iprot (Dump_result{})
  readStructEnd iprot
  return record
data Shutdown_args = Shutdown_args deriving (Show,Eq,Typeable)
instance Hashable Shutdown_args where
  hashWithSalt salt record = salt  
write_Shutdown_args oprot record = do
  writeStructBegin oprot "Shutdown_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Shutdown_args_fields iprot record = do
  (_,_t621,_id622) <- readFieldBegin iprot
  if _t621 == T_STOP then return record else
    case _id622 of 
      _ -> do
        skip iprot _t621
        readFieldEnd iprot
        read_Shutdown_args_fields iprot record
read_Shutdown_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Shutdown_args_fields iprot (Shutdown_args{})
  readStructEnd iprot
  return record
data Shutdown_result = Shutdown_result deriving (Show,Eq,Typeable)
instance Hashable Shutdown_result where
  hashWithSalt salt record = salt  
write_Shutdown_result oprot record = do
  writeStructBegin oprot "Shutdown_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Shutdown_result_fields iprot record = do
  (_,_t626,_id627) <- readFieldBegin iprot
  if _t626 == T_STOP then return record else
    case _id627 of 
      _ -> do
        skip iprot _t626
        readFieldEnd iprot
        read_Shutdown_result_fields iprot record
read_Shutdown_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Shutdown_result_fields iprot (Shutdown_result{})
  readStructEnd iprot
  return record
process_projects (seqid, iprot, oprot, handler) = do
  args <- read_Projects_args iprot
  readMessageEnd iprot
  rs <- return (Projects_result Nothing)
  res <- (do
    res <- Iface.projects handler
    return rs{f_Projects_result_success= Just res})
  writeMessageBegin oprot ("projects", M_REPLY, seqid);
  write_Projects_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_projectByID (seqid, iprot, oprot, handler) = do
  args <- read_ProjectByID_args iprot
  readMessageEnd iprot
  rs <- return (ProjectByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.projectByID handler (f_ProjectByID_args_projectID args)
      return rs{f_ProjectByID_result_success= Just res})
    (\e  -> 
      return rs{f_ProjectByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("projectByID", M_REPLY, seqid);
  write_ProjectByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createProject (seqid, iprot, oprot, handler) = do
  args <- read_CreateProject_args iprot
  readMessageEnd iprot
  rs <- return (CreateProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createProject handler (f_CreateProject_args_project args)
      return rs{f_CreateProject_result_success= Just res})
    (\e  -> 
      return rs{f_CreateProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("createProject", M_REPLY, seqid);
  write_CreateProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_openProject (seqid, iprot, oprot, handler) = do
  args <- read_OpenProject_args iprot
  readMessageEnd iprot
  rs <- return (OpenProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.openProject handler (f_OpenProject_args_path args)
      return rs{f_OpenProject_result_success= Just res})
    (\e  -> 
      return rs{f_OpenProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("openProject", M_REPLY, seqid);
  write_OpenProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateProject (seqid, iprot, oprot, handler) = do
  args <- read_UpdateProject_args iprot
  readMessageEnd iprot
  rs <- return (UpdateProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateProject handler (f_UpdateProject_args_project args)
      return rs)
    (\e  -> 
      return rs{f_UpdateProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateProject", M_REPLY, seqid);
  write_UpdateProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_closeProject (seqid, iprot, oprot, handler) = do
  args <- read_CloseProject_args iprot
  readMessageEnd iprot
  rs <- return (CloseProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.closeProject handler (f_CloseProject_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_CloseProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("closeProject", M_REPLY, seqid);
  write_CloseProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_storeProject (seqid, iprot, oprot, handler) = do
  args <- read_StoreProject_args iprot
  readMessageEnd iprot
  rs <- return (StoreProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.storeProject handler (f_StoreProject_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_StoreProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("storeProject", M_REPLY, seqid);
  write_StoreProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraries (seqid, iprot, oprot, handler) = do
  args <- read_Libraries_args iprot
  readMessageEnd iprot
  rs <- return (Libraries_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraries handler (f_Libraries_args_projectID args)
      return rs{f_Libraries_result_success= Just res})
    (\e  -> 
      return rs{f_Libraries_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraries", M_REPLY, seqid);
  write_Libraries_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraryByID (seqid, iprot, oprot, handler) = do
  args <- read_LibraryByID_args iprot
  readMessageEnd iprot
  rs <- return (LibraryByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraryByID handler (f_LibraryByID_args_libraryID args) (f_LibraryByID_args_projectID args)
      return rs{f_LibraryByID_result_success= Just res})
    (\e  -> 
      return rs{f_LibraryByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraryByID", M_REPLY, seqid);
  write_LibraryByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createLibrary (seqid, iprot, oprot, handler) = do
  args <- read_CreateLibrary_args iprot
  readMessageEnd iprot
  rs <- return (CreateLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createLibrary handler (f_CreateLibrary_args_library args) (f_CreateLibrary_args_projectID args)
      return rs{f_CreateLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_CreateLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("createLibrary", M_REPLY, seqid);
  write_CreateLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_loadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_LoadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (LoadLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.loadLibrary handler (f_LoadLibrary_args_path args) (f_LoadLibrary_args_projectID args)
      return rs{f_LoadLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_LoadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("loadLibrary", M_REPLY, seqid);
  write_LoadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_unloadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_UnloadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (UnloadLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.unloadLibrary handler (f_UnloadLibrary_args_libID args) (f_UnloadLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UnloadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("unloadLibrary", M_REPLY, seqid);
  write_UnloadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_storeLibrary (seqid, iprot, oprot, handler) = do
  args <- read_StoreLibrary_args iprot
  readMessageEnd iprot
  rs <- return (StoreLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.storeLibrary handler (f_StoreLibrary_args_libID args) (f_StoreLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_StoreLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("storeLibrary", M_REPLY, seqid);
  write_StoreLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_buildLibrary (seqid, iprot, oprot, handler) = do
  args <- read_BuildLibrary_args iprot
  readMessageEnd iprot
  rs <- return (BuildLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.buildLibrary handler (f_BuildLibrary_args_libID args) (f_BuildLibrary_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_BuildLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("buildLibrary", M_REPLY, seqid);
  write_BuildLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_runLibrary (seqid, iprot, oprot, handler) = do
  args <- read_RunLibrary_args iprot
  readMessageEnd iprot
  rs <- return (RunLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.runLibrary handler (f_RunLibrary_args_libID args) (f_RunLibrary_args_projectID args)
      return rs{f_RunLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_RunLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("runLibrary", M_REPLY, seqid);
  write_RunLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraryRootDef (seqid, iprot, oprot, handler) = do
  args <- read_LibraryRootDef_args iprot
  readMessageEnd iprot
  rs <- return (LibraryRootDef_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraryRootDef handler (f_LibraryRootDef_args_libID args) (f_LibraryRootDef_args_projectID args)
      return rs{f_LibraryRootDef_result_success= Just res})
    (\e  -> 
      return rs{f_LibraryRootDef_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraryRootDef", M_REPLY, seqid);
  write_LibraryRootDef_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_defsGraph (seqid, iprot, oprot, handler) = do
  args <- read_DefsGraph_args iprot
  readMessageEnd iprot
  rs <- return (DefsGraph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.defsGraph handler (f_DefsGraph_args_libID args) (f_DefsGraph_args_projectID args)
      return rs{f_DefsGraph_result_success= Just res})
    (\e  -> 
      return rs{f_DefsGraph_result_missingFields =Just e}))
  writeMessageBegin oprot ("defsGraph", M_REPLY, seqid);
  write_DefsGraph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_defByID (seqid, iprot, oprot, handler) = do
  args <- read_DefByID_args iprot
  readMessageEnd iprot
  rs <- return (DefByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.defByID handler (f_DefByID_args_defID args) (f_DefByID_args_libID args) (f_DefByID_args_projectID args)
      return rs{f_DefByID_result_success= Just res})
    (\e  -> 
      return rs{f_DefByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("defByID", M_REPLY, seqid);
  write_DefByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addDefinition (seqid, iprot, oprot, handler) = do
  args <- read_AddDefinition_args iprot
  readMessageEnd iprot
  rs <- return (AddDefinition_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addDefinition handler (f_AddDefinition_args_definition args) (f_AddDefinition_args_parentID args) (f_AddDefinition_args_libID args) (f_AddDefinition_args_projectID args)
      return rs{f_AddDefinition_result_success= Just res})
    (\e  -> 
      return rs{f_AddDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("addDefinition", M_REPLY, seqid);
  write_AddDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateDefinition (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDefinition_args iprot
  readMessageEnd iprot
  rs <- return (UpdateDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateDefinition handler (f_UpdateDefinition_args_definition args) (f_UpdateDefinition_args_libID args) (f_UpdateDefinition_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UpdateDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateDefinition", M_REPLY, seqid);
  write_UpdateDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeDefinition (seqid, iprot, oprot, handler) = do
  args <- read_RemoveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (RemoveDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeDefinition handler (f_RemoveDefinition_args_defID args) (f_RemoveDefinition_args_libID args) (f_RemoveDefinition_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_RemoveDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeDefinition", M_REPLY, seqid);
  write_RemoveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionChildren (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionChildren_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionChildren_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionChildren handler (f_DefinitionChildren_args_defID args) (f_DefinitionChildren_args_libID args) (f_DefinitionChildren_args_projectID args)
      return rs{f_DefinitionChildren_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionChildren_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionChildren", M_REPLY, seqid);
  write_DefinitionChildren_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionParent (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionParent_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionParent_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionParent handler (f_DefinitionParent_args_defID args) (f_DefinitionParent_args_libID args) (f_DefinitionParent_args_projectID args)
      return rs{f_DefinitionParent_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionParent_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionParent", M_REPLY, seqid);
  write_DefinitionParent_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_resolveDefinition (seqid, iprot, oprot, handler) = do
  args <- read_ResolveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (ResolveDefinition_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.resolveDefinition handler (f_ResolveDefinition_args_name args) (f_ResolveDefinition_args_parentID args) (f_ResolveDefinition_args_libID args) (f_ResolveDefinition_args_projectID args)
      return rs{f_ResolveDefinition_result_success= Just res})
    (\e  -> 
      return rs{f_ResolveDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("resolveDefinition", M_REPLY, seqid);
  write_ResolveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeModule (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeModule_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeModule_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeModule handler (f_NewTypeModule_args_name args) (f_NewTypeModule_args_fields args)
      return rs{f_NewTypeModule_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeModule_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeModule", M_REPLY, seqid);
  write_NewTypeModule_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeClass (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeClass_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeClass_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeClass handler (f_NewTypeClass_args_name args) (f_NewTypeClass_args_params args) (f_NewTypeClass_args_fields args)
      return rs{f_NewTypeClass_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeClass_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeClass", M_REPLY, seqid);
  write_NewTypeClass_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeFunction (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeFunction_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeFunction_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeFunction handler (f_NewTypeFunction_args_name args) (f_NewTypeFunction_args_inputs args) (f_NewTypeFunction_args_outputs args)
      return rs{f_NewTypeFunction_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeFunction_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeFunction", M_REPLY, seqid);
  write_NewTypeFunction_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeUdefined (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeUdefined_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeUdefined_result Nothing)
  res <- (do
    res <- Iface.newTypeUdefined handler
    return rs{f_NewTypeUdefined_result_success= Just res})
  writeMessageBegin oprot ("newTypeUdefined", M_REPLY, seqid);
  write_NewTypeUdefined_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeNamed (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeNamed_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeNamed_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeNamed handler (f_NewTypeNamed_args_name args) (f_NewTypeNamed_args_type args)
      return rs{f_NewTypeNamed_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeNamed_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeNamed", M_REPLY, seqid);
  write_NewTypeNamed_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeName (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeName_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeName_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeName handler (f_NewTypeName_args_name args)
      return rs{f_NewTypeName_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeName_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeName", M_REPLY, seqid);
  write_NewTypeName_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeTuple (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeTuple_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeTuple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeTuple handler (f_NewTypeTuple_args_types args)
      return rs{f_NewTypeTuple_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeTuple_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeTuple", M_REPLY, seqid);
  write_NewTypeTuple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_nodesGraph (seqid, iprot, oprot, handler) = do
  args <- read_NodesGraph_args iprot
  readMessageEnd iprot
  rs <- return (NodesGraph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.nodesGraph handler (f_NodesGraph_args_defID args) (f_NodesGraph_args_libID args) (f_NodesGraph_args_projectID args)
      return rs{f_NodesGraph_result_success= Just res})
    (\e  -> 
      return rs{f_NodesGraph_result_missingFields =Just e}))
  writeMessageBegin oprot ("nodesGraph", M_REPLY, seqid);
  write_NodesGraph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_nodeByID (seqid, iprot, oprot, handler) = do
  args <- read_NodeByID_args iprot
  readMessageEnd iprot
  rs <- return (NodeByID_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.nodeByID handler (f_NodeByID_args_nodeID args) (f_NodeByID_args_defID args) (f_NodeByID_args_libID args) (f_NodeByID_args_projectID args)
      return rs{f_NodeByID_result_success= Just res})
    (\e  -> 
      return rs{f_NodeByID_result_missingFields =Just e}))
  writeMessageBegin oprot ("nodeByID", M_REPLY, seqid);
  write_NodeByID_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addNode (seqid, iprot, oprot, handler) = do
  args <- read_AddNode_args iprot
  readMessageEnd iprot
  rs <- return (AddNode_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addNode handler (f_AddNode_args_node args) (f_AddNode_args_defID args) (f_AddNode_args_libID args) (f_AddNode_args_projectID args)
      return rs{f_AddNode_result_success= Just res})
    (\e  -> 
      return rs{f_AddNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("addNode", M_REPLY, seqid);
  write_AddNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateNode (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNode_args iprot
  readMessageEnd iprot
  rs <- return (UpdateNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateNode handler (f_UpdateNode_args_node args) (f_UpdateNode_args_defID args) (f_UpdateNode_args_libID args) (f_UpdateNode_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_UpdateNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateNode", M_REPLY, seqid);
  write_UpdateNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNode (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNode_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeNode handler (f_RemoveNode_args_nodeID args) (f_RemoveNode_args_defID args) (f_RemoveNode_args_libID args) (f_RemoveNode_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_RemoveNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeNode", M_REPLY, seqid);
  write_RemoveNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_connect (seqid, iprot, oprot, handler) = do
  args <- read_Connect_args iprot
  readMessageEnd iprot
  rs <- return (Connect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.connect handler (f_Connect_args_srcNodeID args) (f_Connect_args_srcPort args) (f_Connect_args_dstNodeID args) (f_Connect_args_dstPort args) (f_Connect_args_defID args) (f_Connect_args_libID args) (f_Connect_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_Connect_result_missingFields =Just e}))
  writeMessageBegin oprot ("connect", M_REPLY, seqid);
  write_Connect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disconnect (seqid, iprot, oprot, handler) = do
  args <- read_Disconnect_args iprot
  readMessageEnd iprot
  rs <- return (Disconnect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.disconnect handler (f_Disconnect_args_srcNodeID args) (f_Disconnect_args_srcPort args) (f_Disconnect_args_dstNodeID args) (f_Disconnect_args_dstPort args) (f_Disconnect_args_defID args) (f_Disconnect_args_libID args) (f_Disconnect_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_Disconnect_result_missingFields =Just e}))
  writeMessageBegin oprot ("disconnect", M_REPLY, seqid);
  write_Disconnect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_nodeDefaults (seqid, iprot, oprot, handler) = do
  args <- read_NodeDefaults_args iprot
  readMessageEnd iprot
  rs <- return (NodeDefaults_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.nodeDefaults handler (f_NodeDefaults_args_nodeID args) (f_NodeDefaults_args_defID args) (f_NodeDefaults_args_libID args) (f_NodeDefaults_args_projectID args)
      return rs{f_NodeDefaults_result_success= Just res})
    (\e  -> 
      return rs{f_NodeDefaults_result_missingFields =Just e}))
  writeMessageBegin oprot ("nodeDefaults", M_REPLY, seqid);
  write_NodeDefaults_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_setNodeDefault (seqid, iprot, oprot, handler) = do
  args <- read_SetNodeDefault_args iprot
  readMessageEnd iprot
  rs <- return (SetNodeDefault_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.setNodeDefault handler (f_SetNodeDefault_args_dst args) (f_SetNodeDefault_args_value args) (f_SetNodeDefault_args_nodeID args) (f_SetNodeDefault_args_defID args) (f_SetNodeDefault_args_libID args) (f_SetNodeDefault_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_SetNodeDefault_result_missingFields =Just e}))
  writeMessageBegin oprot ("setNodeDefault", M_REPLY, seqid);
  write_SetNodeDefault_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNodeDefault (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNodeDefault_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNodeDefault_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeNodeDefault handler (f_RemoveNodeDefault_args_dst args) (f_RemoveNodeDefault_args_nodeID args) (f_RemoveNodeDefault_args_defID args) (f_RemoveNodeDefault_args_libID args) (f_RemoveNodeDefault_args_projectID args)
      return rs)
    (\e  -> 
      return rs{f_RemoveNodeDefault_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeNodeDefault", M_REPLY, seqid);
  write_RemoveNodeDefault_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_ls (seqid, iprot, oprot, handler) = do
  args <- read_FS_ls_args iprot
  readMessageEnd iprot
  rs <- return (FS_ls_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.fS_ls handler (f_FS_ls_args_path args)
      return rs{f_FS_ls_result_success= Just res})
    (\e  -> 
      return rs{f_FS_ls_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_ls", M_REPLY, seqid);
  write_FS_ls_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_stat (seqid, iprot, oprot, handler) = do
  args <- read_FS_stat_args iprot
  readMessageEnd iprot
  rs <- return (FS_stat_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.fS_stat handler (f_FS_stat_args_path args)
      return rs{f_FS_stat_result_success= Just res})
    (\e  -> 
      return rs{f_FS_stat_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_stat", M_REPLY, seqid);
  write_FS_stat_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_mkdir (seqid, iprot, oprot, handler) = do
  args <- read_FS_mkdir_args iprot
  readMessageEnd iprot
  rs <- return (FS_mkdir_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_mkdir handler (f_FS_mkdir_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_mkdir_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_mkdir", M_REPLY, seqid);
  write_FS_mkdir_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_touch (seqid, iprot, oprot, handler) = do
  args <- read_FS_touch_args iprot
  readMessageEnd iprot
  rs <- return (FS_touch_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_touch handler (f_FS_touch_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_touch_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_touch", M_REPLY, seqid);
  write_FS_touch_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_rm (seqid, iprot, oprot, handler) = do
  args <- read_FS_rm_args iprot
  readMessageEnd iprot
  rs <- return (FS_rm_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_rm handler (f_FS_rm_args_path args)
      return rs)
    (\e  -> 
      return rs{f_FS_rm_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_rm", M_REPLY, seqid);
  write_FS_rm_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_cp (seqid, iprot, oprot, handler) = do
  args <- read_FS_cp_args iprot
  readMessageEnd iprot
  rs <- return (FS_cp_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_cp handler (f_FS_cp_args_src args) (f_FS_cp_args_dst args)
      return rs)
    (\e  -> 
      return rs{f_FS_cp_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_cp", M_REPLY, seqid);
  write_FS_cp_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_fS_mv (seqid, iprot, oprot, handler) = do
  args <- read_FS_mv_args iprot
  readMessageEnd iprot
  rs <- return (FS_mv_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.fS_mv handler (f_FS_mv_args_src args) (f_FS_mv_args_dst args)
      return rs)
    (\e  -> 
      return rs{f_FS_mv_result_missingFields =Just e}))
  writeMessageBegin oprot ("FS_mv", M_REPLY, seqid);
  write_FS_mv_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_initialize (seqid, iprot, oprot, handler) = do
  args <- read_Initialize_args iprot
  readMessageEnd iprot
  rs <- return (Initialize_result)
  res <- (do
    Iface.initialize handler
    return rs)
  writeMessageBegin oprot ("initialize", M_REPLY, seqid);
  write_Initialize_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  readMessageEnd iprot
  rs <- return (Ping_result)
  res <- (do
    Iface.ping handler
    return rs)
  writeMessageBegin oprot ("ping", M_REPLY, seqid);
  write_Ping_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_dump (seqid, iprot, oprot, handler) = do
  args <- read_Dump_args iprot
  readMessageEnd iprot
  rs <- return (Dump_result)
  res <- (do
    Iface.dump handler
    return rs)
  writeMessageBegin oprot ("dump", M_REPLY, seqid);
  write_Dump_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_shutdown (seqid, iprot, oprot, handler) = do
  args <- read_Shutdown_args iprot
  readMessageEnd iprot
  rs <- return (Shutdown_result)
  res <- (do
    Iface.shutdown handler
    return rs)
  writeMessageBegin oprot ("shutdown", M_REPLY, seqid);
  write_Shutdown_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "projects" -> process_projects (seqid,iprot,oprot,handler)
  "projectByID" -> process_projectByID (seqid,iprot,oprot,handler)
  "createProject" -> process_createProject (seqid,iprot,oprot,handler)
  "openProject" -> process_openProject (seqid,iprot,oprot,handler)
  "updateProject" -> process_updateProject (seqid,iprot,oprot,handler)
  "closeProject" -> process_closeProject (seqid,iprot,oprot,handler)
  "storeProject" -> process_storeProject (seqid,iprot,oprot,handler)
  "libraries" -> process_libraries (seqid,iprot,oprot,handler)
  "libraryByID" -> process_libraryByID (seqid,iprot,oprot,handler)
  "createLibrary" -> process_createLibrary (seqid,iprot,oprot,handler)
  "loadLibrary" -> process_loadLibrary (seqid,iprot,oprot,handler)
  "unloadLibrary" -> process_unloadLibrary (seqid,iprot,oprot,handler)
  "storeLibrary" -> process_storeLibrary (seqid,iprot,oprot,handler)
  "buildLibrary" -> process_buildLibrary (seqid,iprot,oprot,handler)
  "runLibrary" -> process_runLibrary (seqid,iprot,oprot,handler)
  "libraryRootDef" -> process_libraryRootDef (seqid,iprot,oprot,handler)
  "defsGraph" -> process_defsGraph (seqid,iprot,oprot,handler)
  "defByID" -> process_defByID (seqid,iprot,oprot,handler)
  "addDefinition" -> process_addDefinition (seqid,iprot,oprot,handler)
  "updateDefinition" -> process_updateDefinition (seqid,iprot,oprot,handler)
  "removeDefinition" -> process_removeDefinition (seqid,iprot,oprot,handler)
  "definitionChildren" -> process_definitionChildren (seqid,iprot,oprot,handler)
  "definitionParent" -> process_definitionParent (seqid,iprot,oprot,handler)
  "resolveDefinition" -> process_resolveDefinition (seqid,iprot,oprot,handler)
  "newTypeModule" -> process_newTypeModule (seqid,iprot,oprot,handler)
  "newTypeClass" -> process_newTypeClass (seqid,iprot,oprot,handler)
  "newTypeFunction" -> process_newTypeFunction (seqid,iprot,oprot,handler)
  "newTypeUdefined" -> process_newTypeUdefined (seqid,iprot,oprot,handler)
  "newTypeNamed" -> process_newTypeNamed (seqid,iprot,oprot,handler)
  "newTypeName" -> process_newTypeName (seqid,iprot,oprot,handler)
  "newTypeTuple" -> process_newTypeTuple (seqid,iprot,oprot,handler)
  "nodesGraph" -> process_nodesGraph (seqid,iprot,oprot,handler)
  "nodeByID" -> process_nodeByID (seqid,iprot,oprot,handler)
  "addNode" -> process_addNode (seqid,iprot,oprot,handler)
  "updateNode" -> process_updateNode (seqid,iprot,oprot,handler)
  "removeNode" -> process_removeNode (seqid,iprot,oprot,handler)
  "connect" -> process_connect (seqid,iprot,oprot,handler)
  "disconnect" -> process_disconnect (seqid,iprot,oprot,handler)
  "nodeDefaults" -> process_nodeDefaults (seqid,iprot,oprot,handler)
  "setNodeDefault" -> process_setNodeDefault (seqid,iprot,oprot,handler)
  "removeNodeDefault" -> process_removeNodeDefault (seqid,iprot,oprot,handler)
  "FS_ls" -> process_fS_ls (seqid,iprot,oprot,handler)
  "FS_stat" -> process_fS_stat (seqid,iprot,oprot,handler)
  "FS_mkdir" -> process_fS_mkdir (seqid,iprot,oprot,handler)
  "FS_touch" -> process_fS_touch (seqid,iprot,oprot,handler)
  "FS_rm" -> process_fS_rm (seqid,iprot,oprot,handler)
  "FS_cp" -> process_fS_cp (seqid,iprot,oprot,handler)
  "FS_mv" -> process_fS_mv (seqid,iprot,oprot,handler)
  "initialize" -> process_initialize (seqid,iprot,oprot,handler)
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  "dump" -> process_dump (seqid,iprot,oprot,handler)
  "shutdown" -> process_shutdown (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
