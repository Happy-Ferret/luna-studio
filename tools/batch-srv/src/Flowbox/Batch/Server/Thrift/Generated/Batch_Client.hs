{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch_Client(projects,createProject,openProject,closeProject,storeProject,libraries,createLibrary,loadLibrary,unloadLibrary,storeLibrary,buildLibrary,libraryRootDef,defsGraph,defByID,addDefinition,updateDefinition,removeDefinition,definitionChildren,definitionParent,newTypeModule,newTypeClass,newTypeFunction,newTypeUdefined,newTypeNamed,newTypeVariable,newTypeList,newTypeTuple,nodesGraph,nodeByID,addNode,updateNode,removeNode,connect,disconnect,fS_ls,fS_stat,fS_mkdir,fS_touch,fS_rm,fS_cp,fS_mv,ping,dump) where
import           Data.IORef             
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import           Control.Exception      
import           Data.ByteString.Lazy   
import           Data.Hashable          
import           Data.Int               
import           Data.Text.Lazy         ( Text )
import qualified Data.Text.Lazy       as TL
import           Data.Typeable          ( Typeable )
import qualified Data.HashMap.Strict  as Map
import qualified Data.HashSet         as Set
import qualified Data.Vector          as Vector

import           Thrift                 
import           Thrift.Types           ()

import qualified Fs_Types               
import qualified Graphview_Types        
import qualified Projects_Types         
import qualified Attrs_Types            
import qualified Defs_Types             
import qualified Graph_Types            
import qualified Libs_Types             
import qualified Types_Types            


import           Batch_Types            
import           Batch                  
seqid = newIORef 0
projects (ip,op) = do
  send_projects op
  recv_projects ip
send_projects op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("projects", M_CALL, seqn)
  write_Projects_args op (Projects_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_projects ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Projects_result ip
  readMessageEnd ip
  case f_Projects_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "projects failed: unknown result")
createProject (ip,op) arg_project = do
  send_createProject op arg_project
  recv_createProject ip
send_createProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("createProject", M_CALL, seqn)
  write_CreateProject_args op (CreateProject_args{f_CreateProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_createProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CreateProject_result ip
  readMessageEnd ip
  case f_CreateProject_result_success res of
    Just v -> return v
    Nothing -> do
      case f_CreateProject_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "createProject failed: unknown result")
openProject (ip,op) arg_path = do
  send_openProject op arg_path
  recv_openProject ip
send_openProject op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("openProject", M_CALL, seqn)
  write_OpenProject_args op (OpenProject_args{f_OpenProject_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_openProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_OpenProject_result ip
  readMessageEnd ip
  case f_OpenProject_result_success res of
    Just v -> return v
    Nothing -> do
      case f_OpenProject_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "openProject failed: unknown result")
closeProject (ip,op) arg_projectID = do
  send_closeProject op arg_projectID
  recv_closeProject ip
send_closeProject op arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("closeProject", M_CALL, seqn)
  write_CloseProject_args op (CloseProject_args{f_CloseProject_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_closeProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CloseProject_result ip
  readMessageEnd ip
  case f_CloseProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
storeProject (ip,op) arg_projectID = do
  send_storeProject op arg_projectID
  recv_storeProject ip
send_storeProject op arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("storeProject", M_CALL, seqn)
  write_StoreProject_args op (StoreProject_args{f_StoreProject_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_storeProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_StoreProject_result ip
  readMessageEnd ip
  case f_StoreProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
libraries (ip,op) arg_projectID = do
  send_libraries op arg_projectID
  recv_libraries ip
send_libraries op arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("libraries", M_CALL, seqn)
  write_Libraries_args op (Libraries_args{f_Libraries_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_libraries ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Libraries_result ip
  readMessageEnd ip
  case f_Libraries_result_success res of
    Just v -> return v
    Nothing -> do
      case f_Libraries_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "libraries failed: unknown result")
createLibrary (ip,op) arg_library arg_projectID = do
  send_createLibrary op arg_library arg_projectID
  recv_createLibrary ip
send_createLibrary op arg_library arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("createLibrary", M_CALL, seqn)
  write_CreateLibrary_args op (CreateLibrary_args{f_CreateLibrary_args_library=Just arg_library,f_CreateLibrary_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_createLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CreateLibrary_result ip
  readMessageEnd ip
  case f_CreateLibrary_result_success res of
    Just v -> return v
    Nothing -> do
      case f_CreateLibrary_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "createLibrary failed: unknown result")
loadLibrary (ip,op) arg_path arg_projectID = do
  send_loadLibrary op arg_path arg_projectID
  recv_loadLibrary ip
send_loadLibrary op arg_path arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("loadLibrary", M_CALL, seqn)
  write_LoadLibrary_args op (LoadLibrary_args{f_LoadLibrary_args_path=Just arg_path,f_LoadLibrary_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_loadLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_LoadLibrary_result ip
  readMessageEnd ip
  case f_LoadLibrary_result_success res of
    Just v -> return v
    Nothing -> do
      case f_LoadLibrary_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "loadLibrary failed: unknown result")
unloadLibrary (ip,op) arg_libID arg_projectID = do
  send_unloadLibrary op arg_libID arg_projectID
  recv_unloadLibrary ip
send_unloadLibrary op arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("unloadLibrary", M_CALL, seqn)
  write_UnloadLibrary_args op (UnloadLibrary_args{f_UnloadLibrary_args_libID=Just arg_libID,f_UnloadLibrary_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_unloadLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UnloadLibrary_result ip
  readMessageEnd ip
  case f_UnloadLibrary_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
storeLibrary (ip,op) arg_libID arg_projectID = do
  send_storeLibrary op arg_libID arg_projectID
  recv_storeLibrary ip
send_storeLibrary op arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("storeLibrary", M_CALL, seqn)
  write_StoreLibrary_args op (StoreLibrary_args{f_StoreLibrary_args_libID=Just arg_libID,f_StoreLibrary_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_storeLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_StoreLibrary_result ip
  readMessageEnd ip
  case f_StoreLibrary_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
buildLibrary (ip,op) arg_libID arg_projectID = do
  send_buildLibrary op arg_libID arg_projectID
  recv_buildLibrary ip
send_buildLibrary op arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("buildLibrary", M_CALL, seqn)
  write_BuildLibrary_args op (BuildLibrary_args{f_BuildLibrary_args_libID=Just arg_libID,f_BuildLibrary_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_buildLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_BuildLibrary_result ip
  readMessageEnd ip
  case f_BuildLibrary_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
libraryRootDef (ip,op) arg_libID arg_projectID = do
  send_libraryRootDef op arg_libID arg_projectID
  recv_libraryRootDef ip
send_libraryRootDef op arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("libraryRootDef", M_CALL, seqn)
  write_LibraryRootDef_args op (LibraryRootDef_args{f_LibraryRootDef_args_libID=Just arg_libID,f_LibraryRootDef_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_libraryRootDef ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_LibraryRootDef_result ip
  readMessageEnd ip
  case f_LibraryRootDef_result_success res of
    Just v -> return v
    Nothing -> do
      case f_LibraryRootDef_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "libraryRootDef failed: unknown result")
defsGraph (ip,op) arg_libID arg_projectID = do
  send_defsGraph op arg_libID arg_projectID
  recv_defsGraph ip
send_defsGraph op arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("defsGraph", M_CALL, seqn)
  write_DefsGraph_args op (DefsGraph_args{f_DefsGraph_args_libID=Just arg_libID,f_DefsGraph_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_defsGraph ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefsGraph_result ip
  readMessageEnd ip
  case f_DefsGraph_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefsGraph_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "defsGraph failed: unknown result")
defByID (ip,op) arg_defID arg_libID arg_projectID = do
  send_defByID op arg_defID arg_libID arg_projectID
  recv_defByID ip
send_defByID op arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("defByID", M_CALL, seqn)
  write_DefByID_args op (DefByID_args{f_DefByID_args_defID=Just arg_defID,f_DefByID_args_libID=Just arg_libID,f_DefByID_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_defByID ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefByID_result ip
  readMessageEnd ip
  case f_DefByID_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefByID_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "defByID failed: unknown result")
addDefinition (ip,op) arg_definition arg_parentID arg_libID arg_projectID = do
  send_addDefinition op arg_definition arg_parentID arg_libID arg_projectID
  recv_addDefinition ip
send_addDefinition op arg_definition arg_parentID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("addDefinition", M_CALL, seqn)
  write_AddDefinition_args op (AddDefinition_args{f_AddDefinition_args_definition=Just arg_definition,f_AddDefinition_args_parentID=Just arg_parentID,f_AddDefinition_args_libID=Just arg_libID,f_AddDefinition_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_addDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_AddDefinition_result ip
  readMessageEnd ip
  case f_AddDefinition_result_success res of
    Just v -> return v
    Nothing -> do
      case f_AddDefinition_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "addDefinition failed: unknown result")
updateDefinition (ip,op) arg_definition arg_libID arg_projectID = do
  send_updateDefinition op arg_definition arg_libID arg_projectID
  recv_updateDefinition ip
send_updateDefinition op arg_definition arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("updateDefinition", M_CALL, seqn)
  write_UpdateDefinition_args op (UpdateDefinition_args{f_UpdateDefinition_args_definition=Just arg_definition,f_UpdateDefinition_args_libID=Just arg_libID,f_UpdateDefinition_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_updateDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UpdateDefinition_result ip
  readMessageEnd ip
  case f_UpdateDefinition_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
removeDefinition (ip,op) arg_defID arg_libID arg_projectID = do
  send_removeDefinition op arg_defID arg_libID arg_projectID
  recv_removeDefinition ip
send_removeDefinition op arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("removeDefinition", M_CALL, seqn)
  write_RemoveDefinition_args op (RemoveDefinition_args{f_RemoveDefinition_args_defID=Just arg_defID,f_RemoveDefinition_args_libID=Just arg_libID,f_RemoveDefinition_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_removeDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_RemoveDefinition_result ip
  readMessageEnd ip
  case f_RemoveDefinition_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
definitionChildren (ip,op) arg_defID arg_libID arg_projectID = do
  send_definitionChildren op arg_defID arg_libID arg_projectID
  recv_definitionChildren ip
send_definitionChildren op arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("definitionChildren", M_CALL, seqn)
  write_DefinitionChildren_args op (DefinitionChildren_args{f_DefinitionChildren_args_defID=Just arg_defID,f_DefinitionChildren_args_libID=Just arg_libID,f_DefinitionChildren_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_definitionChildren ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefinitionChildren_result ip
  readMessageEnd ip
  case f_DefinitionChildren_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefinitionChildren_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "definitionChildren failed: unknown result")
definitionParent (ip,op) arg_defID arg_libID arg_projectID = do
  send_definitionParent op arg_defID arg_libID arg_projectID
  recv_definitionParent ip
send_definitionParent op arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("definitionParent", M_CALL, seqn)
  write_DefinitionParent_args op (DefinitionParent_args{f_DefinitionParent_args_defID=Just arg_defID,f_DefinitionParent_args_libID=Just arg_libID,f_DefinitionParent_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_definitionParent ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefinitionParent_result ip
  readMessageEnd ip
  case f_DefinitionParent_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefinitionParent_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "definitionParent failed: unknown result")
newTypeModule (ip,op) arg_name = do
  send_newTypeModule op arg_name
  recv_newTypeModule ip
send_newTypeModule op arg_name = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeModule", M_CALL, seqn)
  write_NewTypeModule_args op (NewTypeModule_args{f_NewTypeModule_args_name=Just arg_name})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeModule ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeModule_result ip
  readMessageEnd ip
  case f_NewTypeModule_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeModule_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeModule failed: unknown result")
newTypeClass (ip,op) arg_name arg_typeparams arg_params = do
  send_newTypeClass op arg_name arg_typeparams arg_params
  recv_newTypeClass ip
send_newTypeClass op arg_name arg_typeparams arg_params = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeClass", M_CALL, seqn)
  write_NewTypeClass_args op (NewTypeClass_args{f_NewTypeClass_args_name=Just arg_name,f_NewTypeClass_args_typeparams=Just arg_typeparams,f_NewTypeClass_args_params=Just arg_params})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeClass ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeClass_result ip
  readMessageEnd ip
  case f_NewTypeClass_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeClass_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeClass failed: unknown result")
newTypeFunction (ip,op) arg_name arg_inputs arg_outputs = do
  send_newTypeFunction op arg_name arg_inputs arg_outputs
  recv_newTypeFunction ip
send_newTypeFunction op arg_name arg_inputs arg_outputs = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeFunction", M_CALL, seqn)
  write_NewTypeFunction_args op (NewTypeFunction_args{f_NewTypeFunction_args_name=Just arg_name,f_NewTypeFunction_args_inputs=Just arg_inputs,f_NewTypeFunction_args_outputs=Just arg_outputs})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeFunction ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeFunction_result ip
  readMessageEnd ip
  case f_NewTypeFunction_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeFunction_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeFunction failed: unknown result")
newTypeUdefined (ip,op) = do
  send_newTypeUdefined op
  recv_newTypeUdefined ip
send_newTypeUdefined op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeUdefined", M_CALL, seqn)
  write_NewTypeUdefined_args op (NewTypeUdefined_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeUdefined ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeUdefined_result ip
  readMessageEnd ip
  case f_NewTypeUdefined_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "newTypeUdefined failed: unknown result")
newTypeNamed (ip,op) arg_name arg_type = do
  send_newTypeNamed op arg_name arg_type
  recv_newTypeNamed ip
send_newTypeNamed op arg_name arg_type = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeNamed", M_CALL, seqn)
  write_NewTypeNamed_args op (NewTypeNamed_args{f_NewTypeNamed_args_name=Just arg_name,f_NewTypeNamed_args_type=Just arg_type})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeNamed ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeNamed_result ip
  readMessageEnd ip
  case f_NewTypeNamed_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeNamed_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeNamed failed: unknown result")
newTypeVariable (ip,op) arg_name = do
  send_newTypeVariable op arg_name
  recv_newTypeVariable ip
send_newTypeVariable op arg_name = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeVariable", M_CALL, seqn)
  write_NewTypeVariable_args op (NewTypeVariable_args{f_NewTypeVariable_args_name=Just arg_name})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeVariable ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeVariable_result ip
  readMessageEnd ip
  case f_NewTypeVariable_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeVariable_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeVariable failed: unknown result")
newTypeList (ip,op) arg_type = do
  send_newTypeList op arg_type
  recv_newTypeList ip
send_newTypeList op arg_type = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeList", M_CALL, seqn)
  write_NewTypeList_args op (NewTypeList_args{f_NewTypeList_args_type=Just arg_type})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeList ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeList_result ip
  readMessageEnd ip
  case f_NewTypeList_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeList_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeList failed: unknown result")
newTypeTuple (ip,op) arg_types = do
  send_newTypeTuple op arg_types
  recv_newTypeTuple ip
send_newTypeTuple op arg_types = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeTuple", M_CALL, seqn)
  write_NewTypeTuple_args op (NewTypeTuple_args{f_NewTypeTuple_args_types=Just arg_types})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeTuple ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeTuple_result ip
  readMessageEnd ip
  case f_NewTypeTuple_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeTuple_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeTuple failed: unknown result")
nodesGraph (ip,op) arg_defID arg_libID arg_projectID = do
  send_nodesGraph op arg_defID arg_libID arg_projectID
  recv_nodesGraph ip
send_nodesGraph op arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("nodesGraph", M_CALL, seqn)
  write_NodesGraph_args op (NodesGraph_args{f_NodesGraph_args_defID=Just arg_defID,f_NodesGraph_args_libID=Just arg_libID,f_NodesGraph_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_nodesGraph ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NodesGraph_result ip
  readMessageEnd ip
  case f_NodesGraph_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NodesGraph_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "nodesGraph failed: unknown result")
nodeByID (ip,op) arg_nodeID arg_defID arg_libID arg_projectID = do
  send_nodeByID op arg_nodeID arg_defID arg_libID arg_projectID
  recv_nodeByID ip
send_nodeByID op arg_nodeID arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("nodeByID", M_CALL, seqn)
  write_NodeByID_args op (NodeByID_args{f_NodeByID_args_nodeID=Just arg_nodeID,f_NodeByID_args_defID=Just arg_defID,f_NodeByID_args_libID=Just arg_libID,f_NodeByID_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_nodeByID ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NodeByID_result ip
  readMessageEnd ip
  case f_NodeByID_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NodeByID_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "nodeByID failed: unknown result")
addNode (ip,op) arg_node arg_defID arg_libID arg_projectID = do
  send_addNode op arg_node arg_defID arg_libID arg_projectID
  recv_addNode ip
send_addNode op arg_node arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("addNode", M_CALL, seqn)
  write_AddNode_args op (AddNode_args{f_AddNode_args_node=Just arg_node,f_AddNode_args_defID=Just arg_defID,f_AddNode_args_libID=Just arg_libID,f_AddNode_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_addNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_AddNode_result ip
  readMessageEnd ip
  case f_AddNode_result_success res of
    Just v -> return v
    Nothing -> do
      case f_AddNode_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "addNode failed: unknown result")
updateNode (ip,op) arg_node arg_defID arg_libID arg_projectID = do
  send_updateNode op arg_node arg_defID arg_libID arg_projectID
  recv_updateNode ip
send_updateNode op arg_node arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("updateNode", M_CALL, seqn)
  write_UpdateNode_args op (UpdateNode_args{f_UpdateNode_args_node=Just arg_node,f_UpdateNode_args_defID=Just arg_defID,f_UpdateNode_args_libID=Just arg_libID,f_UpdateNode_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_updateNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UpdateNode_result ip
  readMessageEnd ip
  case f_UpdateNode_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
removeNode (ip,op) arg_nodeID arg_defID arg_libID arg_projectID = do
  send_removeNode op arg_nodeID arg_defID arg_libID arg_projectID
  recv_removeNode ip
send_removeNode op arg_nodeID arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("removeNode", M_CALL, seqn)
  write_RemoveNode_args op (RemoveNode_args{f_RemoveNode_args_nodeID=Just arg_nodeID,f_RemoveNode_args_defID=Just arg_defID,f_RemoveNode_args_libID=Just arg_libID,f_RemoveNode_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_removeNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_RemoveNode_result ip
  readMessageEnd ip
  case f_RemoveNode_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
connect (ip,op) arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID = do
  send_connect op arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID
  recv_connect ip
send_connect op arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("connect", M_CALL, seqn)
  write_Connect_args op (Connect_args{f_Connect_args_srcNodeID=Just arg_srcNodeID,f_Connect_args_srcPort=Just arg_srcPort,f_Connect_args_dstNodeID=Just arg_dstNodeID,f_Connect_args_dstPort=Just arg_dstPort,f_Connect_args_defID=Just arg_defID,f_Connect_args_libID=Just arg_libID,f_Connect_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_connect ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Connect_result ip
  readMessageEnd ip
  case f_Connect_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
disconnect (ip,op) arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID = do
  send_disconnect op arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID
  recv_disconnect ip
send_disconnect op arg_srcNodeID arg_srcPort arg_dstNodeID arg_dstPort arg_defID arg_libID arg_projectID = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("disconnect", M_CALL, seqn)
  write_Disconnect_args op (Disconnect_args{f_Disconnect_args_srcNodeID=Just arg_srcNodeID,f_Disconnect_args_srcPort=Just arg_srcPort,f_Disconnect_args_dstNodeID=Just arg_dstNodeID,f_Disconnect_args_dstPort=Just arg_dstPort,f_Disconnect_args_defID=Just arg_defID,f_Disconnect_args_libID=Just arg_libID,f_Disconnect_args_projectID=Just arg_projectID})
  writeMessageEnd op
  tFlush (getTransport op)
recv_disconnect ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Disconnect_result ip
  readMessageEnd ip
  case f_Disconnect_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
fS_ls (ip,op) arg_path = do
  send_FS_ls op arg_path
  recv_FS_ls ip
send_FS_ls op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_ls", M_CALL, seqn)
  write_FS_ls_args op (FS_ls_args{f_FS_ls_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_ls ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_ls_result ip
  readMessageEnd ip
  case f_FS_ls_result_success res of
    Just v -> return v
    Nothing -> do
      case f_FS_ls_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "FS_ls failed: unknown result")
fS_stat (ip,op) arg_path = do
  send_FS_stat op arg_path
  recv_FS_stat ip
send_FS_stat op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_stat", M_CALL, seqn)
  write_FS_stat_args op (FS_stat_args{f_FS_stat_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_stat ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_stat_result ip
  readMessageEnd ip
  case f_FS_stat_result_success res of
    Just v -> return v
    Nothing -> do
      case f_FS_stat_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "FS_stat failed: unknown result")
fS_mkdir (ip,op) arg_path = do
  send_FS_mkdir op arg_path
  recv_FS_mkdir ip
send_FS_mkdir op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_mkdir", M_CALL, seqn)
  write_FS_mkdir_args op (FS_mkdir_args{f_FS_mkdir_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_mkdir ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_mkdir_result ip
  readMessageEnd ip
  case f_FS_mkdir_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
fS_touch (ip,op) arg_path = do
  send_FS_touch op arg_path
  recv_FS_touch ip
send_FS_touch op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_touch", M_CALL, seqn)
  write_FS_touch_args op (FS_touch_args{f_FS_touch_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_touch ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_touch_result ip
  readMessageEnd ip
  case f_FS_touch_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
fS_rm (ip,op) arg_path = do
  send_FS_rm op arg_path
  recv_FS_rm ip
send_FS_rm op arg_path = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_rm", M_CALL, seqn)
  write_FS_rm_args op (FS_rm_args{f_FS_rm_args_path=Just arg_path})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_rm ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_rm_result ip
  readMessageEnd ip
  case f_FS_rm_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
fS_cp (ip,op) arg_src arg_dst = do
  send_FS_cp op arg_src arg_dst
  recv_FS_cp ip
send_FS_cp op arg_src arg_dst = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_cp", M_CALL, seqn)
  write_FS_cp_args op (FS_cp_args{f_FS_cp_args_src=Just arg_src,f_FS_cp_args_dst=Just arg_dst})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_cp ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_cp_result ip
  readMessageEnd ip
  case f_FS_cp_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
fS_mv (ip,op) arg_src arg_dst = do
  send_FS_mv op arg_src arg_dst
  recv_FS_mv ip
send_FS_mv op arg_src arg_dst = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("FS_mv", M_CALL, seqn)
  write_FS_mv_args op (FS_mv_args{f_FS_mv_args_src=Just arg_src,f_FS_mv_args_dst=Just arg_dst})
  writeMessageEnd op
  tFlush (getTransport op)
recv_FS_mv ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_FS_mv_result ip
  readMessageEnd ip
  case f_FS_mv_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
ping (ip,op) = do
  send_ping op
  recv_ping ip
send_ping op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("ping", M_CALL, seqn)
  write_Ping_args op (Ping_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_ping ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Ping_result ip
  readMessageEnd ip
  return ()
dump (ip,op) = do
  send_dump op
  recv_dump ip
send_dump op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("dump", M_CALL, seqn)
  write_Dump_args op (Dump_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_dump ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Dump_result ip
  readMessageEnd ip
  return ()
