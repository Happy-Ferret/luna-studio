{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch_Client(projects,createProject,openProject,closeProject,storeProject,setActiveProject,libraries,createLibrary,loadLibrary,unloadLibrary,storeLibrary,libraryRootDef,defsGraph,newDefinition,addDefinition,updateDefinition,removeDefinition,definitionChildren,definitionParent,newTypeModule,newTypeClass,newTypeFunction,newTypeUdefined,newTypeNamed,newTypeVariable,newTypeList,newTypeTuple,nodesGraph,addNode,updateNode,removeNode,connect,disconnect,ping) where
import Data.IORef
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()

import qualified Graphview_Types
import qualified Projects_Types
import qualified Attrs_Types
import qualified Defs_Types
import qualified Graph_Types
import qualified Libs_Types
import qualified Types_Types


import Batch_Types
import Batch
seqid = newIORef 0
projects (ip,op) = do
  send_projects op
  recv_projects ip
send_projects op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("projects", M_CALL, seqn)
  write_Projects_args op (Projects_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_projects ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Projects_result ip
  readMessageEnd ip
  case f_Projects_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "projects failed: unknown result")
createProject (ip,op) arg_project = do
  send_createProject op arg_project
  recv_createProject ip
send_createProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("createProject", M_CALL, seqn)
  write_CreateProject_args op (CreateProject_args{f_CreateProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_createProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CreateProject_result ip
  readMessageEnd ip
  case f_CreateProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
openProject (ip,op) arg_project = do
  send_openProject op arg_project
  recv_openProject ip
send_openProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("openProject", M_CALL, seqn)
  write_OpenProject_args op (OpenProject_args{f_OpenProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_openProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_OpenProject_result ip
  readMessageEnd ip
  case f_OpenProject_result_success res of
    Just v -> return v
    Nothing -> do
      case f_OpenProject_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "openProject failed: unknown result")
closeProject (ip,op) arg_project = do
  send_closeProject op arg_project
  recv_closeProject ip
send_closeProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("closeProject", M_CALL, seqn)
  write_CloseProject_args op (CloseProject_args{f_CloseProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_closeProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CloseProject_result ip
  readMessageEnd ip
  case f_CloseProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
storeProject (ip,op) arg_project = do
  send_storeProject op arg_project
  recv_storeProject ip
send_storeProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("storeProject", M_CALL, seqn)
  write_StoreProject_args op (StoreProject_args{f_StoreProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_storeProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_StoreProject_result ip
  readMessageEnd ip
  case f_StoreProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
setActiveProject (ip,op) arg_project = do
  send_setActiveProject op arg_project
  recv_setActiveProject ip
send_setActiveProject op arg_project = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("setActiveProject", M_CALL, seqn)
  write_SetActiveProject_args op (SetActiveProject_args{f_SetActiveProject_args_project=Just arg_project})
  writeMessageEnd op
  tFlush (getTransport op)
recv_setActiveProject ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_SetActiveProject_result ip
  readMessageEnd ip
  case f_SetActiveProject_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
libraries (ip,op) = do
  send_libraries op
  recv_libraries ip
send_libraries op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("libraries", M_CALL, seqn)
  write_Libraries_args op (Libraries_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_libraries ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Libraries_result ip
  readMessageEnd ip
  case f_Libraries_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "libraries failed: unknown result")
createLibrary (ip,op) arg_library = do
  send_createLibrary op arg_library
  recv_createLibrary ip
send_createLibrary op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("createLibrary", M_CALL, seqn)
  write_CreateLibrary_args op (CreateLibrary_args{f_CreateLibrary_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_createLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_CreateLibrary_result ip
  readMessageEnd ip
  case f_CreateLibrary_result_success res of
    Just v -> return v
    Nothing -> do
      case f_CreateLibrary_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "createLibrary failed: unknown result")
loadLibrary (ip,op) arg_library = do
  send_loadLibrary op arg_library
  recv_loadLibrary ip
send_loadLibrary op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("loadLibrary", M_CALL, seqn)
  write_LoadLibrary_args op (LoadLibrary_args{f_LoadLibrary_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_loadLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_LoadLibrary_result ip
  readMessageEnd ip
  case f_LoadLibrary_result_success res of
    Just v -> return v
    Nothing -> do
      case f_LoadLibrary_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "loadLibrary failed: unknown result")
unloadLibrary (ip,op) arg_library = do
  send_unloadLibrary op arg_library
  recv_unloadLibrary ip
send_unloadLibrary op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("unloadLibrary", M_CALL, seqn)
  write_UnloadLibrary_args op (UnloadLibrary_args{f_UnloadLibrary_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_unloadLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UnloadLibrary_result ip
  readMessageEnd ip
  case f_UnloadLibrary_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
storeLibrary (ip,op) arg_library = do
  send_storeLibrary op arg_library
  recv_storeLibrary ip
send_storeLibrary op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("storeLibrary", M_CALL, seqn)
  write_StoreLibrary_args op (StoreLibrary_args{f_StoreLibrary_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_storeLibrary ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_StoreLibrary_result ip
  readMessageEnd ip
  case f_StoreLibrary_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
libraryRootDef (ip,op) arg_library = do
  send_libraryRootDef op arg_library
  recv_libraryRootDef ip
send_libraryRootDef op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("libraryRootDef", M_CALL, seqn)
  write_LibraryRootDef_args op (LibraryRootDef_args{f_LibraryRootDef_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_libraryRootDef ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_LibraryRootDef_result ip
  readMessageEnd ip
  case f_LibraryRootDef_result_success res of
    Just v -> return v
    Nothing -> do
      case f_LibraryRootDef_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "libraryRootDef failed: unknown result")
defsGraph (ip,op) arg_library = do
  send_defsGraph op arg_library
  recv_defsGraph ip
send_defsGraph op arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("defsGraph", M_CALL, seqn)
  write_DefsGraph_args op (DefsGraph_args{f_DefsGraph_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_defsGraph ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefsGraph_result ip
  readMessageEnd ip
  case f_DefsGraph_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "defsGraph failed: unknown result")
newDefinition (ip,op) arg_type arg_imports arg_flags arg_attrs = do
  send_newDefinition op arg_type arg_imports arg_flags arg_attrs
  recv_newDefinition ip
send_newDefinition op arg_type arg_imports arg_flags arg_attrs = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newDefinition", M_CALL, seqn)
  write_NewDefinition_args op (NewDefinition_args{f_NewDefinition_args_type=Just arg_type,f_NewDefinition_args_imports=Just arg_imports,f_NewDefinition_args_flags=Just arg_flags,f_NewDefinition_args_attrs=Just arg_attrs})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewDefinition_result ip
  readMessageEnd ip
  case f_NewDefinition_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "newDefinition failed: unknown result")
addDefinition (ip,op) arg_definition arg_parent arg_library = do
  send_addDefinition op arg_definition arg_parent arg_library
  recv_addDefinition ip
send_addDefinition op arg_definition arg_parent arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("addDefinition", M_CALL, seqn)
  write_AddDefinition_args op (AddDefinition_args{f_AddDefinition_args_definition=Just arg_definition,f_AddDefinition_args_parent=Just arg_parent,f_AddDefinition_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_addDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_AddDefinition_result ip
  readMessageEnd ip
  case f_AddDefinition_result_success res of
    Just v -> return v
    Nothing -> do
      case f_AddDefinition_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "addDefinition failed: unknown result")
updateDefinition (ip,op) arg_definition arg_library = do
  send_updateDefinition op arg_definition arg_library
  recv_updateDefinition ip
send_updateDefinition op arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("updateDefinition", M_CALL, seqn)
  write_UpdateDefinition_args op (UpdateDefinition_args{f_UpdateDefinition_args_definition=Just arg_definition,f_UpdateDefinition_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_updateDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UpdateDefinition_result ip
  readMessageEnd ip
  case f_UpdateDefinition_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
removeDefinition (ip,op) arg_definition arg_library = do
  send_removeDefinition op arg_definition arg_library
  recv_removeDefinition ip
send_removeDefinition op arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("removeDefinition", M_CALL, seqn)
  write_RemoveDefinition_args op (RemoveDefinition_args{f_RemoveDefinition_args_definition=Just arg_definition,f_RemoveDefinition_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_removeDefinition ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_RemoveDefinition_result ip
  readMessageEnd ip
  case f_RemoveDefinition_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
definitionChildren (ip,op) arg_definition arg_library = do
  send_definitionChildren op arg_definition arg_library
  recv_definitionChildren ip
send_definitionChildren op arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("definitionChildren", M_CALL, seqn)
  write_DefinitionChildren_args op (DefinitionChildren_args{f_DefinitionChildren_args_definition=Just arg_definition,f_DefinitionChildren_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_definitionChildren ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefinitionChildren_result ip
  readMessageEnd ip
  case f_DefinitionChildren_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefinitionChildren_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "definitionChildren failed: unknown result")
definitionParent (ip,op) arg_definition arg_library = do
  send_definitionParent op arg_definition arg_library
  recv_definitionParent ip
send_definitionParent op arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("definitionParent", M_CALL, seqn)
  write_DefinitionParent_args op (DefinitionParent_args{f_DefinitionParent_args_definition=Just arg_definition,f_DefinitionParent_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_definitionParent ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_DefinitionParent_result ip
  readMessageEnd ip
  case f_DefinitionParent_result_success res of
    Just v -> return v
    Nothing -> do
      case f_DefinitionParent_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "definitionParent failed: unknown result")
newTypeModule (ip,op) arg_name = do
  send_newTypeModule op arg_name
  recv_newTypeModule ip
send_newTypeModule op arg_name = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeModule", M_CALL, seqn)
  write_NewTypeModule_args op (NewTypeModule_args{f_NewTypeModule_args_name=Just arg_name})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeModule ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeModule_result ip
  readMessageEnd ip
  case f_NewTypeModule_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeModule_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeModule failed: unknown result")
newTypeClass (ip,op) arg_name arg_typeparams arg_params = do
  send_newTypeClass op arg_name arg_typeparams arg_params
  recv_newTypeClass ip
send_newTypeClass op arg_name arg_typeparams arg_params = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeClass", M_CALL, seqn)
  write_NewTypeClass_args op (NewTypeClass_args{f_NewTypeClass_args_name=Just arg_name,f_NewTypeClass_args_typeparams=Just arg_typeparams,f_NewTypeClass_args_params=Just arg_params})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeClass ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeClass_result ip
  readMessageEnd ip
  case f_NewTypeClass_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeClass_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeClass failed: unknown result")
newTypeFunction (ip,op) arg_name arg_inputs arg_outputs = do
  send_newTypeFunction op arg_name arg_inputs arg_outputs
  recv_newTypeFunction ip
send_newTypeFunction op arg_name arg_inputs arg_outputs = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeFunction", M_CALL, seqn)
  write_NewTypeFunction_args op (NewTypeFunction_args{f_NewTypeFunction_args_name=Just arg_name,f_NewTypeFunction_args_inputs=Just arg_inputs,f_NewTypeFunction_args_outputs=Just arg_outputs})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeFunction ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeFunction_result ip
  readMessageEnd ip
  case f_NewTypeFunction_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeFunction_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeFunction failed: unknown result")
newTypeUdefined (ip,op) = do
  send_newTypeUdefined op
  recv_newTypeUdefined ip
send_newTypeUdefined op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeUdefined", M_CALL, seqn)
  write_NewTypeUdefined_args op (NewTypeUdefined_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeUdefined ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeUdefined_result ip
  readMessageEnd ip
  case f_NewTypeUdefined_result_success res of
    Just v -> return v
    Nothing -> do
      throw (AppExn AE_MISSING_RESULT "newTypeUdefined failed: unknown result")
newTypeNamed (ip,op) arg_name arg_type = do
  send_newTypeNamed op arg_name arg_type
  recv_newTypeNamed ip
send_newTypeNamed op arg_name arg_type = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeNamed", M_CALL, seqn)
  write_NewTypeNamed_args op (NewTypeNamed_args{f_NewTypeNamed_args_name=Just arg_name,f_NewTypeNamed_args_type=Just arg_type})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeNamed ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeNamed_result ip
  readMessageEnd ip
  case f_NewTypeNamed_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeNamed_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeNamed failed: unknown result")
newTypeVariable (ip,op) arg_name = do
  send_newTypeVariable op arg_name
  recv_newTypeVariable ip
send_newTypeVariable op arg_name = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeVariable", M_CALL, seqn)
  write_NewTypeVariable_args op (NewTypeVariable_args{f_NewTypeVariable_args_name=Just arg_name})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeVariable ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeVariable_result ip
  readMessageEnd ip
  case f_NewTypeVariable_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeVariable_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeVariable failed: unknown result")
newTypeList (ip,op) arg_type = do
  send_newTypeList op arg_type
  recv_newTypeList ip
send_newTypeList op arg_type = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeList", M_CALL, seqn)
  write_NewTypeList_args op (NewTypeList_args{f_NewTypeList_args_type=Just arg_type})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeList ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeList_result ip
  readMessageEnd ip
  case f_NewTypeList_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeList_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeList failed: unknown result")
newTypeTuple (ip,op) arg_types = do
  send_newTypeTuple op arg_types
  recv_newTypeTuple ip
send_newTypeTuple op arg_types = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("newTypeTuple", M_CALL, seqn)
  write_NewTypeTuple_args op (NewTypeTuple_args{f_NewTypeTuple_args_types=Just arg_types})
  writeMessageEnd op
  tFlush (getTransport op)
recv_newTypeTuple ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NewTypeTuple_result ip
  readMessageEnd ip
  case f_NewTypeTuple_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NewTypeTuple_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "newTypeTuple failed: unknown result")
nodesGraph (ip,op) arg_definition arg_library = do
  send_nodesGraph op arg_definition arg_library
  recv_nodesGraph ip
send_nodesGraph op arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("nodesGraph", M_CALL, seqn)
  write_NodesGraph_args op (NodesGraph_args{f_NodesGraph_args_definition=Just arg_definition,f_NodesGraph_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_nodesGraph ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_NodesGraph_result ip
  readMessageEnd ip
  case f_NodesGraph_result_success res of
    Just v -> return v
    Nothing -> do
      case f_NodesGraph_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "nodesGraph failed: unknown result")
addNode (ip,op) arg_node arg_definition arg_library = do
  send_addNode op arg_node arg_definition arg_library
  recv_addNode ip
send_addNode op arg_node arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("addNode", M_CALL, seqn)
  write_AddNode_args op (AddNode_args{f_AddNode_args_node=Just arg_node,f_AddNode_args_definition=Just arg_definition,f_AddNode_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_addNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_AddNode_result ip
  readMessageEnd ip
  case f_AddNode_result_success res of
    Just v -> return v
    Nothing -> do
      case f_AddNode_result_missingFields res of
        Nothing -> return ()
        Just _v -> throw _v
      throw (AppExn AE_MISSING_RESULT "addNode failed: unknown result")
updateNode (ip,op) arg_node arg_definition arg_library = do
  send_updateNode op arg_node arg_definition arg_library
  recv_updateNode ip
send_updateNode op arg_node arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("updateNode", M_CALL, seqn)
  write_UpdateNode_args op (UpdateNode_args{f_UpdateNode_args_node=Just arg_node,f_UpdateNode_args_definition=Just arg_definition,f_UpdateNode_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_updateNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_UpdateNode_result ip
  readMessageEnd ip
  case f_UpdateNode_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
removeNode (ip,op) arg_node arg_definition arg_library = do
  send_removeNode op arg_node arg_definition arg_library
  recv_removeNode ip
send_removeNode op arg_node arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("removeNode", M_CALL, seqn)
  write_RemoveNode_args op (RemoveNode_args{f_RemoveNode_args_node=Just arg_node,f_RemoveNode_args_definition=Just arg_definition,f_RemoveNode_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_removeNode ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_RemoveNode_result ip
  readMessageEnd ip
  case f_RemoveNode_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
connect (ip,op) arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library = do
  send_connect op arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library
  recv_connect ip
send_connect op arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("connect", M_CALL, seqn)
  write_Connect_args op (Connect_args{f_Connect_args_srcNode=Just arg_srcNode,f_Connect_args_srcPort=Just arg_srcPort,f_Connect_args_dstNode=Just arg_dstNode,f_Connect_args_dstPort=Just arg_dstPort,f_Connect_args_definition=Just arg_definition,f_Connect_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_connect ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Connect_result ip
  readMessageEnd ip
  case f_Connect_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
disconnect (ip,op) arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library = do
  send_disconnect op arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library
  recv_disconnect ip
send_disconnect op arg_srcNode arg_srcPort arg_dstNode arg_dstPort arg_definition arg_library = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("disconnect", M_CALL, seqn)
  write_Disconnect_args op (Disconnect_args{f_Disconnect_args_srcNode=Just arg_srcNode,f_Disconnect_args_srcPort=Just arg_srcPort,f_Disconnect_args_dstNode=Just arg_dstNode,f_Disconnect_args_dstPort=Just arg_dstPort,f_Disconnect_args_definition=Just arg_definition,f_Disconnect_args_library=Just arg_library})
  writeMessageEnd op
  tFlush (getTransport op)
recv_disconnect ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Disconnect_result ip
  readMessageEnd ip
  case f_Disconnect_result_missingFields res of
    Nothing -> return ()
    Just _v -> throw _v
  return ()
ping (ip,op) = do
  send_ping op
  recv_ping ip
send_ping op = do
  seq <- seqid
  seqn <- readIORef seq
  writeMessageBegin op ("ping", M_CALL, seqn)
  write_Ping_args op (Ping_args{})
  writeMessageEnd op
  tFlush (getTransport op)
recv_ping ip = do
  (fname, mtype, rseqid) <- readMessageBegin ip
  if mtype == M_EXCEPTION then do
    x <- readAppExn ip
    readMessageEnd ip
    throw x
    else return ()
  res <- read_Ping_result ip
  readMessageEnd ip
  return ()
