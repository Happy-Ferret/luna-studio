/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Batch_H
#define Batch_H

#include <thrift/TDispatchProcessor.h>
#include "batch_types.h"

namespace flowbox { namespace batch {

class BatchIf {
 public:
  virtual ~BatchIf() {}
  virtual void libraries(std::vector< ::flowbox::batch::Library> & _return) = 0;
  virtual void createLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) = 0;
  virtual void loadLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) = 0;
  virtual void unloadLibrary(const  ::flowbox::batch::Library& library) = 0;
  virtual void storeLibrary(const  ::flowbox::batch::Library& library) = 0;
  virtual void libraryRootDef( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Library& library) = 0;
  virtual void newDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Type& type, const  ::flowbox::batch::Imports& imports, const  ::flowbox::batch::Flags& flags, const  ::flowbox::batch::Attributes& attrs) = 0;
  virtual void addDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition, const  ::flowbox::batch::Definition& parent) = 0;
  virtual void updateDefinition(const  ::flowbox::batch::Definition& definition) = 0;
  virtual void removeDefinition(const  ::flowbox::batch::Definition& definition) = 0;
  virtual void definitionChildren(std::vector< ::flowbox::batch::Definition> & _return, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void definitionParent( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void newTypeModule( ::flowbox::batch::Type& _return, const std::string& name) = 0;
  virtual void newTypeClass( ::flowbox::batch::Type& _return, const std::string& name, const std::vector<std::string> & typeparams, const std::vector< ::flowbox::batch::Type> & params) = 0;
  virtual void newTypeFunction( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& inputs, const  ::flowbox::batch::Type& outputs) = 0;
  virtual void newTypeUdefined( ::flowbox::batch::Type& _return) = 0;
  virtual void newTypeNamed( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& type) = 0;
  virtual void newTypeVariable( ::flowbox::batch::Type& _return, const std::string& name) = 0;
  virtual void newTypeList( ::flowbox::batch::Type& _return, const  ::flowbox::batch::Type& type) = 0;
  virtual void newTypeTuple( ::flowbox::batch::Type& _return, const std::vector< ::flowbox::batch::Type> & types) = 0;
  virtual void graph( ::flowbox::batch::Graph& _return, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void addNode( ::flowbox::batch::Node& _return, const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void updateNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void removeNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void connect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void disconnect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) = 0;
  virtual void ping() = 0;
};

class BatchIfFactory {
 public:
  typedef BatchIf Handler;

  virtual ~BatchIfFactory() {}

  virtual BatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(BatchIf* /* handler */) = 0;
};

class BatchIfSingletonFactory : virtual public BatchIfFactory {
 public:
  BatchIfSingletonFactory(const boost::shared_ptr<BatchIf>& iface) : iface_(iface) {}
  virtual ~BatchIfSingletonFactory() {}

  virtual BatchIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(BatchIf* /* handler */) {}

 protected:
  boost::shared_ptr<BatchIf> iface_;
};

class BatchNull : virtual public BatchIf {
 public:
  virtual ~BatchNull() {}
  void libraries(std::vector< ::flowbox::batch::Library> & /* _return */) {
    return;
  }
  void createLibrary( ::flowbox::batch::Library& /* _return */, const  ::flowbox::batch::Library& /* library */) {
    return;
  }
  void loadLibrary( ::flowbox::batch::Library& /* _return */, const  ::flowbox::batch::Library& /* library */) {
    return;
  }
  void unloadLibrary(const  ::flowbox::batch::Library& /* library */) {
    return;
  }
  void storeLibrary(const  ::flowbox::batch::Library& /* library */) {
    return;
  }
  void libraryRootDef( ::flowbox::batch::Definition& /* _return */, const  ::flowbox::batch::Library& /* library */) {
    return;
  }
  void newDefinition( ::flowbox::batch::Definition& /* _return */, const  ::flowbox::batch::Type& /* type */, const  ::flowbox::batch::Imports& /* imports */, const  ::flowbox::batch::Flags& /* flags */, const  ::flowbox::batch::Attributes& /* attrs */) {
    return;
  }
  void addDefinition( ::flowbox::batch::Definition& /* _return */, const  ::flowbox::batch::Definition& /* definition */, const  ::flowbox::batch::Definition& /* parent */) {
    return;
  }
  void updateDefinition(const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void removeDefinition(const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void definitionChildren(std::vector< ::flowbox::batch::Definition> & /* _return */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void definitionParent( ::flowbox::batch::Definition& /* _return */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void newTypeModule( ::flowbox::batch::Type& /* _return */, const std::string& /* name */) {
    return;
  }
  void newTypeClass( ::flowbox::batch::Type& /* _return */, const std::string& /* name */, const std::vector<std::string> & /* typeparams */, const std::vector< ::flowbox::batch::Type> & /* params */) {
    return;
  }
  void newTypeFunction( ::flowbox::batch::Type& /* _return */, const std::string& /* name */, const  ::flowbox::batch::Type& /* inputs */, const  ::flowbox::batch::Type& /* outputs */) {
    return;
  }
  void newTypeUdefined( ::flowbox::batch::Type& /* _return */) {
    return;
  }
  void newTypeNamed( ::flowbox::batch::Type& /* _return */, const std::string& /* name */, const  ::flowbox::batch::Type& /* type */) {
    return;
  }
  void newTypeVariable( ::flowbox::batch::Type& /* _return */, const std::string& /* name */) {
    return;
  }
  void newTypeList( ::flowbox::batch::Type& /* _return */, const  ::flowbox::batch::Type& /* type */) {
    return;
  }
  void newTypeTuple( ::flowbox::batch::Type& /* _return */, const std::vector< ::flowbox::batch::Type> & /* types */) {
    return;
  }
  void graph( ::flowbox::batch::Graph& /* _return */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void addNode( ::flowbox::batch::Node& /* _return */, const  ::flowbox::batch::Node& /* node */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void updateNode(const  ::flowbox::batch::Node& /* node */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void removeNode(const  ::flowbox::batch::Node& /* node */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void connect(const  ::flowbox::batch::Node& /* srcNode */, const  ::flowbox::batch::PortDescriptor& /* srcPort */, const  ::flowbox::batch::Node& /* dstNode */, const  ::flowbox::batch::PortDescriptor& /* dstPort */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void disconnect(const  ::flowbox::batch::Node& /* srcNode */, const  ::flowbox::batch::PortDescriptor& /* srcPort */, const  ::flowbox::batch::Node& /* dstNode */, const  ::flowbox::batch::PortDescriptor& /* dstPort */, const  ::flowbox::batch::Definition& /* definition */) {
    return;
  }
  void ping() {
    return;
  }
};


class Batch_libraries_args {
 public:

  Batch_libraries_args() {
  }

  virtual ~Batch_libraries_args() throw() {}


  bool operator == (const Batch_libraries_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_libraries_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraries_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_libraries_pargs {
 public:


  virtual ~Batch_libraries_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraries_result__isset {
  _Batch_libraries_result__isset() : success(false) {}
  bool success;
} _Batch_libraries_result__isset;

class Batch_libraries_result {
 public:

  Batch_libraries_result() {
  }

  virtual ~Batch_libraries_result() throw() {}

  std::vector< ::flowbox::batch::Library>  success;

  _Batch_libraries_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::Library> & val) {
    success = val;
  }

  bool operator == (const Batch_libraries_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Batch_libraries_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraries_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraries_presult__isset {
  _Batch_libraries_presult__isset() : success(false) {}
  bool success;
} _Batch_libraries_presult__isset;

class Batch_libraries_presult {
 public:


  virtual ~Batch_libraries_presult() throw() {}

  std::vector< ::flowbox::batch::Library> * success;

  _Batch_libraries_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_createLibrary_args__isset {
  _Batch_createLibrary_args__isset() : library(false) {}
  bool library;
} _Batch_createLibrary_args__isset;

class Batch_createLibrary_args {
 public:

  Batch_createLibrary_args() {
  }

  virtual ~Batch_createLibrary_args() throw() {}

   ::flowbox::batch::Library library;

  _Batch_createLibrary_args__isset __isset;

  void __set_library(const  ::flowbox::batch::Library& val) {
    library = val;
  }

  bool operator == (const Batch_createLibrary_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    return true;
  }
  bool operator != (const Batch_createLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_createLibrary_pargs {
 public:


  virtual ~Batch_createLibrary_pargs() throw() {}

  const  ::flowbox::batch::Library* library;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createLibrary_result__isset {
  _Batch_createLibrary_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createLibrary_result__isset;

class Batch_createLibrary_result {
 public:

  Batch_createLibrary_result() {
  }

  virtual ~Batch_createLibrary_result() throw() {}

   ::flowbox::batch::Library success;
  ArgumentException missingFields;

  _Batch_createLibrary_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Library& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_createLibrary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_createLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createLibrary_presult__isset {
  _Batch_createLibrary_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createLibrary_presult__isset;

class Batch_createLibrary_presult {
 public:


  virtual ~Batch_createLibrary_presult() throw() {}

   ::flowbox::batch::Library* success;
  ArgumentException missingFields;

  _Batch_createLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_loadLibrary_args__isset {
  _Batch_loadLibrary_args__isset() : library(false) {}
  bool library;
} _Batch_loadLibrary_args__isset;

class Batch_loadLibrary_args {
 public:

  Batch_loadLibrary_args() {
  }

  virtual ~Batch_loadLibrary_args() throw() {}

   ::flowbox::batch::Library library;

  _Batch_loadLibrary_args__isset __isset;

  void __set_library(const  ::flowbox::batch::Library& val) {
    library = val;
  }

  bool operator == (const Batch_loadLibrary_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    return true;
  }
  bool operator != (const Batch_loadLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_loadLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_loadLibrary_pargs {
 public:


  virtual ~Batch_loadLibrary_pargs() throw() {}

  const  ::flowbox::batch::Library* library;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_loadLibrary_result__isset {
  _Batch_loadLibrary_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_loadLibrary_result__isset;

class Batch_loadLibrary_result {
 public:

  Batch_loadLibrary_result() {
  }

  virtual ~Batch_loadLibrary_result() throw() {}

   ::flowbox::batch::Library success;
  ArgumentException missingFields;

  _Batch_loadLibrary_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Library& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_loadLibrary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_loadLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_loadLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_loadLibrary_presult__isset {
  _Batch_loadLibrary_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_loadLibrary_presult__isset;

class Batch_loadLibrary_presult {
 public:


  virtual ~Batch_loadLibrary_presult() throw() {}

   ::flowbox::batch::Library* success;
  ArgumentException missingFields;

  _Batch_loadLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_unloadLibrary_args__isset {
  _Batch_unloadLibrary_args__isset() : library(false) {}
  bool library;
} _Batch_unloadLibrary_args__isset;

class Batch_unloadLibrary_args {
 public:

  Batch_unloadLibrary_args() {
  }

  virtual ~Batch_unloadLibrary_args() throw() {}

   ::flowbox::batch::Library library;

  _Batch_unloadLibrary_args__isset __isset;

  void __set_library(const  ::flowbox::batch::Library& val) {
    library = val;
  }

  bool operator == (const Batch_unloadLibrary_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    return true;
  }
  bool operator != (const Batch_unloadLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_unloadLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_unloadLibrary_pargs {
 public:


  virtual ~Batch_unloadLibrary_pargs() throw() {}

  const  ::flowbox::batch::Library* library;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_unloadLibrary_result__isset {
  _Batch_unloadLibrary_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_unloadLibrary_result__isset;

class Batch_unloadLibrary_result {
 public:

  Batch_unloadLibrary_result() {
  }

  virtual ~Batch_unloadLibrary_result() throw() {}

  ArgumentException missingFields;

  _Batch_unloadLibrary_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_unloadLibrary_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_unloadLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_unloadLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_unloadLibrary_presult__isset {
  _Batch_unloadLibrary_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_unloadLibrary_presult__isset;

class Batch_unloadLibrary_presult {
 public:


  virtual ~Batch_unloadLibrary_presult() throw() {}

  ArgumentException missingFields;

  _Batch_unloadLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_storeLibrary_args__isset {
  _Batch_storeLibrary_args__isset() : library(false) {}
  bool library;
} _Batch_storeLibrary_args__isset;

class Batch_storeLibrary_args {
 public:

  Batch_storeLibrary_args() {
  }

  virtual ~Batch_storeLibrary_args() throw() {}

   ::flowbox::batch::Library library;

  _Batch_storeLibrary_args__isset __isset;

  void __set_library(const  ::flowbox::batch::Library& val) {
    library = val;
  }

  bool operator == (const Batch_storeLibrary_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    return true;
  }
  bool operator != (const Batch_storeLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_storeLibrary_pargs {
 public:


  virtual ~Batch_storeLibrary_pargs() throw() {}

  const  ::flowbox::batch::Library* library;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeLibrary_result__isset {
  _Batch_storeLibrary_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeLibrary_result__isset;

class Batch_storeLibrary_result {
 public:

  Batch_storeLibrary_result() {
  }

  virtual ~Batch_storeLibrary_result() throw() {}

  ArgumentException missingFields;

  _Batch_storeLibrary_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_storeLibrary_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_storeLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeLibrary_presult__isset {
  _Batch_storeLibrary_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeLibrary_presult__isset;

class Batch_storeLibrary_presult {
 public:


  virtual ~Batch_storeLibrary_presult() throw() {}

  ArgumentException missingFields;

  _Batch_storeLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_libraryRootDef_args__isset {
  _Batch_libraryRootDef_args__isset() : library(false) {}
  bool library;
} _Batch_libraryRootDef_args__isset;

class Batch_libraryRootDef_args {
 public:

  Batch_libraryRootDef_args() {
  }

  virtual ~Batch_libraryRootDef_args() throw() {}

   ::flowbox::batch::Library library;

  _Batch_libraryRootDef_args__isset __isset;

  void __set_library(const  ::flowbox::batch::Library& val) {
    library = val;
  }

  bool operator == (const Batch_libraryRootDef_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryRootDef_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryRootDef_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_libraryRootDef_pargs {
 public:


  virtual ~Batch_libraryRootDef_pargs() throw() {}

  const  ::flowbox::batch::Library* library;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryRootDef_result__isset {
  _Batch_libraryRootDef_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryRootDef_result__isset;

class Batch_libraryRootDef_result {
 public:

  Batch_libraryRootDef_result() {
  }

  virtual ~Batch_libraryRootDef_result() throw() {}

   ::flowbox::batch::Definition success;
  ArgumentException missingFields;

  _Batch_libraryRootDef_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_libraryRootDef_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryRootDef_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryRootDef_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryRootDef_presult__isset {
  _Batch_libraryRootDef_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryRootDef_presult__isset;

class Batch_libraryRootDef_presult {
 public:


  virtual ~Batch_libraryRootDef_presult() throw() {}

   ::flowbox::batch::Definition* success;
  ArgumentException missingFields;

  _Batch_libraryRootDef_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newDefinition_args__isset {
  _Batch_newDefinition_args__isset() : type(false), imports(false), flags(false), attrs(false) {}
  bool type;
  bool imports;
  bool flags;
  bool attrs;
} _Batch_newDefinition_args__isset;

class Batch_newDefinition_args {
 public:

  Batch_newDefinition_args() {
  }

  virtual ~Batch_newDefinition_args() throw() {}

   ::flowbox::batch::Type type;
   ::flowbox::batch::Imports imports;
   ::flowbox::batch::Flags flags;
   ::flowbox::batch::Attributes attrs;

  _Batch_newDefinition_args__isset __isset;

  void __set_type(const  ::flowbox::batch::Type& val) {
    type = val;
  }

  void __set_imports(const  ::flowbox::batch::Imports& val) {
    imports = val;
  }

  void __set_flags(const  ::flowbox::batch::Flags& val) {
    flags = val;
  }

  void __set_attrs(const  ::flowbox::batch::Attributes& val) {
    attrs = val;
  }

  bool operator == (const Batch_newDefinition_args & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(imports == rhs.imports))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(attrs == rhs.attrs))
      return false;
    return true;
  }
  bool operator != (const Batch_newDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newDefinition_pargs {
 public:


  virtual ~Batch_newDefinition_pargs() throw() {}

  const  ::flowbox::batch::Type* type;
  const  ::flowbox::batch::Imports* imports;
  const  ::flowbox::batch::Flags* flags;
  const  ::flowbox::batch::Attributes* attrs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newDefinition_result__isset {
  _Batch_newDefinition_result__isset() : success(false) {}
  bool success;
} _Batch_newDefinition_result__isset;

class Batch_newDefinition_result {
 public:

  Batch_newDefinition_result() {
  }

  virtual ~Batch_newDefinition_result() throw() {}

   ::flowbox::batch::Definition success;

  _Batch_newDefinition_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Definition& val) {
    success = val;
  }

  bool operator == (const Batch_newDefinition_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Batch_newDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newDefinition_presult__isset {
  _Batch_newDefinition_presult__isset() : success(false) {}
  bool success;
} _Batch_newDefinition_presult__isset;

class Batch_newDefinition_presult {
 public:


  virtual ~Batch_newDefinition_presult() throw() {}

   ::flowbox::batch::Definition* success;

  _Batch_newDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_addDefinition_args__isset {
  _Batch_addDefinition_args__isset() : definition(false), parent(false) {}
  bool definition;
  bool parent;
} _Batch_addDefinition_args__isset;

class Batch_addDefinition_args {
 public:

  Batch_addDefinition_args() {
  }

  virtual ~Batch_addDefinition_args() throw() {}

   ::flowbox::batch::Definition definition;
   ::flowbox::batch::Definition parent;

  _Batch_addDefinition_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  void __set_parent(const  ::flowbox::batch::Definition& val) {
    parent = val;
  }

  bool operator == (const Batch_addDefinition_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    if (!(parent == rhs.parent))
      return false;
    return true;
  }
  bool operator != (const Batch_addDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_addDefinition_pargs {
 public:


  virtual ~Batch_addDefinition_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;
  const  ::flowbox::batch::Definition* parent;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addDefinition_result__isset {
  _Batch_addDefinition_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addDefinition_result__isset;

class Batch_addDefinition_result {
 public:

  Batch_addDefinition_result() {
  }

  virtual ~Batch_addDefinition_result() throw() {}

   ::flowbox::batch::Definition success;
  ArgumentException missingFields;

  _Batch_addDefinition_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_addDefinition_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_addDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addDefinition_presult__isset {
  _Batch_addDefinition_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addDefinition_presult__isset;

class Batch_addDefinition_presult {
 public:


  virtual ~Batch_addDefinition_presult() throw() {}

   ::flowbox::batch::Definition* success;
  ArgumentException missingFields;

  _Batch_addDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_updateDefinition_args__isset {
  _Batch_updateDefinition_args__isset() : definition(false) {}
  bool definition;
} _Batch_updateDefinition_args__isset;

class Batch_updateDefinition_args {
 public:

  Batch_updateDefinition_args() {
  }

  virtual ~Batch_updateDefinition_args() throw() {}

   ::flowbox::batch::Definition definition;

  _Batch_updateDefinition_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_updateDefinition_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_updateDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_updateDefinition_pargs {
 public:


  virtual ~Batch_updateDefinition_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateDefinition_result__isset {
  _Batch_updateDefinition_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateDefinition_result__isset;

class Batch_updateDefinition_result {
 public:

  Batch_updateDefinition_result() {
  }

  virtual ~Batch_updateDefinition_result() throw() {}

  ArgumentException missingFields;

  _Batch_updateDefinition_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_updateDefinition_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_updateDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateDefinition_presult__isset {
  _Batch_updateDefinition_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateDefinition_presult__isset;

class Batch_updateDefinition_presult {
 public:


  virtual ~Batch_updateDefinition_presult() throw() {}

  ArgumentException missingFields;

  _Batch_updateDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_removeDefinition_args__isset {
  _Batch_removeDefinition_args__isset() : definition(false) {}
  bool definition;
} _Batch_removeDefinition_args__isset;

class Batch_removeDefinition_args {
 public:

  Batch_removeDefinition_args() {
  }

  virtual ~Batch_removeDefinition_args() throw() {}

   ::flowbox::batch::Definition definition;

  _Batch_removeDefinition_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_removeDefinition_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_removeDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_removeDefinition_pargs {
 public:


  virtual ~Batch_removeDefinition_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeDefinition_result__isset {
  _Batch_removeDefinition_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeDefinition_result__isset;

class Batch_removeDefinition_result {
 public:

  Batch_removeDefinition_result() {
  }

  virtual ~Batch_removeDefinition_result() throw() {}

  ArgumentException missingFields;

  _Batch_removeDefinition_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_removeDefinition_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_removeDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeDefinition_presult__isset {
  _Batch_removeDefinition_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeDefinition_presult__isset;

class Batch_removeDefinition_presult {
 public:


  virtual ~Batch_removeDefinition_presult() throw() {}

  ArgumentException missingFields;

  _Batch_removeDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_definitionChildren_args__isset {
  _Batch_definitionChildren_args__isset() : definition(false) {}
  bool definition;
} _Batch_definitionChildren_args__isset;

class Batch_definitionChildren_args {
 public:

  Batch_definitionChildren_args() {
  }

  virtual ~Batch_definitionChildren_args() throw() {}

   ::flowbox::batch::Definition definition;

  _Batch_definitionChildren_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_definitionChildren_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionChildren_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionChildren_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_definitionChildren_pargs {
 public:


  virtual ~Batch_definitionChildren_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionChildren_result__isset {
  _Batch_definitionChildren_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionChildren_result__isset;

class Batch_definitionChildren_result {
 public:

  Batch_definitionChildren_result() {
  }

  virtual ~Batch_definitionChildren_result() throw() {}

  std::vector< ::flowbox::batch::Definition>  success;
  ArgumentException missingFields;

  _Batch_definitionChildren_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::Definition> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_definitionChildren_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionChildren_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionChildren_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionChildren_presult__isset {
  _Batch_definitionChildren_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionChildren_presult__isset;

class Batch_definitionChildren_presult {
 public:


  virtual ~Batch_definitionChildren_presult() throw() {}

  std::vector< ::flowbox::batch::Definition> * success;
  ArgumentException missingFields;

  _Batch_definitionChildren_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_definitionParent_args__isset {
  _Batch_definitionParent_args__isset() : definition(false) {}
  bool definition;
} _Batch_definitionParent_args__isset;

class Batch_definitionParent_args {
 public:

  Batch_definitionParent_args() {
  }

  virtual ~Batch_definitionParent_args() throw() {}

   ::flowbox::batch::Definition definition;

  _Batch_definitionParent_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_definitionParent_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionParent_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionParent_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_definitionParent_pargs {
 public:


  virtual ~Batch_definitionParent_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionParent_result__isset {
  _Batch_definitionParent_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionParent_result__isset;

class Batch_definitionParent_result {
 public:

  Batch_definitionParent_result() {
  }

  virtual ~Batch_definitionParent_result() throw() {}

   ::flowbox::batch::Definition success;
  ArgumentException missingFields;

  _Batch_definitionParent_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_definitionParent_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionParent_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionParent_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionParent_presult__isset {
  _Batch_definitionParent_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionParent_presult__isset;

class Batch_definitionParent_presult {
 public:


  virtual ~Batch_definitionParent_presult() throw() {}

   ::flowbox::batch::Definition* success;
  ArgumentException missingFields;

  _Batch_definitionParent_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeModule_args__isset {
  _Batch_newTypeModule_args__isset() : name(false) {}
  bool name;
} _Batch_newTypeModule_args__isset;

class Batch_newTypeModule_args {
 public:

  Batch_newTypeModule_args() : name() {
  }

  virtual ~Batch_newTypeModule_args() throw() {}

  std::string name;

  _Batch_newTypeModule_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const Batch_newTypeModule_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeModule_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeModule_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeModule_pargs {
 public:


  virtual ~Batch_newTypeModule_pargs() throw() {}

  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeModule_result__isset {
  _Batch_newTypeModule_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeModule_result__isset;

class Batch_newTypeModule_result {
 public:

  Batch_newTypeModule_result() {
  }

  virtual ~Batch_newTypeModule_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeModule_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeModule_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeModule_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeModule_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeModule_presult__isset {
  _Batch_newTypeModule_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeModule_presult__isset;

class Batch_newTypeModule_presult {
 public:


  virtual ~Batch_newTypeModule_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeModule_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeClass_args__isset {
  _Batch_newTypeClass_args__isset() : name(false), typeparams(false), params(false) {}
  bool name;
  bool typeparams;
  bool params;
} _Batch_newTypeClass_args__isset;

class Batch_newTypeClass_args {
 public:

  Batch_newTypeClass_args() : name() {
  }

  virtual ~Batch_newTypeClass_args() throw() {}

  std::string name;
  std::vector<std::string>  typeparams;
  std::vector< ::flowbox::batch::Type>  params;

  _Batch_newTypeClass_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_typeparams(const std::vector<std::string> & val) {
    typeparams = val;
  }

  void __set_params(const std::vector< ::flowbox::batch::Type> & val) {
    params = val;
  }

  bool operator == (const Batch_newTypeClass_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(typeparams == rhs.typeparams))
      return false;
    if (!(params == rhs.params))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeClass_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeClass_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeClass_pargs {
 public:


  virtual ~Batch_newTypeClass_pargs() throw() {}

  const std::string* name;
  const std::vector<std::string> * typeparams;
  const std::vector< ::flowbox::batch::Type> * params;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeClass_result__isset {
  _Batch_newTypeClass_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeClass_result__isset;

class Batch_newTypeClass_result {
 public:

  Batch_newTypeClass_result() {
  }

  virtual ~Batch_newTypeClass_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeClass_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeClass_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeClass_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeClass_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeClass_presult__isset {
  _Batch_newTypeClass_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeClass_presult__isset;

class Batch_newTypeClass_presult {
 public:


  virtual ~Batch_newTypeClass_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeClass_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeFunction_args__isset {
  _Batch_newTypeFunction_args__isset() : name(false), inputs(false), outputs(false) {}
  bool name;
  bool inputs;
  bool outputs;
} _Batch_newTypeFunction_args__isset;

class Batch_newTypeFunction_args {
 public:

  Batch_newTypeFunction_args() : name() {
  }

  virtual ~Batch_newTypeFunction_args() throw() {}

  std::string name;
   ::flowbox::batch::Type inputs;
   ::flowbox::batch::Type outputs;

  _Batch_newTypeFunction_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_inputs(const  ::flowbox::batch::Type& val) {
    inputs = val;
  }

  void __set_outputs(const  ::flowbox::batch::Type& val) {
    outputs = val;
  }

  bool operator == (const Batch_newTypeFunction_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(inputs == rhs.inputs))
      return false;
    if (!(outputs == rhs.outputs))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeFunction_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeFunction_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeFunction_pargs {
 public:


  virtual ~Batch_newTypeFunction_pargs() throw() {}

  const std::string* name;
  const  ::flowbox::batch::Type* inputs;
  const  ::flowbox::batch::Type* outputs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeFunction_result__isset {
  _Batch_newTypeFunction_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeFunction_result__isset;

class Batch_newTypeFunction_result {
 public:

  Batch_newTypeFunction_result() {
  }

  virtual ~Batch_newTypeFunction_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeFunction_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeFunction_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeFunction_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeFunction_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeFunction_presult__isset {
  _Batch_newTypeFunction_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeFunction_presult__isset;

class Batch_newTypeFunction_presult {
 public:


  virtual ~Batch_newTypeFunction_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeFunction_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_newTypeUdefined_args {
 public:

  Batch_newTypeUdefined_args() {
  }

  virtual ~Batch_newTypeUdefined_args() throw() {}


  bool operator == (const Batch_newTypeUdefined_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_newTypeUdefined_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeUdefined_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeUdefined_pargs {
 public:


  virtual ~Batch_newTypeUdefined_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeUdefined_result__isset {
  _Batch_newTypeUdefined_result__isset() : success(false) {}
  bool success;
} _Batch_newTypeUdefined_result__isset;

class Batch_newTypeUdefined_result {
 public:

  Batch_newTypeUdefined_result() {
  }

  virtual ~Batch_newTypeUdefined_result() throw() {}

   ::flowbox::batch::Type success;

  _Batch_newTypeUdefined_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  bool operator == (const Batch_newTypeUdefined_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeUdefined_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeUdefined_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeUdefined_presult__isset {
  _Batch_newTypeUdefined_presult__isset() : success(false) {}
  bool success;
} _Batch_newTypeUdefined_presult__isset;

class Batch_newTypeUdefined_presult {
 public:


  virtual ~Batch_newTypeUdefined_presult() throw() {}

   ::flowbox::batch::Type* success;

  _Batch_newTypeUdefined_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeNamed_args__isset {
  _Batch_newTypeNamed_args__isset() : name(false), type(false) {}
  bool name;
  bool type;
} _Batch_newTypeNamed_args__isset;

class Batch_newTypeNamed_args {
 public:

  Batch_newTypeNamed_args() : name() {
  }

  virtual ~Batch_newTypeNamed_args() throw() {}

  std::string name;
   ::flowbox::batch::Type type;

  _Batch_newTypeNamed_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const  ::flowbox::batch::Type& val) {
    type = val;
  }

  bool operator == (const Batch_newTypeNamed_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeNamed_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeNamed_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeNamed_pargs {
 public:


  virtual ~Batch_newTypeNamed_pargs() throw() {}

  const std::string* name;
  const  ::flowbox::batch::Type* type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeNamed_result__isset {
  _Batch_newTypeNamed_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeNamed_result__isset;

class Batch_newTypeNamed_result {
 public:

  Batch_newTypeNamed_result() {
  }

  virtual ~Batch_newTypeNamed_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeNamed_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeNamed_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeNamed_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeNamed_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeNamed_presult__isset {
  _Batch_newTypeNamed_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeNamed_presult__isset;

class Batch_newTypeNamed_presult {
 public:


  virtual ~Batch_newTypeNamed_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeNamed_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeVariable_args__isset {
  _Batch_newTypeVariable_args__isset() : name(false) {}
  bool name;
} _Batch_newTypeVariable_args__isset;

class Batch_newTypeVariable_args {
 public:

  Batch_newTypeVariable_args() : name() {
  }

  virtual ~Batch_newTypeVariable_args() throw() {}

  std::string name;

  _Batch_newTypeVariable_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const Batch_newTypeVariable_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeVariable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeVariable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeVariable_pargs {
 public:


  virtual ~Batch_newTypeVariable_pargs() throw() {}

  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeVariable_result__isset {
  _Batch_newTypeVariable_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeVariable_result__isset;

class Batch_newTypeVariable_result {
 public:

  Batch_newTypeVariable_result() {
  }

  virtual ~Batch_newTypeVariable_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeVariable_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeVariable_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeVariable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeVariable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeVariable_presult__isset {
  _Batch_newTypeVariable_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeVariable_presult__isset;

class Batch_newTypeVariable_presult {
 public:


  virtual ~Batch_newTypeVariable_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeVariable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeList_args__isset {
  _Batch_newTypeList_args__isset() : type(false) {}
  bool type;
} _Batch_newTypeList_args__isset;

class Batch_newTypeList_args {
 public:

  Batch_newTypeList_args() {
  }

  virtual ~Batch_newTypeList_args() throw() {}

   ::flowbox::batch::Type type;

  _Batch_newTypeList_args__isset __isset;

  void __set_type(const  ::flowbox::batch::Type& val) {
    type = val;
  }

  bool operator == (const Batch_newTypeList_args & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeList_pargs {
 public:


  virtual ~Batch_newTypeList_pargs() throw() {}

  const  ::flowbox::batch::Type* type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeList_result__isset {
  _Batch_newTypeList_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeList_result__isset;

class Batch_newTypeList_result {
 public:

  Batch_newTypeList_result() {
  }

  virtual ~Batch_newTypeList_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeList_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeList_presult__isset {
  _Batch_newTypeList_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeList_presult__isset;

class Batch_newTypeList_presult {
 public:


  virtual ~Batch_newTypeList_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeTuple_args__isset {
  _Batch_newTypeTuple_args__isset() : types(false) {}
  bool types;
} _Batch_newTypeTuple_args__isset;

class Batch_newTypeTuple_args {
 public:

  Batch_newTypeTuple_args() {
  }

  virtual ~Batch_newTypeTuple_args() throw() {}

  std::vector< ::flowbox::batch::Type>  types;

  _Batch_newTypeTuple_args__isset __isset;

  void __set_types(const std::vector< ::flowbox::batch::Type> & val) {
    types = val;
  }

  bool operator == (const Batch_newTypeTuple_args & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeTuple_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeTuple_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeTuple_pargs {
 public:


  virtual ~Batch_newTypeTuple_pargs() throw() {}

  const std::vector< ::flowbox::batch::Type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeTuple_result__isset {
  _Batch_newTypeTuple_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeTuple_result__isset;

class Batch_newTypeTuple_result {
 public:

  Batch_newTypeTuple_result() {
  }

  virtual ~Batch_newTypeTuple_result() throw() {}

   ::flowbox::batch::Type success;
  ArgumentException missingFields;

  _Batch_newTypeTuple_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeTuple_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeTuple_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeTuple_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeTuple_presult__isset {
  _Batch_newTypeTuple_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeTuple_presult__isset;

class Batch_newTypeTuple_presult {
 public:


  virtual ~Batch_newTypeTuple_presult() throw() {}

   ::flowbox::batch::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeTuple_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_graph_args__isset {
  _Batch_graph_args__isset() : definition(false) {}
  bool definition;
} _Batch_graph_args__isset;

class Batch_graph_args {
 public:

  Batch_graph_args() {
  }

  virtual ~Batch_graph_args() throw() {}

   ::flowbox::batch::Definition definition;

  _Batch_graph_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_graph_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_graph_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_graph_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_graph_pargs {
 public:


  virtual ~Batch_graph_pargs() throw() {}

  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_graph_result__isset {
  _Batch_graph_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_graph_result__isset;

class Batch_graph_result {
 public:

  Batch_graph_result() {
  }

  virtual ~Batch_graph_result() throw() {}

   ::flowbox::batch::Graph success;
  ArgumentException missingFields;

  _Batch_graph_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Graph& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_graph_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_graph_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_graph_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_graph_presult__isset {
  _Batch_graph_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_graph_presult__isset;

class Batch_graph_presult {
 public:


  virtual ~Batch_graph_presult() throw() {}

   ::flowbox::batch::Graph* success;
  ArgumentException missingFields;

  _Batch_graph_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_addNode_args__isset {
  _Batch_addNode_args__isset() : node(false), definition(false) {}
  bool node;
  bool definition;
} _Batch_addNode_args__isset;

class Batch_addNode_args {
 public:

  Batch_addNode_args() {
  }

  virtual ~Batch_addNode_args() throw() {}

   ::flowbox::batch::Node node;
   ::flowbox::batch::Definition definition;

  _Batch_addNode_args__isset __isset;

  void __set_node(const  ::flowbox::batch::Node& val) {
    node = val;
  }

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_addNode_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_addNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_addNode_pargs {
 public:


  virtual ~Batch_addNode_pargs() throw() {}

  const  ::flowbox::batch::Node* node;
  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addNode_result__isset {
  _Batch_addNode_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addNode_result__isset;

class Batch_addNode_result {
 public:

  Batch_addNode_result() {
  }

  virtual ~Batch_addNode_result() throw() {}

   ::flowbox::batch::Node success;
  ArgumentException missingFields;

  _Batch_addNode_result__isset __isset;

  void __set_success(const  ::flowbox::batch::Node& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_addNode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_addNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addNode_presult__isset {
  _Batch_addNode_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addNode_presult__isset;

class Batch_addNode_presult {
 public:


  virtual ~Batch_addNode_presult() throw() {}

   ::flowbox::batch::Node* success;
  ArgumentException missingFields;

  _Batch_addNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_updateNode_args__isset {
  _Batch_updateNode_args__isset() : node(false), definition(false) {}
  bool node;
  bool definition;
} _Batch_updateNode_args__isset;

class Batch_updateNode_args {
 public:

  Batch_updateNode_args() {
  }

  virtual ~Batch_updateNode_args() throw() {}

   ::flowbox::batch::Node node;
   ::flowbox::batch::Definition definition;

  _Batch_updateNode_args__isset __isset;

  void __set_node(const  ::flowbox::batch::Node& val) {
    node = val;
  }

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_updateNode_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_updateNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_updateNode_pargs {
 public:


  virtual ~Batch_updateNode_pargs() throw() {}

  const  ::flowbox::batch::Node* node;
  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateNode_result__isset {
  _Batch_updateNode_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateNode_result__isset;

class Batch_updateNode_result {
 public:

  Batch_updateNode_result() {
  }

  virtual ~Batch_updateNode_result() throw() {}

  ArgumentException missingFields;

  _Batch_updateNode_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_updateNode_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_updateNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateNode_presult__isset {
  _Batch_updateNode_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateNode_presult__isset;

class Batch_updateNode_presult {
 public:


  virtual ~Batch_updateNode_presult() throw() {}

  ArgumentException missingFields;

  _Batch_updateNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_removeNode_args__isset {
  _Batch_removeNode_args__isset() : node(false), definition(false) {}
  bool node;
  bool definition;
} _Batch_removeNode_args__isset;

class Batch_removeNode_args {
 public:

  Batch_removeNode_args() {
  }

  virtual ~Batch_removeNode_args() throw() {}

   ::flowbox::batch::Node node;
   ::flowbox::batch::Definition definition;

  _Batch_removeNode_args__isset __isset;

  void __set_node(const  ::flowbox::batch::Node& val) {
    node = val;
  }

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_removeNode_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_removeNode_pargs {
 public:


  virtual ~Batch_removeNode_pargs() throw() {}

  const  ::flowbox::batch::Node* node;
  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNode_result__isset {
  _Batch_removeNode_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNode_result__isset;

class Batch_removeNode_result {
 public:

  Batch_removeNode_result() {
  }

  virtual ~Batch_removeNode_result() throw() {}

  ArgumentException missingFields;

  _Batch_removeNode_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_removeNode_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNode_presult__isset {
  _Batch_removeNode_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNode_presult__isset;

class Batch_removeNode_presult {
 public:


  virtual ~Batch_removeNode_presult() throw() {}

  ArgumentException missingFields;

  _Batch_removeNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_connect_args__isset {
  _Batch_connect_args__isset() : srcNode(false), srcPort(false), dstNode(false), dstPort(false), definition(false) {}
  bool srcNode;
  bool srcPort;
  bool dstNode;
  bool dstPort;
  bool definition;
} _Batch_connect_args__isset;

class Batch_connect_args {
 public:

  Batch_connect_args() {
  }

  virtual ~Batch_connect_args() throw() {}

   ::flowbox::batch::Node srcNode;
   ::flowbox::batch::PortDescriptor srcPort;
   ::flowbox::batch::Node dstNode;
   ::flowbox::batch::PortDescriptor dstPort;
   ::flowbox::batch::Definition definition;

  _Batch_connect_args__isset __isset;

  void __set_srcNode(const  ::flowbox::batch::Node& val) {
    srcNode = val;
  }

  void __set_srcPort(const  ::flowbox::batch::PortDescriptor& val) {
    srcPort = val;
  }

  void __set_dstNode(const  ::flowbox::batch::Node& val) {
    dstNode = val;
  }

  void __set_dstPort(const  ::flowbox::batch::PortDescriptor& val) {
    dstPort = val;
  }

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_connect_args & rhs) const
  {
    if (!(srcNode == rhs.srcNode))
      return false;
    if (!(srcPort == rhs.srcPort))
      return false;
    if (!(dstNode == rhs.dstNode))
      return false;
    if (!(dstPort == rhs.dstPort))
      return false;
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_connect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_connect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_connect_pargs {
 public:


  virtual ~Batch_connect_pargs() throw() {}

  const  ::flowbox::batch::Node* srcNode;
  const  ::flowbox::batch::PortDescriptor* srcPort;
  const  ::flowbox::batch::Node* dstNode;
  const  ::flowbox::batch::PortDescriptor* dstPort;
  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_connect_result__isset {
  _Batch_connect_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_connect_result__isset;

class Batch_connect_result {
 public:

  Batch_connect_result() {
  }

  virtual ~Batch_connect_result() throw() {}

  ArgumentException missingFields;

  _Batch_connect_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_connect_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_connect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_connect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_connect_presult__isset {
  _Batch_connect_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_connect_presult__isset;

class Batch_connect_presult {
 public:


  virtual ~Batch_connect_presult() throw() {}

  ArgumentException missingFields;

  _Batch_connect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_disconnect_args__isset {
  _Batch_disconnect_args__isset() : srcNode(false), srcPort(false), dstNode(false), dstPort(false), definition(false) {}
  bool srcNode;
  bool srcPort;
  bool dstNode;
  bool dstPort;
  bool definition;
} _Batch_disconnect_args__isset;

class Batch_disconnect_args {
 public:

  Batch_disconnect_args() {
  }

  virtual ~Batch_disconnect_args() throw() {}

   ::flowbox::batch::Node srcNode;
   ::flowbox::batch::PortDescriptor srcPort;
   ::flowbox::batch::Node dstNode;
   ::flowbox::batch::PortDescriptor dstPort;
   ::flowbox::batch::Definition definition;

  _Batch_disconnect_args__isset __isset;

  void __set_srcNode(const  ::flowbox::batch::Node& val) {
    srcNode = val;
  }

  void __set_srcPort(const  ::flowbox::batch::PortDescriptor& val) {
    srcPort = val;
  }

  void __set_dstNode(const  ::flowbox::batch::Node& val) {
    dstNode = val;
  }

  void __set_dstPort(const  ::flowbox::batch::PortDescriptor& val) {
    dstPort = val;
  }

  void __set_definition(const  ::flowbox::batch::Definition& val) {
    definition = val;
  }

  bool operator == (const Batch_disconnect_args & rhs) const
  {
    if (!(srcNode == rhs.srcNode))
      return false;
    if (!(srcPort == rhs.srcPort))
      return false;
    if (!(dstNode == rhs.dstNode))
      return false;
    if (!(dstPort == rhs.dstPort))
      return false;
    if (!(definition == rhs.definition))
      return false;
    return true;
  }
  bool operator != (const Batch_disconnect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_disconnect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_disconnect_pargs {
 public:


  virtual ~Batch_disconnect_pargs() throw() {}

  const  ::flowbox::batch::Node* srcNode;
  const  ::flowbox::batch::PortDescriptor* srcPort;
  const  ::flowbox::batch::Node* dstNode;
  const  ::flowbox::batch::PortDescriptor* dstPort;
  const  ::flowbox::batch::Definition* definition;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_disconnect_result__isset {
  _Batch_disconnect_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_disconnect_result__isset;

class Batch_disconnect_result {
 public:

  Batch_disconnect_result() {
  }

  virtual ~Batch_disconnect_result() throw() {}

  ArgumentException missingFields;

  _Batch_disconnect_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_disconnect_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_disconnect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_disconnect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_disconnect_presult__isset {
  _Batch_disconnect_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_disconnect_presult__isset;

class Batch_disconnect_presult {
 public:


  virtual ~Batch_disconnect_presult() throw() {}

  ArgumentException missingFields;

  _Batch_disconnect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_ping_args {
 public:

  Batch_ping_args() {
  }

  virtual ~Batch_ping_args() throw() {}


  bool operator == (const Batch_ping_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_ping_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_ping_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_pargs {
 public:


  virtual ~Batch_ping_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_result {
 public:

  Batch_ping_result() {
  }

  virtual ~Batch_ping_result() throw() {}


  bool operator == (const Batch_ping_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_ping_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_ping_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_presult {
 public:


  virtual ~Batch_ping_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class BatchClient : virtual public BatchIf {
 public:
  BatchClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  BatchClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void libraries(std::vector< ::flowbox::batch::Library> & _return);
  void send_libraries();
  void recv_libraries(std::vector< ::flowbox::batch::Library> & _return);
  void createLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library);
  void send_createLibrary(const  ::flowbox::batch::Library& library);
  void recv_createLibrary( ::flowbox::batch::Library& _return);
  void loadLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library);
  void send_loadLibrary(const  ::flowbox::batch::Library& library);
  void recv_loadLibrary( ::flowbox::batch::Library& _return);
  void unloadLibrary(const  ::flowbox::batch::Library& library);
  void send_unloadLibrary(const  ::flowbox::batch::Library& library);
  void recv_unloadLibrary();
  void storeLibrary(const  ::flowbox::batch::Library& library);
  void send_storeLibrary(const  ::flowbox::batch::Library& library);
  void recv_storeLibrary();
  void libraryRootDef( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Library& library);
  void send_libraryRootDef(const  ::flowbox::batch::Library& library);
  void recv_libraryRootDef( ::flowbox::batch::Definition& _return);
  void newDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Type& type, const  ::flowbox::batch::Imports& imports, const  ::flowbox::batch::Flags& flags, const  ::flowbox::batch::Attributes& attrs);
  void send_newDefinition(const  ::flowbox::batch::Type& type, const  ::flowbox::batch::Imports& imports, const  ::flowbox::batch::Flags& flags, const  ::flowbox::batch::Attributes& attrs);
  void recv_newDefinition( ::flowbox::batch::Definition& _return);
  void addDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition, const  ::flowbox::batch::Definition& parent);
  void send_addDefinition(const  ::flowbox::batch::Definition& definition, const  ::flowbox::batch::Definition& parent);
  void recv_addDefinition( ::flowbox::batch::Definition& _return);
  void updateDefinition(const  ::flowbox::batch::Definition& definition);
  void send_updateDefinition(const  ::flowbox::batch::Definition& definition);
  void recv_updateDefinition();
  void removeDefinition(const  ::flowbox::batch::Definition& definition);
  void send_removeDefinition(const  ::flowbox::batch::Definition& definition);
  void recv_removeDefinition();
  void definitionChildren(std::vector< ::flowbox::batch::Definition> & _return, const  ::flowbox::batch::Definition& definition);
  void send_definitionChildren(const  ::flowbox::batch::Definition& definition);
  void recv_definitionChildren(std::vector< ::flowbox::batch::Definition> & _return);
  void definitionParent( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition);
  void send_definitionParent(const  ::flowbox::batch::Definition& definition);
  void recv_definitionParent( ::flowbox::batch::Definition& _return);
  void newTypeModule( ::flowbox::batch::Type& _return, const std::string& name);
  void send_newTypeModule(const std::string& name);
  void recv_newTypeModule( ::flowbox::batch::Type& _return);
  void newTypeClass( ::flowbox::batch::Type& _return, const std::string& name, const std::vector<std::string> & typeparams, const std::vector< ::flowbox::batch::Type> & params);
  void send_newTypeClass(const std::string& name, const std::vector<std::string> & typeparams, const std::vector< ::flowbox::batch::Type> & params);
  void recv_newTypeClass( ::flowbox::batch::Type& _return);
  void newTypeFunction( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& inputs, const  ::flowbox::batch::Type& outputs);
  void send_newTypeFunction(const std::string& name, const  ::flowbox::batch::Type& inputs, const  ::flowbox::batch::Type& outputs);
  void recv_newTypeFunction( ::flowbox::batch::Type& _return);
  void newTypeUdefined( ::flowbox::batch::Type& _return);
  void send_newTypeUdefined();
  void recv_newTypeUdefined( ::flowbox::batch::Type& _return);
  void newTypeNamed( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& type);
  void send_newTypeNamed(const std::string& name, const  ::flowbox::batch::Type& type);
  void recv_newTypeNamed( ::flowbox::batch::Type& _return);
  void newTypeVariable( ::flowbox::batch::Type& _return, const std::string& name);
  void send_newTypeVariable(const std::string& name);
  void recv_newTypeVariable( ::flowbox::batch::Type& _return);
  void newTypeList( ::flowbox::batch::Type& _return, const  ::flowbox::batch::Type& type);
  void send_newTypeList(const  ::flowbox::batch::Type& type);
  void recv_newTypeList( ::flowbox::batch::Type& _return);
  void newTypeTuple( ::flowbox::batch::Type& _return, const std::vector< ::flowbox::batch::Type> & types);
  void send_newTypeTuple(const std::vector< ::flowbox::batch::Type> & types);
  void recv_newTypeTuple( ::flowbox::batch::Type& _return);
  void graph( ::flowbox::batch::Graph& _return, const  ::flowbox::batch::Definition& definition);
  void send_graph(const  ::flowbox::batch::Definition& definition);
  void recv_graph( ::flowbox::batch::Graph& _return);
  void addNode( ::flowbox::batch::Node& _return, const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void send_addNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void recv_addNode( ::flowbox::batch::Node& _return);
  void updateNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void send_updateNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void recv_updateNode();
  void removeNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void send_removeNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition);
  void recv_removeNode();
  void connect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition);
  void send_connect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition);
  void recv_connect();
  void disconnect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition);
  void send_disconnect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition);
  void recv_disconnect();
  void ping();
  void send_ping();
  void recv_ping();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class BatchProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<BatchIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (BatchProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_libraries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_loadLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unloadLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_storeLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_libraryRootDef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_definitionChildren(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_definitionParent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeModule(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeClass(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeFunction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeUdefined(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeNamed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeVariable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeTuple(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_graph(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disconnect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  BatchProcessor(boost::shared_ptr<BatchIf> iface) :
    iface_(iface) {
    processMap_["libraries"] = &BatchProcessor::process_libraries;
    processMap_["createLibrary"] = &BatchProcessor::process_createLibrary;
    processMap_["loadLibrary"] = &BatchProcessor::process_loadLibrary;
    processMap_["unloadLibrary"] = &BatchProcessor::process_unloadLibrary;
    processMap_["storeLibrary"] = &BatchProcessor::process_storeLibrary;
    processMap_["libraryRootDef"] = &BatchProcessor::process_libraryRootDef;
    processMap_["newDefinition"] = &BatchProcessor::process_newDefinition;
    processMap_["addDefinition"] = &BatchProcessor::process_addDefinition;
    processMap_["updateDefinition"] = &BatchProcessor::process_updateDefinition;
    processMap_["removeDefinition"] = &BatchProcessor::process_removeDefinition;
    processMap_["definitionChildren"] = &BatchProcessor::process_definitionChildren;
    processMap_["definitionParent"] = &BatchProcessor::process_definitionParent;
    processMap_["newTypeModule"] = &BatchProcessor::process_newTypeModule;
    processMap_["newTypeClass"] = &BatchProcessor::process_newTypeClass;
    processMap_["newTypeFunction"] = &BatchProcessor::process_newTypeFunction;
    processMap_["newTypeUdefined"] = &BatchProcessor::process_newTypeUdefined;
    processMap_["newTypeNamed"] = &BatchProcessor::process_newTypeNamed;
    processMap_["newTypeVariable"] = &BatchProcessor::process_newTypeVariable;
    processMap_["newTypeList"] = &BatchProcessor::process_newTypeList;
    processMap_["newTypeTuple"] = &BatchProcessor::process_newTypeTuple;
    processMap_["graph"] = &BatchProcessor::process_graph;
    processMap_["addNode"] = &BatchProcessor::process_addNode;
    processMap_["updateNode"] = &BatchProcessor::process_updateNode;
    processMap_["removeNode"] = &BatchProcessor::process_removeNode;
    processMap_["connect"] = &BatchProcessor::process_connect;
    processMap_["disconnect"] = &BatchProcessor::process_disconnect;
    processMap_["ping"] = &BatchProcessor::process_ping;
  }

  virtual ~BatchProcessor() {}
};

class BatchProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  BatchProcessorFactory(const ::boost::shared_ptr< BatchIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< BatchIfFactory > handlerFactory_;
};

class BatchMultiface : virtual public BatchIf {
 public:
  BatchMultiface(std::vector<boost::shared_ptr<BatchIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~BatchMultiface() {}
 protected:
  std::vector<boost::shared_ptr<BatchIf> > ifaces_;
  BatchMultiface() {}
  void add(boost::shared_ptr<BatchIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void libraries(std::vector< ::flowbox::batch::Library> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->libraries(_return);
    }
    ifaces_[i]->libraries(_return);
    return;
  }

  void createLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createLibrary(_return, library);
    }
    ifaces_[i]->createLibrary(_return, library);
    return;
  }

  void loadLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->loadLibrary(_return, library);
    }
    ifaces_[i]->loadLibrary(_return, library);
    return;
  }

  void unloadLibrary(const  ::flowbox::batch::Library& library) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unloadLibrary(library);
    }
    ifaces_[i]->unloadLibrary(library);
  }

  void storeLibrary(const  ::flowbox::batch::Library& library) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->storeLibrary(library);
    }
    ifaces_[i]->storeLibrary(library);
  }

  void libraryRootDef( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Library& library) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->libraryRootDef(_return, library);
    }
    ifaces_[i]->libraryRootDef(_return, library);
    return;
  }

  void newDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Type& type, const  ::flowbox::batch::Imports& imports, const  ::flowbox::batch::Flags& flags, const  ::flowbox::batch::Attributes& attrs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newDefinition(_return, type, imports, flags, attrs);
    }
    ifaces_[i]->newDefinition(_return, type, imports, flags, attrs);
    return;
  }

  void addDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition, const  ::flowbox::batch::Definition& parent) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addDefinition(_return, definition, parent);
    }
    ifaces_[i]->addDefinition(_return, definition, parent);
    return;
  }

  void updateDefinition(const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateDefinition(definition);
    }
    ifaces_[i]->updateDefinition(definition);
  }

  void removeDefinition(const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeDefinition(definition);
    }
    ifaces_[i]->removeDefinition(definition);
  }

  void definitionChildren(std::vector< ::flowbox::batch::Definition> & _return, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->definitionChildren(_return, definition);
    }
    ifaces_[i]->definitionChildren(_return, definition);
    return;
  }

  void definitionParent( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->definitionParent(_return, definition);
    }
    ifaces_[i]->definitionParent(_return, definition);
    return;
  }

  void newTypeModule( ::flowbox::batch::Type& _return, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeModule(_return, name);
    }
    ifaces_[i]->newTypeModule(_return, name);
    return;
  }

  void newTypeClass( ::flowbox::batch::Type& _return, const std::string& name, const std::vector<std::string> & typeparams, const std::vector< ::flowbox::batch::Type> & params) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeClass(_return, name, typeparams, params);
    }
    ifaces_[i]->newTypeClass(_return, name, typeparams, params);
    return;
  }

  void newTypeFunction( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& inputs, const  ::flowbox::batch::Type& outputs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeFunction(_return, name, inputs, outputs);
    }
    ifaces_[i]->newTypeFunction(_return, name, inputs, outputs);
    return;
  }

  void newTypeUdefined( ::flowbox::batch::Type& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeUdefined(_return);
    }
    ifaces_[i]->newTypeUdefined(_return);
    return;
  }

  void newTypeNamed( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& type) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeNamed(_return, name, type);
    }
    ifaces_[i]->newTypeNamed(_return, name, type);
    return;
  }

  void newTypeVariable( ::flowbox::batch::Type& _return, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeVariable(_return, name);
    }
    ifaces_[i]->newTypeVariable(_return, name);
    return;
  }

  void newTypeList( ::flowbox::batch::Type& _return, const  ::flowbox::batch::Type& type) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeList(_return, type);
    }
    ifaces_[i]->newTypeList(_return, type);
    return;
  }

  void newTypeTuple( ::flowbox::batch::Type& _return, const std::vector< ::flowbox::batch::Type> & types) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeTuple(_return, types);
    }
    ifaces_[i]->newTypeTuple(_return, types);
    return;
  }

  void graph( ::flowbox::batch::Graph& _return, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->graph(_return, definition);
    }
    ifaces_[i]->graph(_return, definition);
    return;
  }

  void addNode( ::flowbox::batch::Node& _return, const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addNode(_return, node, definition);
    }
    ifaces_[i]->addNode(_return, node, definition);
    return;
  }

  void updateNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateNode(node, definition);
    }
    ifaces_[i]->updateNode(node, definition);
  }

  void removeNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeNode(node, definition);
    }
    ifaces_[i]->removeNode(node, definition);
  }

  void connect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->connect(srcNode, srcPort, dstNode, dstPort, definition);
    }
    ifaces_[i]->connect(srcNode, srcPort, dstNode, dstPort, definition);
  }

  void disconnect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disconnect(srcNode, srcPort, dstNode, dstPort, definition);
    }
    ifaces_[i]->disconnect(srcNode, srcPort, dstNode, dstPort, definition);
  }

  void ping() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ping();
    }
    ifaces_[i]->ping();
  }

};

}} // namespace

#endif
