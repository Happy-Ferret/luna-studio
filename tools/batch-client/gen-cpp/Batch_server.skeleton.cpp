// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Batch.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::flowbox::batch;

class BatchHandler : virtual public BatchIf {
 public:
  BatchHandler() {
    // Your initialization goes here
  }

  void libraries(std::vector< ::flowbox::batch::Library> & _return) {
    // Your implementation goes here
    printf("libraries\n");
  }

  void createLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) {
    // Your implementation goes here
    printf("createLibrary\n");
  }

  void loadLibrary( ::flowbox::batch::Library& _return, const  ::flowbox::batch::Library& library) {
    // Your implementation goes here
    printf("loadLibrary\n");
  }

  void unloadLibrary(const  ::flowbox::batch::Library& library) {
    // Your implementation goes here
    printf("unloadLibrary\n");
  }

  void storeLibrary(const  ::flowbox::batch::Library& library) {
    // Your implementation goes here
    printf("storeLibrary\n");
  }

  void libraryRootDef( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Library& library) {
    // Your implementation goes here
    printf("libraryRootDef\n");
  }

  void newDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Type& type, const  ::flowbox::batch::Imports& imports, const  ::flowbox::batch::Flags& flags, const  ::flowbox::batch::Attributes& attrs) {
    // Your implementation goes here
    printf("newDefinition\n");
  }

  void addDefinition( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition, const  ::flowbox::batch::Definition& parent) {
    // Your implementation goes here
    printf("addDefinition\n");
  }

  void updateDefinition(const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("updateDefinition\n");
  }

  void removeDefinition(const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("removeDefinition\n");
  }

  void definitionChildren(std::vector< ::flowbox::batch::Definition> & _return, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("definitionChildren\n");
  }

  void definitionParent( ::flowbox::batch::Definition& _return, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("definitionParent\n");
  }

  void newTypeModule( ::flowbox::batch::Type& _return, const std::string& name) {
    // Your implementation goes here
    printf("newTypeModule\n");
  }

  void newTypeClass( ::flowbox::batch::Type& _return, const std::string& name, const std::vector<std::string> & typeparams, const std::vector< ::flowbox::batch::Type> & params) {
    // Your implementation goes here
    printf("newTypeClass\n");
  }

  void newTypeFunction( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& inputs, const  ::flowbox::batch::Type& outputs) {
    // Your implementation goes here
    printf("newTypeFunction\n");
  }

  void newTypeUdefined( ::flowbox::batch::Type& _return) {
    // Your implementation goes here
    printf("newTypeUdefined\n");
  }

  void newTypeNamed( ::flowbox::batch::Type& _return, const std::string& name, const  ::flowbox::batch::Type& type) {
    // Your implementation goes here
    printf("newTypeNamed\n");
  }

  void newTypeVariable( ::flowbox::batch::Type& _return, const std::string& name) {
    // Your implementation goes here
    printf("newTypeVariable\n");
  }

  void newTypeList( ::flowbox::batch::Type& _return, const  ::flowbox::batch::Type& type) {
    // Your implementation goes here
    printf("newTypeList\n");
  }

  void newTypeTuple( ::flowbox::batch::Type& _return, const std::vector< ::flowbox::batch::Type> & types) {
    // Your implementation goes here
    printf("newTypeTuple\n");
  }

  void graph( ::flowbox::batch::Graph& _return, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("graph\n");
  }

  void addNode( ::flowbox::batch::Node& _return, const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("addNode\n");
  }

  void updateNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("updateNode\n");
  }

  void removeNode(const  ::flowbox::batch::Node& node, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("removeNode\n");
  }

  void connect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("connect\n");
  }

  void disconnect(const  ::flowbox::batch::Node& srcNode, const  ::flowbox::batch::PortDescriptor& srcPort, const  ::flowbox::batch::Node& dstNode, const  ::flowbox::batch::PortDescriptor& dstPort, const  ::flowbox::batch::Definition& definition) {
    // Your implementation goes here
    printf("disconnect\n");
  }

  void ping() {
    // Your implementation goes here
    printf("ping\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<BatchHandler> handler(new BatchHandler());
  shared_ptr<TProcessor> processor(new BatchProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

