// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Batch.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::flowbox::batch;

class BatchHandler : virtual public BatchIf {
 public:
  BatchHandler() {
    // Your initialization goes here
  }

  void libraries(std::vector< ::Library> & _return) {
    // Your implementation goes here
    printf("libraries\n");
  }

  void loadLibrary( ::Library& _return, const  ::Library& library) {
    // Your implementation goes here
    printf("loadLibrary\n");
  }

  void unloadLibrary(const  ::Library& library) {
    // Your implementation goes here
    printf("unloadLibrary\n");
  }

  void libraryRootDef( ::NodeDef& _return, const  ::Library& library) {
    // Your implementation goes here
    printf("libraryRootDef\n");
  }

  void newDefinition( ::NodeDef& _return, const  ::Type& type, const  ::Imports& imports, const  ::Flags& flags, const  ::Attributes& attrs) {
    // Your implementation goes here
    printf("newDefinition\n");
  }

  void addDefinition( ::NodeDef& _return, const  ::NodeDef& definition, const  ::NodeDef& parent) {
    // Your implementation goes here
    printf("addDefinition\n");
  }

  void updateDefinition(const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("updateDefinition\n");
  }

  void removeDefinition(const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("removeDefinition\n");
  }

  void definitionChildren(std::vector< ::NodeDef> & _return, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("definitionChildren\n");
  }

  void definitionParent( ::NodeDef& _return, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("definitionParent\n");
  }

  void newTypeModule( ::Type& _return, const std::string& name) {
    // Your implementation goes here
    printf("newTypeModule\n");
  }

  void newTypeClass( ::Type& _return, const std::string& name, const  ::Type& params) {
    // Your implementation goes here
    printf("newTypeClass\n");
  }

  void newTypeFunction( ::Type& _return, const std::string& name, const  ::Type& inputs, const  ::Type& outputs) {
    // Your implementation goes here
    printf("newTypeFunction\n");
  }

  void newTypeUdefined( ::Type& _return) {
    // Your implementation goes here
    printf("newTypeUdefined\n");
  }

  void newTypeNamed( ::Type& _return, const std::string& name) {
    // Your implementation goes here
    printf("newTypeNamed\n");
  }

  void newTypeVariable( ::Type& _return, const std::string& name, const  ::Type& type) {
    // Your implementation goes here
    printf("newTypeVariable\n");
  }

  void newTypeList( ::Type& _return, const  ::Type& type) {
    // Your implementation goes here
    printf("newTypeList\n");
  }

  void newTypeTuple( ::Type& _return, const std::vector< ::Type> & types) {
    // Your implementation goes here
    printf("newTypeTuple\n");
  }

  void graph( ::Graph& _return, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("graph\n");
  }

  void addNode( ::Node& _return, const  ::Node& node, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("addNode\n");
  }

  void updateNode(const  ::Node& node, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("updateNode\n");
  }

  void removeNode(const  ::Node& node, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("removeNode\n");
  }

  void connect(const  ::Node& srcNode, const  ::PortDescriptor& srcPort, const  ::Node& dstNode, const  ::PortDescriptor& dstPort, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("connect\n");
  }

  void disconnect(const  ::Node& srcNode, const  ::PortDescriptor& srcPort, const  ::Node& dstNode, const  ::PortDescriptor& dstPort, const  ::NodeDef& definition) {
    // Your implementation goes here
    printf("disconnect\n");
  }

  void ping() {
    // Your implementation goes here
    printf("ping\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<BatchHandler> handler(new BatchHandler());
  shared_ptr<TProcessor> processor(new BatchProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

