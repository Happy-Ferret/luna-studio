{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()

import Attrs_Types
import Defs_Types
import Graph_Types
import Libs_Types
import Projects_Types
import Types_Types


import Batch_Types
import qualified Batch_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Projects_args = Projects_args deriving (Show,Eq,Typeable)
instance Hashable Projects_args where
  hashWithSalt salt record = salt  
write_Projects_args oprot record = do
  writeStructBegin oprot "Projects_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_args_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Projects_args_fields iprot record
read_Projects_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_args_fields iprot (Projects_args{})
  readStructEnd iprot
  return record
data Projects_result = Projects_result{f_Projects_result_success :: Maybe (Vector.Vector Projects_Types.Project)} deriving (Show,Eq,Typeable)
instance Hashable Projects_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Projects_result_success record  
write_Projects_result oprot record = do
  writeStructBegin oprot "Projects_result"
  case f_Projects_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter12 -> Projects_Types.write_Project oprot _viter12) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Projects_result_fields iprot record = do
  (_,_t14,_id15) <- readFieldBegin iprot
  if _t14 == T_STOP then return record else
    case _id15 of 
      0 -> if _t14 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Project iprot)) in do {(_etype19,_size16) <- readListBegin iprot; f _size16})
        read_Projects_result_fields iprot record{f_Projects_result_success=Just s}
        else do
          skip iprot _t14
          read_Projects_result_fields iprot record
      _ -> do
        skip iprot _t14
        readFieldEnd iprot
        read_Projects_result_fields iprot record
read_Projects_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Projects_result_fields iprot (Projects_result{f_Projects_result_success=Nothing})
  readStructEnd iprot
  return record
data CreateProject_args = CreateProject_args{f_CreateProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_args_project record  
write_CreateProject_args oprot record = do
  writeStructBegin oprot "CreateProject_args"
  case f_CreateProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_args_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_args_fields iprot record{f_CreateProject_args_project=Just s}
        else do
          skip iprot _t24
          read_CreateProject_args_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_CreateProject_args_fields iprot record
read_CreateProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_args_fields iprot (CreateProject_args{f_CreateProject_args_project=Nothing})
  readStructEnd iprot
  return record
data CreateProject_result = CreateProject_result{f_CreateProject_result_success :: Maybe Projects_Types.Project,f_CreateProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateProject_result_success record   `hashWithSalt` f_CreateProject_result_missingFields record  
write_CreateProject_result oprot record = do
  writeStructBegin oprot "CreateProject_result"
  case f_CreateProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_CreateProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateProject_result_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      0 -> if _t29 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_success=Just s}
        else do
          skip iprot _t29
          read_CreateProject_result_fields iprot record
      1 -> if _t29 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateProject_result_fields iprot record{f_CreateProject_result_missingFields=Just s}
        else do
          skip iprot _t29
          read_CreateProject_result_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_CreateProject_result_fields iprot record
read_CreateProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateProject_result_fields iprot (CreateProject_result{f_CreateProject_result_success=Nothing,f_CreateProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data OpenProject_args = OpenProject_args{f_OpenProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_args_project record  
write_OpenProject_args oprot record = do
  writeStructBegin oprot "OpenProject_args"
  case f_OpenProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_args_fields iprot record = do
  (_,_t34,_id35) <- readFieldBegin iprot
  if _t34 == T_STOP then return record else
    case _id35 of 
      1 -> if _t34 == T_STRUCT then do
        s <- (read_Project iprot)
        read_OpenProject_args_fields iprot record{f_OpenProject_args_project=Just s}
        else do
          skip iprot _t34
          read_OpenProject_args_fields iprot record
      _ -> do
        skip iprot _t34
        readFieldEnd iprot
        read_OpenProject_args_fields iprot record
read_OpenProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_args_fields iprot (OpenProject_args{f_OpenProject_args_project=Nothing})
  readStructEnd iprot
  return record
data OpenProject_result = OpenProject_result{f_OpenProject_result_success :: Maybe Projects_Types.Project,f_OpenProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable OpenProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_OpenProject_result_success record   `hashWithSalt` f_OpenProject_result_missingFields record  
write_OpenProject_result oprot record = do
  writeStructBegin oprot "OpenProject_result"
  case f_OpenProject_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  case f_OpenProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_OpenProject_result_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      0 -> if _t39 == T_STRUCT then do
        s <- (read_Project iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_success=Just s}
        else do
          skip iprot _t39
          read_OpenProject_result_fields iprot record
      1 -> if _t39 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_OpenProject_result_fields iprot record{f_OpenProject_result_missingFields=Just s}
        else do
          skip iprot _t39
          read_OpenProject_result_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_OpenProject_result_fields iprot record
read_OpenProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_OpenProject_result_fields iprot (OpenProject_result{f_OpenProject_result_success=Nothing,f_OpenProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data CloseProject_args = CloseProject_args{f_CloseProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_args_project record  
write_CloseProject_args oprot record = do
  writeStructBegin oprot "CloseProject_args"
  case f_CloseProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_args_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_STRUCT then do
        s <- (read_Project iprot)
        read_CloseProject_args_fields iprot record{f_CloseProject_args_project=Just s}
        else do
          skip iprot _t44
          read_CloseProject_args_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_CloseProject_args_fields iprot record
read_CloseProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_args_fields iprot (CloseProject_args{f_CloseProject_args_project=Nothing})
  readStructEnd iprot
  return record
data CloseProject_result = CloseProject_result{f_CloseProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CloseProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CloseProject_result_missingFields record  
write_CloseProject_result oprot record = do
  writeStructBegin oprot "CloseProject_result"
  case f_CloseProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CloseProject_result_fields iprot record = do
  (_,_t49,_id50) <- readFieldBegin iprot
  if _t49 == T_STOP then return record else
    case _id50 of 
      1 -> if _t49 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CloseProject_result_fields iprot record{f_CloseProject_result_missingFields=Just s}
        else do
          skip iprot _t49
          read_CloseProject_result_fields iprot record
      _ -> do
        skip iprot _t49
        readFieldEnd iprot
        read_CloseProject_result_fields iprot record
read_CloseProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CloseProject_result_fields iprot (CloseProject_result{f_CloseProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data SetActiveProject_args = SetActiveProject_args{f_SetActiveProject_args_project :: Maybe Projects_Types.Project} deriving (Show,Eq,Typeable)
instance Hashable SetActiveProject_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_SetActiveProject_args_project record  
write_SetActiveProject_args oprot record = do
  writeStructBegin oprot "SetActiveProject_args"
  case f_SetActiveProject_args_project record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("project",T_STRUCT,1)
    Projects_Types.write_Project oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SetActiveProject_args_fields iprot record = do
  (_,_t54,_id55) <- readFieldBegin iprot
  if _t54 == T_STOP then return record else
    case _id55 of 
      1 -> if _t54 == T_STRUCT then do
        s <- (read_Project iprot)
        read_SetActiveProject_args_fields iprot record{f_SetActiveProject_args_project=Just s}
        else do
          skip iprot _t54
          read_SetActiveProject_args_fields iprot record
      _ -> do
        skip iprot _t54
        readFieldEnd iprot
        read_SetActiveProject_args_fields iprot record
read_SetActiveProject_args iprot = do
  _ <- readStructBegin iprot
  record <- read_SetActiveProject_args_fields iprot (SetActiveProject_args{f_SetActiveProject_args_project=Nothing})
  readStructEnd iprot
  return record
data SetActiveProject_result = SetActiveProject_result{f_SetActiveProject_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable SetActiveProject_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_SetActiveProject_result_missingFields record  
write_SetActiveProject_result oprot record = do
  writeStructBegin oprot "SetActiveProject_result"
  case f_SetActiveProject_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_SetActiveProject_result_fields iprot record = do
  (_,_t59,_id60) <- readFieldBegin iprot
  if _t59 == T_STOP then return record else
    case _id60 of 
      1 -> if _t59 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_SetActiveProject_result_fields iprot record{f_SetActiveProject_result_missingFields=Just s}
        else do
          skip iprot _t59
          read_SetActiveProject_result_fields iprot record
      _ -> do
        skip iprot _t59
        readFieldEnd iprot
        read_SetActiveProject_result_fields iprot record
read_SetActiveProject_result iprot = do
  _ <- readStructBegin iprot
  record <- read_SetActiveProject_result_fields iprot (SetActiveProject_result{f_SetActiveProject_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Libraries_args = Libraries_args deriving (Show,Eq,Typeable)
instance Hashable Libraries_args where
  hashWithSalt salt record = salt  
write_Libraries_args oprot record = do
  writeStructBegin oprot "Libraries_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_args_fields iprot record = do
  (_,_t64,_id65) <- readFieldBegin iprot
  if _t64 == T_STOP then return record else
    case _id65 of 
      _ -> do
        skip iprot _t64
        readFieldEnd iprot
        read_Libraries_args_fields iprot record
read_Libraries_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_args_fields iprot (Libraries_args{})
  readStructEnd iprot
  return record
data Libraries_result = Libraries_result{f_Libraries_result_success :: Maybe (Vector.Vector Libs_Types.Library)} deriving (Show,Eq,Typeable)
instance Hashable Libraries_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_result_success record  
write_Libraries_result oprot record = do
  writeStructBegin oprot "Libraries_result"
  case f_Libraries_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter68 -> Libs_Types.write_Library oprot _viter68) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_result_fields iprot record = do
  (_,_t70,_id71) <- readFieldBegin iprot
  if _t70 == T_STOP then return record else
    case _id71 of 
      0 -> if _t70 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Library iprot)) in do {(_etype75,_size72) <- readListBegin iprot; f _size72})
        read_Libraries_result_fields iprot record{f_Libraries_result_success=Just s}
        else do
          skip iprot _t70
          read_Libraries_result_fields iprot record
      _ -> do
        skip iprot _t70
        readFieldEnd iprot
        read_Libraries_result_fields iprot record
read_Libraries_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_result_fields iprot (Libraries_result{f_Libraries_result_success=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_args = CreateLibrary_args{f_CreateLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_args_library record  
write_CreateLibrary_args oprot record = do
  writeStructBegin oprot "CreateLibrary_args"
  case f_CreateLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_args_fields iprot record = do
  (_,_t80,_id81) <- readFieldBegin iprot
  if _t80 == T_STOP then return record else
    case _id81 of 
      1 -> if _t80 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_args_fields iprot record{f_CreateLibrary_args_library=Just s}
        else do
          skip iprot _t80
          read_CreateLibrary_args_fields iprot record
      _ -> do
        skip iprot _t80
        readFieldEnd iprot
        read_CreateLibrary_args_fields iprot record
read_CreateLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_args_fields iprot (CreateLibrary_args{f_CreateLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data CreateLibrary_result = CreateLibrary_result{f_CreateLibrary_result_success :: Maybe Libs_Types.Library,f_CreateLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable CreateLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_CreateLibrary_result_success record   `hashWithSalt` f_CreateLibrary_result_missingFields record  
write_CreateLibrary_result oprot record = do
  writeStructBegin oprot "CreateLibrary_result"
  case f_CreateLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_CreateLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_CreateLibrary_result_fields iprot record = do
  (_,_t85,_id86) <- readFieldBegin iprot
  if _t85 == T_STOP then return record else
    case _id86 of 
      0 -> if _t85 == T_STRUCT then do
        s <- (read_Library iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_success=Just s}
        else do
          skip iprot _t85
          read_CreateLibrary_result_fields iprot record
      1 -> if _t85 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_CreateLibrary_result_fields iprot record{f_CreateLibrary_result_missingFields=Just s}
        else do
          skip iprot _t85
          read_CreateLibrary_result_fields iprot record
      _ -> do
        skip iprot _t85
        readFieldEnd iprot
        read_CreateLibrary_result_fields iprot record
read_CreateLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_CreateLibrary_result_fields iprot (CreateLibrary_result{f_CreateLibrary_result_success=Nothing,f_CreateLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_args = LoadLibrary_args{f_LoadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_args_library record  
write_LoadLibrary_args oprot record = do
  writeStructBegin oprot "LoadLibrary_args"
  case f_LoadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_args_fields iprot record = do
  (_,_t90,_id91) <- readFieldBegin iprot
  if _t90 == T_STOP then return record else
    case _id91 of 
      1 -> if _t90 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_library=Just s}
        else do
          skip iprot _t90
          read_LoadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t90
        readFieldEnd iprot
        read_LoadLibrary_args_fields iprot record
read_LoadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_args_fields iprot (LoadLibrary_args{f_LoadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_result = LoadLibrary_result{f_LoadLibrary_result_success :: Maybe Libs_Types.Library,f_LoadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_result_success record   `hashWithSalt` f_LoadLibrary_result_missingFields record  
write_LoadLibrary_result oprot record = do
  writeStructBegin oprot "LoadLibrary_result"
  case f_LoadLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_result_fields iprot record = do
  (_,_t95,_id96) <- readFieldBegin iprot
  if _t95 == T_STOP then return record else
    case _id96 of 
      0 -> if _t95 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_success=Just s}
        else do
          skip iprot _t95
          read_LoadLibrary_result_fields iprot record
      1 -> if _t95 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t95
          read_LoadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t95
        readFieldEnd iprot
        read_LoadLibrary_result_fields iprot record
read_LoadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_result_fields iprot (LoadLibrary_result{f_LoadLibrary_result_success=Nothing,f_LoadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_args = UnloadLibrary_args{f_UnloadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_args_library record  
write_UnloadLibrary_args oprot record = do
  writeStructBegin oprot "UnloadLibrary_args"
  case f_UnloadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_args_fields iprot record = do
  (_,_t100,_id101) <- readFieldBegin iprot
  if _t100 == T_STOP then return record else
    case _id101 of 
      1 -> if _t100 == T_STRUCT then do
        s <- (read_Library iprot)
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_library=Just s}
        else do
          skip iprot _t100
          read_UnloadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t100
        readFieldEnd iprot
        read_UnloadLibrary_args_fields iprot record
read_UnloadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_args_fields iprot (UnloadLibrary_args{f_UnloadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_result = UnloadLibrary_result{f_UnloadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_result_missingFields record  
write_UnloadLibrary_result oprot record = do
  writeStructBegin oprot "UnloadLibrary_result"
  case f_UnloadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_result_fields iprot record = do
  (_,_t105,_id106) <- readFieldBegin iprot
  if _t105 == T_STOP then return record else
    case _id106 of 
      1 -> if _t105 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UnloadLibrary_result_fields iprot record{f_UnloadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t105
          read_UnloadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t105
        readFieldEnd iprot
        read_UnloadLibrary_result_fields iprot record
read_UnloadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_result_fields iprot (UnloadLibrary_result{f_UnloadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_args = StoreLibrary_args{f_StoreLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_args_library record  
write_StoreLibrary_args oprot record = do
  writeStructBegin oprot "StoreLibrary_args"
  case f_StoreLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_args_fields iprot record = do
  (_,_t110,_id111) <- readFieldBegin iprot
  if _t110 == T_STOP then return record else
    case _id111 of 
      1 -> if _t110 == T_STRUCT then do
        s <- (read_Library iprot)
        read_StoreLibrary_args_fields iprot record{f_StoreLibrary_args_library=Just s}
        else do
          skip iprot _t110
          read_StoreLibrary_args_fields iprot record
      _ -> do
        skip iprot _t110
        readFieldEnd iprot
        read_StoreLibrary_args_fields iprot record
read_StoreLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_args_fields iprot (StoreLibrary_args{f_StoreLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data StoreLibrary_result = StoreLibrary_result{f_StoreLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable StoreLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_StoreLibrary_result_missingFields record  
write_StoreLibrary_result oprot record = do
  writeStructBegin oprot "StoreLibrary_result"
  case f_StoreLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_StoreLibrary_result_fields iprot record = do
  (_,_t115,_id116) <- readFieldBegin iprot
  if _t115 == T_STOP then return record else
    case _id116 of 
      1 -> if _t115 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_StoreLibrary_result_fields iprot record{f_StoreLibrary_result_missingFields=Just s}
        else do
          skip iprot _t115
          read_StoreLibrary_result_fields iprot record
      _ -> do
        skip iprot _t115
        readFieldEnd iprot
        read_StoreLibrary_result_fields iprot record
read_StoreLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_StoreLibrary_result_fields iprot (StoreLibrary_result{f_StoreLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_args = LibraryRootDef_args{f_LibraryRootDef_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_args_library record  
write_LibraryRootDef_args oprot record = do
  writeStructBegin oprot "LibraryRootDef_args"
  case f_LibraryRootDef_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_args_fields iprot record = do
  (_,_t120,_id121) <- readFieldBegin iprot
  if _t120 == T_STOP then return record else
    case _id121 of 
      1 -> if _t120 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_library=Just s}
        else do
          skip iprot _t120
          read_LibraryRootDef_args_fields iprot record
      _ -> do
        skip iprot _t120
        readFieldEnd iprot
        read_LibraryRootDef_args_fields iprot record
read_LibraryRootDef_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_args_fields iprot (LibraryRootDef_args{f_LibraryRootDef_args_library=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_result = LibraryRootDef_result{f_LibraryRootDef_result_success :: Maybe Defs_Types.Definition,f_LibraryRootDef_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_result_success record   `hashWithSalt` f_LibraryRootDef_result_missingFields record  
write_LibraryRootDef_result oprot record = do
  writeStructBegin oprot "LibraryRootDef_result"
  case f_LibraryRootDef_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_result_fields iprot record = do
  (_,_t125,_id126) <- readFieldBegin iprot
  if _t125 == T_STOP then return record else
    case _id126 of 
      0 -> if _t125 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_success=Just s}
        else do
          skip iprot _t125
          read_LibraryRootDef_result_fields iprot record
      1 -> if _t125 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_missingFields=Just s}
        else do
          skip iprot _t125
          read_LibraryRootDef_result_fields iprot record
      _ -> do
        skip iprot _t125
        readFieldEnd iprot
        read_LibraryRootDef_result_fields iprot record
read_LibraryRootDef_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_result_fields iprot (LibraryRootDef_result{f_LibraryRootDef_result_success=Nothing,f_LibraryRootDef_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefsGraph_args = DefsGraph_args deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_args where
  hashWithSalt salt record = salt  
write_DefsGraph_args oprot record = do
  writeStructBegin oprot "DefsGraph_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_args_fields iprot record = do
  (_,_t130,_id131) <- readFieldBegin iprot
  if _t130 == T_STOP then return record else
    case _id131 of 
      _ -> do
        skip iprot _t130
        readFieldEnd iprot
        read_DefsGraph_args_fields iprot record
read_DefsGraph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_args_fields iprot (DefsGraph_args{})
  readStructEnd iprot
  return record
data DefsGraph_result = DefsGraph_result{f_DefsGraph_result_success :: Maybe Defs_Types.DefsGraph} deriving (Show,Eq,Typeable)
instance Hashable DefsGraph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefsGraph_result_success record  
write_DefsGraph_result oprot record = do
  writeStructBegin oprot "DefsGraph_result"
  case f_DefsGraph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_DefsGraph oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefsGraph_result_fields iprot record = do
  (_,_t135,_id136) <- readFieldBegin iprot
  if _t135 == T_STOP then return record else
    case _id136 of 
      0 -> if _t135 == T_STRUCT then do
        s <- (read_DefsGraph iprot)
        read_DefsGraph_result_fields iprot record{f_DefsGraph_result_success=Just s}
        else do
          skip iprot _t135
          read_DefsGraph_result_fields iprot record
      _ -> do
        skip iprot _t135
        readFieldEnd iprot
        read_DefsGraph_result_fields iprot record
read_DefsGraph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefsGraph_result_fields iprot (DefsGraph_result{f_DefsGraph_result_success=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_args = NewDefinition_args{f_NewDefinition_args_type :: Maybe Types_Types.Type,f_NewDefinition_args_imports :: Maybe (Vector.Vector Defs_Types.Import),f_NewDefinition_args_flags :: Maybe Attrs_Types.Flags,f_NewDefinition_args_attrs :: Maybe Attrs_Types.Attributes} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_args_type record   `hashWithSalt` f_NewDefinition_args_imports record   `hashWithSalt` f_NewDefinition_args_flags record   `hashWithSalt` f_NewDefinition_args_attrs record  
write_NewDefinition_args oprot record = do
  writeStructBegin oprot "NewDefinition_args"
  case f_NewDefinition_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_imports record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("imports",T_LIST,2)
    (let f = Vector.mapM_ (\_viter139 -> Defs_Types.write_Import oprot _viter139) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NewDefinition_args_flags record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("flags",T_STRUCT,3)
    Attrs_Types.write_Flags oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_attrs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attrs",T_STRUCT,4)
    Attrs_Types.write_Attributes oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_args_fields iprot record = do
  (_,_t141,_id142) <- readFieldBegin iprot
  if _t141 == T_STOP then return record else
    case _id142 of 
      1 -> if _t141 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_type=Just s}
        else do
          skip iprot _t141
          read_NewDefinition_args_fields iprot record
      2 -> if _t141 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Import iprot)) in do {(_etype146,_size143) <- readListBegin iprot; f _size143})
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_imports=Just s}
        else do
          skip iprot _t141
          read_NewDefinition_args_fields iprot record
      3 -> if _t141 == T_STRUCT then do
        s <- (read_Flags iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_flags=Just s}
        else do
          skip iprot _t141
          read_NewDefinition_args_fields iprot record
      4 -> if _t141 == T_STRUCT then do
        s <- (read_Attributes iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_attrs=Just s}
        else do
          skip iprot _t141
          read_NewDefinition_args_fields iprot record
      _ -> do
        skip iprot _t141
        readFieldEnd iprot
        read_NewDefinition_args_fields iprot record
read_NewDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_args_fields iprot (NewDefinition_args{f_NewDefinition_args_type=Nothing,f_NewDefinition_args_imports=Nothing,f_NewDefinition_args_flags=Nothing,f_NewDefinition_args_attrs=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_result = NewDefinition_result{f_NewDefinition_result_success :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_result_success record  
write_NewDefinition_result oprot record = do
  writeStructBegin oprot "NewDefinition_result"
  case f_NewDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_result_fields iprot record = do
  (_,_t151,_id152) <- readFieldBegin iprot
  if _t151 == T_STOP then return record else
    case _id152 of 
      0 -> if _t151 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_NewDefinition_result_fields iprot record{f_NewDefinition_result_success=Just s}
        else do
          skip iprot _t151
          read_NewDefinition_result_fields iprot record
      _ -> do
        skip iprot _t151
        readFieldEnd iprot
        read_NewDefinition_result_fields iprot record
read_NewDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_result_fields iprot (NewDefinition_result{f_NewDefinition_result_success=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_args = AddDefinition_args{f_AddDefinition_args_definition :: Maybe Defs_Types.Definition,f_AddDefinition_args_parent :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_args_definition record   `hashWithSalt` f_AddDefinition_args_parent record  
write_AddDefinition_args oprot record = do
  writeStructBegin oprot "AddDefinition_args"
  case f_AddDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_parent record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parent",T_STRUCT,2)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_args_fields iprot record = do
  (_,_t156,_id157) <- readFieldBegin iprot
  if _t156 == T_STOP then return record else
    case _id157 of 
      1 -> if _t156 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_definition=Just s}
        else do
          skip iprot _t156
          read_AddDefinition_args_fields iprot record
      2 -> if _t156 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_parent=Just s}
        else do
          skip iprot _t156
          read_AddDefinition_args_fields iprot record
      _ -> do
        skip iprot _t156
        readFieldEnd iprot
        read_AddDefinition_args_fields iprot record
read_AddDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_args_fields iprot (AddDefinition_args{f_AddDefinition_args_definition=Nothing,f_AddDefinition_args_parent=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_result = AddDefinition_result{f_AddDefinition_result_success :: Maybe Defs_Types.Definition,f_AddDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_result_success record   `hashWithSalt` f_AddDefinition_result_missingFields record  
write_AddDefinition_result oprot record = do
  writeStructBegin oprot "AddDefinition_result"
  case f_AddDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_result_fields iprot record = do
  (_,_t161,_id162) <- readFieldBegin iprot
  if _t161 == T_STOP then return record else
    case _id162 of 
      0 -> if _t161 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_success=Just s}
        else do
          skip iprot _t161
          read_AddDefinition_result_fields iprot record
      1 -> if _t161 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_missingFields=Just s}
        else do
          skip iprot _t161
          read_AddDefinition_result_fields iprot record
      _ -> do
        skip iprot _t161
        readFieldEnd iprot
        read_AddDefinition_result_fields iprot record
read_AddDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_result_fields iprot (AddDefinition_result{f_AddDefinition_result_success=Nothing,f_AddDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_args = UpdateDefinition_args{f_UpdateDefinition_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_args_definition record  
write_UpdateDefinition_args oprot record = do
  writeStructBegin oprot "UpdateDefinition_args"
  case f_UpdateDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_args_fields iprot record = do
  (_,_t166,_id167) <- readFieldBegin iprot
  if _t166 == T_STOP then return record else
    case _id167 of 
      1 -> if _t166 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_definition=Just s}
        else do
          skip iprot _t166
          read_UpdateDefinition_args_fields iprot record
      _ -> do
        skip iprot _t166
        readFieldEnd iprot
        read_UpdateDefinition_args_fields iprot record
read_UpdateDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_args_fields iprot (UpdateDefinition_args{f_UpdateDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_result = UpdateDefinition_result{f_UpdateDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_result_missingFields record  
write_UpdateDefinition_result oprot record = do
  writeStructBegin oprot "UpdateDefinition_result"
  case f_UpdateDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_result_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      1 -> if _t171 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateDefinition_result_fields iprot record{f_UpdateDefinition_result_missingFields=Just s}
        else do
          skip iprot _t171
          read_UpdateDefinition_result_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_UpdateDefinition_result_fields iprot record
read_UpdateDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_result_fields iprot (UpdateDefinition_result{f_UpdateDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_args = RemoveDefinition_args{f_RemoveDefinition_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_args_definition record  
write_RemoveDefinition_args oprot record = do
  writeStructBegin oprot "RemoveDefinition_args"
  case f_RemoveDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_args_fields iprot record = do
  (_,_t176,_id177) <- readFieldBegin iprot
  if _t176 == T_STOP then return record else
    case _id177 of 
      1 -> if _t176 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_definition=Just s}
        else do
          skip iprot _t176
          read_RemoveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t176
        readFieldEnd iprot
        read_RemoveDefinition_args_fields iprot record
read_RemoveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_args_fields iprot (RemoveDefinition_args{f_RemoveDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_result = RemoveDefinition_result{f_RemoveDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_result_missingFields record  
write_RemoveDefinition_result oprot record = do
  writeStructBegin oprot "RemoveDefinition_result"
  case f_RemoveDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_result_fields iprot record = do
  (_,_t181,_id182) <- readFieldBegin iprot
  if _t181 == T_STOP then return record else
    case _id182 of 
      1 -> if _t181 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveDefinition_result_fields iprot record{f_RemoveDefinition_result_missingFields=Just s}
        else do
          skip iprot _t181
          read_RemoveDefinition_result_fields iprot record
      _ -> do
        skip iprot _t181
        readFieldEnd iprot
        read_RemoveDefinition_result_fields iprot record
read_RemoveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_result_fields iprot (RemoveDefinition_result{f_RemoveDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_args = DefinitionChildren_args{f_DefinitionChildren_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_args_definition record  
write_DefinitionChildren_args oprot record = do
  writeStructBegin oprot "DefinitionChildren_args"
  case f_DefinitionChildren_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_args_fields iprot record = do
  (_,_t186,_id187) <- readFieldBegin iprot
  if _t186 == T_STOP then return record else
    case _id187 of 
      1 -> if _t186 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_definition=Just s}
        else do
          skip iprot _t186
          read_DefinitionChildren_args_fields iprot record
      _ -> do
        skip iprot _t186
        readFieldEnd iprot
        read_DefinitionChildren_args_fields iprot record
read_DefinitionChildren_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_args_fields iprot (DefinitionChildren_args{f_DefinitionChildren_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_result = DefinitionChildren_result{f_DefinitionChildren_result_success :: Maybe (Vector.Vector Defs_Types.Definition),f_DefinitionChildren_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_result_success record   `hashWithSalt` f_DefinitionChildren_result_missingFields record  
write_DefinitionChildren_result oprot record = do
  writeStructBegin oprot "DefinitionChildren_result"
  case f_DefinitionChildren_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter190 -> Defs_Types.write_Definition oprot _viter190) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_DefinitionChildren_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_result_fields iprot record = do
  (_,_t192,_id193) <- readFieldBegin iprot
  if _t192 == T_STOP then return record else
    case _id193 of 
      0 -> if _t192 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Definition iprot)) in do {(_etype197,_size194) <- readListBegin iprot; f _size194})
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_success=Just s}
        else do
          skip iprot _t192
          read_DefinitionChildren_result_fields iprot record
      1 -> if _t192 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_missingFields=Just s}
        else do
          skip iprot _t192
          read_DefinitionChildren_result_fields iprot record
      _ -> do
        skip iprot _t192
        readFieldEnd iprot
        read_DefinitionChildren_result_fields iprot record
read_DefinitionChildren_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_result_fields iprot (DefinitionChildren_result{f_DefinitionChildren_result_success=Nothing,f_DefinitionChildren_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_args = DefinitionParent_args{f_DefinitionParent_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_args_definition record  
write_DefinitionParent_args oprot record = do
  writeStructBegin oprot "DefinitionParent_args"
  case f_DefinitionParent_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_args_fields iprot record = do
  (_,_t202,_id203) <- readFieldBegin iprot
  if _t202 == T_STOP then return record else
    case _id203 of 
      1 -> if _t202 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_definition=Just s}
        else do
          skip iprot _t202
          read_DefinitionParent_args_fields iprot record
      _ -> do
        skip iprot _t202
        readFieldEnd iprot
        read_DefinitionParent_args_fields iprot record
read_DefinitionParent_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_args_fields iprot (DefinitionParent_args{f_DefinitionParent_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_result = DefinitionParent_result{f_DefinitionParent_result_success :: Maybe Defs_Types.Definition,f_DefinitionParent_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_result_success record   `hashWithSalt` f_DefinitionParent_result_missingFields record  
write_DefinitionParent_result oprot record = do
  writeStructBegin oprot "DefinitionParent_result"
  case f_DefinitionParent_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_result_fields iprot record = do
  (_,_t207,_id208) <- readFieldBegin iprot
  if _t207 == T_STOP then return record else
    case _id208 of 
      0 -> if _t207 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_success=Just s}
        else do
          skip iprot _t207
          read_DefinitionParent_result_fields iprot record
      1 -> if _t207 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_missingFields=Just s}
        else do
          skip iprot _t207
          read_DefinitionParent_result_fields iprot record
      _ -> do
        skip iprot _t207
        readFieldEnd iprot
        read_DefinitionParent_result_fields iprot record
read_DefinitionParent_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_result_fields iprot (DefinitionParent_result{f_DefinitionParent_result_success=Nothing,f_DefinitionParent_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_args = NewTypeModule_args{f_NewTypeModule_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_args_name record  
write_NewTypeModule_args oprot record = do
  writeStructBegin oprot "NewTypeModule_args"
  case f_NewTypeModule_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_args_fields iprot record = do
  (_,_t212,_id213) <- readFieldBegin iprot
  if _t212 == T_STOP then return record else
    case _id213 of 
      1 -> if _t212 == T_STRING then do
        s <- readString iprot
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_name=Just s}
        else do
          skip iprot _t212
          read_NewTypeModule_args_fields iprot record
      _ -> do
        skip iprot _t212
        readFieldEnd iprot
        read_NewTypeModule_args_fields iprot record
read_NewTypeModule_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_args_fields iprot (NewTypeModule_args{f_NewTypeModule_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_result = NewTypeModule_result{f_NewTypeModule_result_success :: Maybe Types_Types.Type,f_NewTypeModule_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_result_success record   `hashWithSalt` f_NewTypeModule_result_missingFields record  
write_NewTypeModule_result oprot record = do
  writeStructBegin oprot "NewTypeModule_result"
  case f_NewTypeModule_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeModule_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_result_fields iprot record = do
  (_,_t217,_id218) <- readFieldBegin iprot
  if _t217 == T_STOP then return record else
    case _id218 of 
      0 -> if _t217 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_success=Just s}
        else do
          skip iprot _t217
          read_NewTypeModule_result_fields iprot record
      1 -> if _t217 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_missingFields=Just s}
        else do
          skip iprot _t217
          read_NewTypeModule_result_fields iprot record
      _ -> do
        skip iprot _t217
        readFieldEnd iprot
        read_NewTypeModule_result_fields iprot record
read_NewTypeModule_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_result_fields iprot (NewTypeModule_result{f_NewTypeModule_result_success=Nothing,f_NewTypeModule_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_args = NewTypeClass_args{f_NewTypeClass_args_name :: Maybe Text,f_NewTypeClass_args_typeparams :: Maybe (Vector.Vector Text),f_NewTypeClass_args_params :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_args_name record   `hashWithSalt` f_NewTypeClass_args_typeparams record   `hashWithSalt` f_NewTypeClass_args_params record  
write_NewTypeClass_args oprot record = do
  writeStructBegin oprot "NewTypeClass_args"
  case f_NewTypeClass_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_args_typeparams record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("typeparams",T_LIST,2)
    (let f = Vector.mapM_ (\_viter221 -> writeString oprot _viter221) in do {writeListBegin oprot (T_STRING,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NewTypeClass_args_params record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("params",T_LIST,3)
    (let f = Vector.mapM_ (\_viter222 -> Types_Types.write_Type oprot _viter222) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_args_fields iprot record = do
  (_,_t224,_id225) <- readFieldBegin iprot
  if _t224 == T_STOP then return record else
    case _id225 of 
      1 -> if _t224 == T_STRING then do
        s <- readString iprot
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_name=Just s}
        else do
          skip iprot _t224
          read_NewTypeClass_args_fields iprot record
      2 -> if _t224 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readString iprot) in do {(_etype229,_size226) <- readListBegin iprot; f _size226})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_typeparams=Just s}
        else do
          skip iprot _t224
          read_NewTypeClass_args_fields iprot record
      3 -> if _t224 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype234,_size231) <- readListBegin iprot; f _size231})
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_params=Just s}
        else do
          skip iprot _t224
          read_NewTypeClass_args_fields iprot record
      _ -> do
        skip iprot _t224
        readFieldEnd iprot
        read_NewTypeClass_args_fields iprot record
read_NewTypeClass_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_args_fields iprot (NewTypeClass_args{f_NewTypeClass_args_name=Nothing,f_NewTypeClass_args_typeparams=Nothing,f_NewTypeClass_args_params=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_result = NewTypeClass_result{f_NewTypeClass_result_success :: Maybe Types_Types.Type,f_NewTypeClass_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_result_success record   `hashWithSalt` f_NewTypeClass_result_missingFields record  
write_NewTypeClass_result oprot record = do
  writeStructBegin oprot "NewTypeClass_result"
  case f_NewTypeClass_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_result_fields iprot record = do
  (_,_t239,_id240) <- readFieldBegin iprot
  if _t239 == T_STOP then return record else
    case _id240 of 
      0 -> if _t239 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_success=Just s}
        else do
          skip iprot _t239
          read_NewTypeClass_result_fields iprot record
      1 -> if _t239 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_missingFields=Just s}
        else do
          skip iprot _t239
          read_NewTypeClass_result_fields iprot record
      _ -> do
        skip iprot _t239
        readFieldEnd iprot
        read_NewTypeClass_result_fields iprot record
read_NewTypeClass_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_result_fields iprot (NewTypeClass_result{f_NewTypeClass_result_success=Nothing,f_NewTypeClass_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_args = NewTypeFunction_args{f_NewTypeFunction_args_name :: Maybe Text,f_NewTypeFunction_args_inputs :: Maybe Types_Types.Type,f_NewTypeFunction_args_outputs :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_args_name record   `hashWithSalt` f_NewTypeFunction_args_inputs record   `hashWithSalt` f_NewTypeFunction_args_outputs record  
write_NewTypeFunction_args oprot record = do
  writeStructBegin oprot "NewTypeFunction_args"
  case f_NewTypeFunction_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_inputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inputs",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_outputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("outputs",T_STRUCT,3)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_args_fields iprot record = do
  (_,_t244,_id245) <- readFieldBegin iprot
  if _t244 == T_STOP then return record else
    case _id245 of 
      1 -> if _t244 == T_STRING then do
        s <- readString iprot
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_name=Just s}
        else do
          skip iprot _t244
          read_NewTypeFunction_args_fields iprot record
      2 -> if _t244 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_inputs=Just s}
        else do
          skip iprot _t244
          read_NewTypeFunction_args_fields iprot record
      3 -> if _t244 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_outputs=Just s}
        else do
          skip iprot _t244
          read_NewTypeFunction_args_fields iprot record
      _ -> do
        skip iprot _t244
        readFieldEnd iprot
        read_NewTypeFunction_args_fields iprot record
read_NewTypeFunction_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_args_fields iprot (NewTypeFunction_args{f_NewTypeFunction_args_name=Nothing,f_NewTypeFunction_args_inputs=Nothing,f_NewTypeFunction_args_outputs=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_result = NewTypeFunction_result{f_NewTypeFunction_result_success :: Maybe Types_Types.Type,f_NewTypeFunction_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_result_success record   `hashWithSalt` f_NewTypeFunction_result_missingFields record  
write_NewTypeFunction_result oprot record = do
  writeStructBegin oprot "NewTypeFunction_result"
  case f_NewTypeFunction_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_result_fields iprot record = do
  (_,_t249,_id250) <- readFieldBegin iprot
  if _t249 == T_STOP then return record else
    case _id250 of 
      0 -> if _t249 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_success=Just s}
        else do
          skip iprot _t249
          read_NewTypeFunction_result_fields iprot record
      1 -> if _t249 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_missingFields=Just s}
        else do
          skip iprot _t249
          read_NewTypeFunction_result_fields iprot record
      _ -> do
        skip iprot _t249
        readFieldEnd iprot
        read_NewTypeFunction_result_fields iprot record
read_NewTypeFunction_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_result_fields iprot (NewTypeFunction_result{f_NewTypeFunction_result_success=Nothing,f_NewTypeFunction_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeUdefined_args = NewTypeUdefined_args deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_args where
  hashWithSalt salt record = salt  
write_NewTypeUdefined_args oprot record = do
  writeStructBegin oprot "NewTypeUdefined_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_args_fields iprot record = do
  (_,_t254,_id255) <- readFieldBegin iprot
  if _t254 == T_STOP then return record else
    case _id255 of 
      _ -> do
        skip iprot _t254
        readFieldEnd iprot
        read_NewTypeUdefined_args_fields iprot record
read_NewTypeUdefined_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_args_fields iprot (NewTypeUdefined_args{})
  readStructEnd iprot
  return record
data NewTypeUdefined_result = NewTypeUdefined_result{f_NewTypeUdefined_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeUdefined_result_success record  
write_NewTypeUdefined_result oprot record = do
  writeStructBegin oprot "NewTypeUdefined_result"
  case f_NewTypeUdefined_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_result_fields iprot record = do
  (_,_t259,_id260) <- readFieldBegin iprot
  if _t259 == T_STOP then return record else
    case _id260 of 
      0 -> if _t259 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_success=Just s}
        else do
          skip iprot _t259
          read_NewTypeUdefined_result_fields iprot record
      _ -> do
        skip iprot _t259
        readFieldEnd iprot
        read_NewTypeUdefined_result_fields iprot record
read_NewTypeUdefined_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_result_fields iprot (NewTypeUdefined_result{f_NewTypeUdefined_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_args = NewTypeNamed_args{f_NewTypeNamed_args_name :: Maybe Text,f_NewTypeNamed_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_args_name record   `hashWithSalt` f_NewTypeNamed_args_type record  
write_NewTypeNamed_args oprot record = do
  writeStructBegin oprot "NewTypeNamed_args"
  case f_NewTypeNamed_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_args_fields iprot record = do
  (_,_t264,_id265) <- readFieldBegin iprot
  if _t264 == T_STOP then return record else
    case _id265 of 
      1 -> if _t264 == T_STRING then do
        s <- readString iprot
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_name=Just s}
        else do
          skip iprot _t264
          read_NewTypeNamed_args_fields iprot record
      2 -> if _t264 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_type=Just s}
        else do
          skip iprot _t264
          read_NewTypeNamed_args_fields iprot record
      _ -> do
        skip iprot _t264
        readFieldEnd iprot
        read_NewTypeNamed_args_fields iprot record
read_NewTypeNamed_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_args_fields iprot (NewTypeNamed_args{f_NewTypeNamed_args_name=Nothing,f_NewTypeNamed_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_result = NewTypeNamed_result{f_NewTypeNamed_result_success :: Maybe Types_Types.Type,f_NewTypeNamed_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_result_success record   `hashWithSalt` f_NewTypeNamed_result_missingFields record  
write_NewTypeNamed_result oprot record = do
  writeStructBegin oprot "NewTypeNamed_result"
  case f_NewTypeNamed_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_result_fields iprot record = do
  (_,_t269,_id270) <- readFieldBegin iprot
  if _t269 == T_STOP then return record else
    case _id270 of 
      0 -> if _t269 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_success=Just s}
        else do
          skip iprot _t269
          read_NewTypeNamed_result_fields iprot record
      1 -> if _t269 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_missingFields=Just s}
        else do
          skip iprot _t269
          read_NewTypeNamed_result_fields iprot record
      _ -> do
        skip iprot _t269
        readFieldEnd iprot
        read_NewTypeNamed_result_fields iprot record
read_NewTypeNamed_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_result_fields iprot (NewTypeNamed_result{f_NewTypeNamed_result_success=Nothing,f_NewTypeNamed_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_args = NewTypeVariable_args{f_NewTypeVariable_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_args_name record  
write_NewTypeVariable_args oprot record = do
  writeStructBegin oprot "NewTypeVariable_args"
  case f_NewTypeVariable_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_args_fields iprot record = do
  (_,_t274,_id275) <- readFieldBegin iprot
  if _t274 == T_STOP then return record else
    case _id275 of 
      1 -> if _t274 == T_STRING then do
        s <- readString iprot
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_name=Just s}
        else do
          skip iprot _t274
          read_NewTypeVariable_args_fields iprot record
      _ -> do
        skip iprot _t274
        readFieldEnd iprot
        read_NewTypeVariable_args_fields iprot record
read_NewTypeVariable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_args_fields iprot (NewTypeVariable_args{f_NewTypeVariable_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_result = NewTypeVariable_result{f_NewTypeVariable_result_success :: Maybe Types_Types.Type,f_NewTypeVariable_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_result_success record   `hashWithSalt` f_NewTypeVariable_result_missingFields record  
write_NewTypeVariable_result oprot record = do
  writeStructBegin oprot "NewTypeVariable_result"
  case f_NewTypeVariable_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeVariable_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_result_fields iprot record = do
  (_,_t279,_id280) <- readFieldBegin iprot
  if _t279 == T_STOP then return record else
    case _id280 of 
      0 -> if _t279 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_success=Just s}
        else do
          skip iprot _t279
          read_NewTypeVariable_result_fields iprot record
      1 -> if _t279 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_missingFields=Just s}
        else do
          skip iprot _t279
          read_NewTypeVariable_result_fields iprot record
      _ -> do
        skip iprot _t279
        readFieldEnd iprot
        read_NewTypeVariable_result_fields iprot record
read_NewTypeVariable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_result_fields iprot (NewTypeVariable_result{f_NewTypeVariable_result_success=Nothing,f_NewTypeVariable_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_args = NewTypeList_args{f_NewTypeList_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_args_type record  
write_NewTypeList_args oprot record = do
  writeStructBegin oprot "NewTypeList_args"
  case f_NewTypeList_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_args_fields iprot record = do
  (_,_t284,_id285) <- readFieldBegin iprot
  if _t284 == T_STOP then return record else
    case _id285 of 
      1 -> if _t284 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_args_fields iprot record{f_NewTypeList_args_type=Just s}
        else do
          skip iprot _t284
          read_NewTypeList_args_fields iprot record
      _ -> do
        skip iprot _t284
        readFieldEnd iprot
        read_NewTypeList_args_fields iprot record
read_NewTypeList_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_args_fields iprot (NewTypeList_args{f_NewTypeList_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_result = NewTypeList_result{f_NewTypeList_result_success :: Maybe Types_Types.Type,f_NewTypeList_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_result_success record   `hashWithSalt` f_NewTypeList_result_missingFields record  
write_NewTypeList_result oprot record = do
  writeStructBegin oprot "NewTypeList_result"
  case f_NewTypeList_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeList_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_result_fields iprot record = do
  (_,_t289,_id290) <- readFieldBegin iprot
  if _t289 == T_STOP then return record else
    case _id290 of 
      0 -> if _t289 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_success=Just s}
        else do
          skip iprot _t289
          read_NewTypeList_result_fields iprot record
      1 -> if _t289 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_missingFields=Just s}
        else do
          skip iprot _t289
          read_NewTypeList_result_fields iprot record
      _ -> do
        skip iprot _t289
        readFieldEnd iprot
        read_NewTypeList_result_fields iprot record
read_NewTypeList_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_result_fields iprot (NewTypeList_result{f_NewTypeList_result_success=Nothing,f_NewTypeList_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_args = NewTypeTuple_args{f_NewTypeTuple_args_types :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_args_types record  
write_NewTypeTuple_args oprot record = do
  writeStructBegin oprot "NewTypeTuple_args"
  case f_NewTypeTuple_args_types record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("types",T_LIST,1)
    (let f = Vector.mapM_ (\_viter293 -> Types_Types.write_Type oprot _viter293) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_args_fields iprot record = do
  (_,_t295,_id296) <- readFieldBegin iprot
  if _t295 == T_STOP then return record else
    case _id296 of 
      1 -> if _t295 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype300,_size297) <- readListBegin iprot; f _size297})
        read_NewTypeTuple_args_fields iprot record{f_NewTypeTuple_args_types=Just s}
        else do
          skip iprot _t295
          read_NewTypeTuple_args_fields iprot record
      _ -> do
        skip iprot _t295
        readFieldEnd iprot
        read_NewTypeTuple_args_fields iprot record
read_NewTypeTuple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_args_fields iprot (NewTypeTuple_args{f_NewTypeTuple_args_types=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_result = NewTypeTuple_result{f_NewTypeTuple_result_success :: Maybe Types_Types.Type,f_NewTypeTuple_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_result_success record   `hashWithSalt` f_NewTypeTuple_result_missingFields record  
write_NewTypeTuple_result oprot record = do
  writeStructBegin oprot "NewTypeTuple_result"
  case f_NewTypeTuple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeTuple_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_result_fields iprot record = do
  (_,_t305,_id306) <- readFieldBegin iprot
  if _t305 == T_STOP then return record else
    case _id306 of 
      0 -> if _t305 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_success=Just s}
        else do
          skip iprot _t305
          read_NewTypeTuple_result_fields iprot record
      1 -> if _t305 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_missingFields=Just s}
        else do
          skip iprot _t305
          read_NewTypeTuple_result_fields iprot record
      _ -> do
        skip iprot _t305
        readFieldEnd iprot
        read_NewTypeTuple_result_fields iprot record
read_NewTypeTuple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_result_fields iprot (NewTypeTuple_result{f_NewTypeTuple_result_success=Nothing,f_NewTypeTuple_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Graph_args = Graph_args{f_Graph_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable Graph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_args_definition record  
write_Graph_args oprot record = do
  writeStructBegin oprot "Graph_args"
  case f_Graph_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_args_fields iprot record = do
  (_,_t310,_id311) <- readFieldBegin iprot
  if _t310 == T_STOP then return record else
    case _id311 of 
      1 -> if _t310 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_Graph_args_fields iprot record{f_Graph_args_definition=Just s}
        else do
          skip iprot _t310
          read_Graph_args_fields iprot record
      _ -> do
        skip iprot _t310
        readFieldEnd iprot
        read_Graph_args_fields iprot record
read_Graph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_args_fields iprot (Graph_args{f_Graph_args_definition=Nothing})
  readStructEnd iprot
  return record
data Graph_result = Graph_result{f_Graph_result_success :: Maybe Graph_Types.Graph,f_Graph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Graph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_result_success record   `hashWithSalt` f_Graph_result_missingFields record  
write_Graph_result oprot record = do
  writeStructBegin oprot "Graph_result"
  case f_Graph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Graph oprot _v
    writeFieldEnd oprot}
  case f_Graph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_result_fields iprot record = do
  (_,_t315,_id316) <- readFieldBegin iprot
  if _t315 == T_STOP then return record else
    case _id316 of 
      0 -> if _t315 == T_STRUCT then do
        s <- (read_Graph iprot)
        read_Graph_result_fields iprot record{f_Graph_result_success=Just s}
        else do
          skip iprot _t315
          read_Graph_result_fields iprot record
      1 -> if _t315 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Graph_result_fields iprot record{f_Graph_result_missingFields=Just s}
        else do
          skip iprot _t315
          read_Graph_result_fields iprot record
      _ -> do
        skip iprot _t315
        readFieldEnd iprot
        read_Graph_result_fields iprot record
read_Graph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_result_fields iprot (Graph_result{f_Graph_result_success=Nothing,f_Graph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddNode_args = AddNode_args{f_AddNode_args_node :: Maybe Graph_Types.Node,f_AddNode_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable AddNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_args_node record   `hashWithSalt` f_AddNode_args_definition record  
write_AddNode_args oprot record = do
  writeStructBegin oprot "AddNode_args"
  case f_AddNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_args_fields iprot record = do
  (_,_t320,_id321) <- readFieldBegin iprot
  if _t320 == T_STOP then return record else
    case _id321 of 
      1 -> if _t320 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_node=Just s}
        else do
          skip iprot _t320
          read_AddNode_args_fields iprot record
      2 -> if _t320 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_definition=Just s}
        else do
          skip iprot _t320
          read_AddNode_args_fields iprot record
      _ -> do
        skip iprot _t320
        readFieldEnd iprot
        read_AddNode_args_fields iprot record
read_AddNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_args_fields iprot (AddNode_args{f_AddNode_args_node=Nothing,f_AddNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data AddNode_result = AddNode_result{f_AddNode_result_success :: Maybe Graph_Types.Node,f_AddNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_result_success record   `hashWithSalt` f_AddNode_result_missingFields record  
write_AddNode_result oprot record = do
  writeStructBegin oprot "AddNode_result"
  case f_AddNode_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_result_fields iprot record = do
  (_,_t325,_id326) <- readFieldBegin iprot
  if _t325 == T_STOP then return record else
    case _id326 of 
      0 -> if _t325 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_success=Just s}
        else do
          skip iprot _t325
          read_AddNode_result_fields iprot record
      1 -> if _t325 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_missingFields=Just s}
        else do
          skip iprot _t325
          read_AddNode_result_fields iprot record
      _ -> do
        skip iprot _t325
        readFieldEnd iprot
        read_AddNode_result_fields iprot record
read_AddNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_result_fields iprot (AddNode_result{f_AddNode_result_success=Nothing,f_AddNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_args = UpdateNode_args{f_UpdateNode_args_node :: Maybe Graph_Types.Node,f_UpdateNode_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_args_node record   `hashWithSalt` f_UpdateNode_args_definition record  
write_UpdateNode_args oprot record = do
  writeStructBegin oprot "UpdateNode_args"
  case f_UpdateNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_args_fields iprot record = do
  (_,_t330,_id331) <- readFieldBegin iprot
  if _t330 == T_STOP then return record else
    case _id331 of 
      1 -> if _t330 == T_STRUCT then do
        s <- (read_Node iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_node=Just s}
        else do
          skip iprot _t330
          read_UpdateNode_args_fields iprot record
      2 -> if _t330 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_definition=Just s}
        else do
          skip iprot _t330
          read_UpdateNode_args_fields iprot record
      _ -> do
        skip iprot _t330
        readFieldEnd iprot
        read_UpdateNode_args_fields iprot record
read_UpdateNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_args_fields iprot (UpdateNode_args{f_UpdateNode_args_node=Nothing,f_UpdateNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_result = UpdateNode_result{f_UpdateNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_result_missingFields record  
write_UpdateNode_result oprot record = do
  writeStructBegin oprot "UpdateNode_result"
  case f_UpdateNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_result_fields iprot record = do
  (_,_t335,_id336) <- readFieldBegin iprot
  if _t335 == T_STOP then return record else
    case _id336 of 
      1 -> if _t335 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateNode_result_fields iprot record{f_UpdateNode_result_missingFields=Just s}
        else do
          skip iprot _t335
          read_UpdateNode_result_fields iprot record
      _ -> do
        skip iprot _t335
        readFieldEnd iprot
        read_UpdateNode_result_fields iprot record
read_UpdateNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_result_fields iprot (UpdateNode_result{f_UpdateNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_args = RemoveNode_args{f_RemoveNode_args_node :: Maybe Graph_Types.Node,f_RemoveNode_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_args_node record   `hashWithSalt` f_RemoveNode_args_definition record  
write_RemoveNode_args oprot record = do
  writeStructBegin oprot "RemoveNode_args"
  case f_RemoveNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_args_fields iprot record = do
  (_,_t340,_id341) <- readFieldBegin iprot
  if _t340 == T_STOP then return record else
    case _id341 of 
      1 -> if _t340 == T_STRUCT then do
        s <- (read_Node iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_node=Just s}
        else do
          skip iprot _t340
          read_RemoveNode_args_fields iprot record
      2 -> if _t340 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_definition=Just s}
        else do
          skip iprot _t340
          read_RemoveNode_args_fields iprot record
      _ -> do
        skip iprot _t340
        readFieldEnd iprot
        read_RemoveNode_args_fields iprot record
read_RemoveNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_args_fields iprot (RemoveNode_args{f_RemoveNode_args_node=Nothing,f_RemoveNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_result = RemoveNode_result{f_RemoveNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_result_missingFields record  
write_RemoveNode_result oprot record = do
  writeStructBegin oprot "RemoveNode_result"
  case f_RemoveNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_result_fields iprot record = do
  (_,_t345,_id346) <- readFieldBegin iprot
  if _t345 == T_STOP then return record else
    case _id346 of 
      1 -> if _t345 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveNode_result_fields iprot record{f_RemoveNode_result_missingFields=Just s}
        else do
          skip iprot _t345
          read_RemoveNode_result_fields iprot record
      _ -> do
        skip iprot _t345
        readFieldEnd iprot
        read_RemoveNode_result_fields iprot record
read_RemoveNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_result_fields iprot (RemoveNode_result{f_RemoveNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Connect_args = Connect_args{f_Connect_args_srcNode :: Maybe Graph_Types.Node,f_Connect_args_srcPort :: Maybe (Vector.Vector Int32),f_Connect_args_dstNode :: Maybe Graph_Types.Node,f_Connect_args_dstPort :: Maybe (Vector.Vector Int32),f_Connect_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable Connect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_args_srcNode record   `hashWithSalt` f_Connect_args_srcPort record   `hashWithSalt` f_Connect_args_dstNode record   `hashWithSalt` f_Connect_args_dstPort record   `hashWithSalt` f_Connect_args_definition record  
write_Connect_args oprot record = do
  writeStructBegin oprot "Connect_args"
  case f_Connect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter349 -> writeI32 oprot _viter349) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter350 -> writeI32 oprot _viter350) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_args_fields iprot record = do
  (_,_t352,_id353) <- readFieldBegin iprot
  if _t352 == T_STOP then return record else
    case _id353 of 
      1 -> if _t352 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_srcNode=Just s}
        else do
          skip iprot _t352
          read_Connect_args_fields iprot record
      2 -> if _t352 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype357,_size354) <- readListBegin iprot; f _size354})
        read_Connect_args_fields iprot record{f_Connect_args_srcPort=Just s}
        else do
          skip iprot _t352
          read_Connect_args_fields iprot record
      3 -> if _t352 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_dstNode=Just s}
        else do
          skip iprot _t352
          read_Connect_args_fields iprot record
      4 -> if _t352 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype362,_size359) <- readListBegin iprot; f _size359})
        read_Connect_args_fields iprot record{f_Connect_args_dstPort=Just s}
        else do
          skip iprot _t352
          read_Connect_args_fields iprot record
      5 -> if _t352 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_Connect_args_fields iprot record{f_Connect_args_definition=Just s}
        else do
          skip iprot _t352
          read_Connect_args_fields iprot record
      _ -> do
        skip iprot _t352
        readFieldEnd iprot
        read_Connect_args_fields iprot record
read_Connect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_args_fields iprot (Connect_args{f_Connect_args_srcNode=Nothing,f_Connect_args_srcPort=Nothing,f_Connect_args_dstNode=Nothing,f_Connect_args_dstPort=Nothing,f_Connect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Connect_result = Connect_result{f_Connect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Connect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_result_missingFields record  
write_Connect_result oprot record = do
  writeStructBegin oprot "Connect_result"
  case f_Connect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_result_fields iprot record = do
  (_,_t367,_id368) <- readFieldBegin iprot
  if _t367 == T_STOP then return record else
    case _id368 of 
      1 -> if _t367 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Connect_result_fields iprot record{f_Connect_result_missingFields=Just s}
        else do
          skip iprot _t367
          read_Connect_result_fields iprot record
      _ -> do
        skip iprot _t367
        readFieldEnd iprot
        read_Connect_result_fields iprot record
read_Connect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_result_fields iprot (Connect_result{f_Connect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Disconnect_args = Disconnect_args{f_Disconnect_args_srcNode :: Maybe Graph_Types.Node,f_Disconnect_args_srcPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_dstNode :: Maybe Graph_Types.Node,f_Disconnect_args_dstPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_definition :: Maybe Defs_Types.Definition} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_args_srcNode record   `hashWithSalt` f_Disconnect_args_srcPort record   `hashWithSalt` f_Disconnect_args_dstNode record   `hashWithSalt` f_Disconnect_args_dstPort record   `hashWithSalt` f_Disconnect_args_definition record  
write_Disconnect_args oprot record = do
  writeStructBegin oprot "Disconnect_args"
  case f_Disconnect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter371 -> writeI32 oprot _viter371) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter372 -> writeI32 oprot _viter372) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_Definition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_args_fields iprot record = do
  (_,_t374,_id375) <- readFieldBegin iprot
  if _t374 == T_STOP then return record else
    case _id375 of 
      1 -> if _t374 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcNode=Just s}
        else do
          skip iprot _t374
          read_Disconnect_args_fields iprot record
      2 -> if _t374 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype379,_size376) <- readListBegin iprot; f _size376})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcPort=Just s}
        else do
          skip iprot _t374
          read_Disconnect_args_fields iprot record
      3 -> if _t374 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstNode=Just s}
        else do
          skip iprot _t374
          read_Disconnect_args_fields iprot record
      4 -> if _t374 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype384,_size381) <- readListBegin iprot; f _size381})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstPort=Just s}
        else do
          skip iprot _t374
          read_Disconnect_args_fields iprot record
      5 -> if _t374 == T_STRUCT then do
        s <- (read_Definition iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_definition=Just s}
        else do
          skip iprot _t374
          read_Disconnect_args_fields iprot record
      _ -> do
        skip iprot _t374
        readFieldEnd iprot
        read_Disconnect_args_fields iprot record
read_Disconnect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_args_fields iprot (Disconnect_args{f_Disconnect_args_srcNode=Nothing,f_Disconnect_args_srcPort=Nothing,f_Disconnect_args_dstNode=Nothing,f_Disconnect_args_dstPort=Nothing,f_Disconnect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Disconnect_result = Disconnect_result{f_Disconnect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_result_missingFields record  
write_Disconnect_result oprot record = do
  writeStructBegin oprot "Disconnect_result"
  case f_Disconnect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_result_fields iprot record = do
  (_,_t389,_id390) <- readFieldBegin iprot
  if _t389 == T_STOP then return record else
    case _id390 of 
      1 -> if _t389 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Disconnect_result_fields iprot record{f_Disconnect_result_missingFields=Just s}
        else do
          skip iprot _t389
          read_Disconnect_result_fields iprot record
      _ -> do
        skip iprot _t389
        readFieldEnd iprot
        read_Disconnect_result_fields iprot record
read_Disconnect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_result_fields iprot (Disconnect_result{f_Disconnect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Ping_args = Ping_args deriving (Show,Eq,Typeable)
instance Hashable Ping_args where
  hashWithSalt salt record = salt  
write_Ping_args oprot record = do
  writeStructBegin oprot "Ping_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_args_fields iprot record = do
  (_,_t394,_id395) <- readFieldBegin iprot
  if _t394 == T_STOP then return record else
    case _id395 of 
      _ -> do
        skip iprot _t394
        readFieldEnd iprot
        read_Ping_args_fields iprot record
read_Ping_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_args_fields iprot (Ping_args{})
  readStructEnd iprot
  return record
data Ping_result = Ping_result deriving (Show,Eq,Typeable)
instance Hashable Ping_result where
  hashWithSalt salt record = salt  
write_Ping_result oprot record = do
  writeStructBegin oprot "Ping_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_result_fields iprot record = do
  (_,_t399,_id400) <- readFieldBegin iprot
  if _t399 == T_STOP then return record else
    case _id400 of 
      _ -> do
        skip iprot _t399
        readFieldEnd iprot
        read_Ping_result_fields iprot record
read_Ping_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_result_fields iprot (Ping_result{})
  readStructEnd iprot
  return record
process_projects (seqid, iprot, oprot, handler) = do
  args <- read_Projects_args iprot
  readMessageEnd iprot
  rs <- return (Projects_result Nothing)
  res <- (do
    res <- Iface.projects handler
    return rs{f_Projects_result_success= Just res})
  writeMessageBegin oprot ("projects", M_REPLY, seqid);
  write_Projects_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createProject (seqid, iprot, oprot, handler) = do
  args <- read_CreateProject_args iprot
  readMessageEnd iprot
  rs <- return (CreateProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createProject handler (f_CreateProject_args_project args)
      return rs{f_CreateProject_result_success= Just res})
    (\e  -> 
      return rs{f_CreateProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("createProject", M_REPLY, seqid);
  write_CreateProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_openProject (seqid, iprot, oprot, handler) = do
  args <- read_OpenProject_args iprot
  readMessageEnd iprot
  rs <- return (OpenProject_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.openProject handler (f_OpenProject_args_project args)
      return rs{f_OpenProject_result_success= Just res})
    (\e  -> 
      return rs{f_OpenProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("openProject", M_REPLY, seqid);
  write_OpenProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_closeProject (seqid, iprot, oprot, handler) = do
  args <- read_CloseProject_args iprot
  readMessageEnd iprot
  rs <- return (CloseProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.closeProject handler (f_CloseProject_args_project args)
      return rs)
    (\e  -> 
      return rs{f_CloseProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("closeProject", M_REPLY, seqid);
  write_CloseProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_setActiveProject (seqid, iprot, oprot, handler) = do
  args <- read_SetActiveProject_args iprot
  readMessageEnd iprot
  rs <- return (SetActiveProject_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.setActiveProject handler (f_SetActiveProject_args_project args)
      return rs)
    (\e  -> 
      return rs{f_SetActiveProject_result_missingFields =Just e}))
  writeMessageBegin oprot ("setActiveProject", M_REPLY, seqid);
  write_SetActiveProject_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraries (seqid, iprot, oprot, handler) = do
  args <- read_Libraries_args iprot
  readMessageEnd iprot
  rs <- return (Libraries_result Nothing)
  res <- (do
    res <- Iface.libraries handler
    return rs{f_Libraries_result_success= Just res})
  writeMessageBegin oprot ("libraries", M_REPLY, seqid);
  write_Libraries_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_createLibrary (seqid, iprot, oprot, handler) = do
  args <- read_CreateLibrary_args iprot
  readMessageEnd iprot
  rs <- return (CreateLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.createLibrary handler (f_CreateLibrary_args_library args)
      return rs{f_CreateLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_CreateLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("createLibrary", M_REPLY, seqid);
  write_CreateLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_loadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_LoadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (LoadLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.loadLibrary handler (f_LoadLibrary_args_library args)
      return rs{f_LoadLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_LoadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("loadLibrary", M_REPLY, seqid);
  write_LoadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_unloadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_UnloadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (UnloadLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.unloadLibrary handler (f_UnloadLibrary_args_library args)
      return rs)
    (\e  -> 
      return rs{f_UnloadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("unloadLibrary", M_REPLY, seqid);
  write_UnloadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_storeLibrary (seqid, iprot, oprot, handler) = do
  args <- read_StoreLibrary_args iprot
  readMessageEnd iprot
  rs <- return (StoreLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.storeLibrary handler (f_StoreLibrary_args_library args)
      return rs)
    (\e  -> 
      return rs{f_StoreLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("storeLibrary", M_REPLY, seqid);
  write_StoreLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraryRootDef (seqid, iprot, oprot, handler) = do
  args <- read_LibraryRootDef_args iprot
  readMessageEnd iprot
  rs <- return (LibraryRootDef_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraryRootDef handler (f_LibraryRootDef_args_library args)
      return rs{f_LibraryRootDef_result_success= Just res})
    (\e  -> 
      return rs{f_LibraryRootDef_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraryRootDef", M_REPLY, seqid);
  write_LibraryRootDef_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_defsGraph (seqid, iprot, oprot, handler) = do
  args <- read_DefsGraph_args iprot
  readMessageEnd iprot
  rs <- return (DefsGraph_result Nothing)
  res <- (do
    res <- Iface.defsGraph handler
    return rs{f_DefsGraph_result_success= Just res})
  writeMessageBegin oprot ("defsGraph", M_REPLY, seqid);
  write_DefsGraph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newDefinition (seqid, iprot, oprot, handler) = do
  args <- read_NewDefinition_args iprot
  readMessageEnd iprot
  rs <- return (NewDefinition_result Nothing)
  res <- (do
    res <- Iface.newDefinition handler (f_NewDefinition_args_type args) (f_NewDefinition_args_imports args) (f_NewDefinition_args_flags args) (f_NewDefinition_args_attrs args)
    return rs{f_NewDefinition_result_success= Just res})
  writeMessageBegin oprot ("newDefinition", M_REPLY, seqid);
  write_NewDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addDefinition (seqid, iprot, oprot, handler) = do
  args <- read_AddDefinition_args iprot
  readMessageEnd iprot
  rs <- return (AddDefinition_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addDefinition handler (f_AddDefinition_args_definition args) (f_AddDefinition_args_parent args)
      return rs{f_AddDefinition_result_success= Just res})
    (\e  -> 
      return rs{f_AddDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("addDefinition", M_REPLY, seqid);
  write_AddDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateDefinition (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDefinition_args iprot
  readMessageEnd iprot
  rs <- return (UpdateDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateDefinition handler (f_UpdateDefinition_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_UpdateDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateDefinition", M_REPLY, seqid);
  write_UpdateDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeDefinition (seqid, iprot, oprot, handler) = do
  args <- read_RemoveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (RemoveDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeDefinition handler (f_RemoveDefinition_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_RemoveDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeDefinition", M_REPLY, seqid);
  write_RemoveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionChildren (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionChildren_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionChildren_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionChildren handler (f_DefinitionChildren_args_definition args)
      return rs{f_DefinitionChildren_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionChildren_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionChildren", M_REPLY, seqid);
  write_DefinitionChildren_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionParent (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionParent_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionParent_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionParent handler (f_DefinitionParent_args_definition args)
      return rs{f_DefinitionParent_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionParent_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionParent", M_REPLY, seqid);
  write_DefinitionParent_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeModule (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeModule_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeModule_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeModule handler (f_NewTypeModule_args_name args)
      return rs{f_NewTypeModule_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeModule_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeModule", M_REPLY, seqid);
  write_NewTypeModule_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeClass (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeClass_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeClass_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeClass handler (f_NewTypeClass_args_name args) (f_NewTypeClass_args_typeparams args) (f_NewTypeClass_args_params args)
      return rs{f_NewTypeClass_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeClass_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeClass", M_REPLY, seqid);
  write_NewTypeClass_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeFunction (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeFunction_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeFunction_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeFunction handler (f_NewTypeFunction_args_name args) (f_NewTypeFunction_args_inputs args) (f_NewTypeFunction_args_outputs args)
      return rs{f_NewTypeFunction_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeFunction_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeFunction", M_REPLY, seqid);
  write_NewTypeFunction_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeUdefined (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeUdefined_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeUdefined_result Nothing)
  res <- (do
    res <- Iface.newTypeUdefined handler
    return rs{f_NewTypeUdefined_result_success= Just res})
  writeMessageBegin oprot ("newTypeUdefined", M_REPLY, seqid);
  write_NewTypeUdefined_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeNamed (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeNamed_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeNamed_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeNamed handler (f_NewTypeNamed_args_name args) (f_NewTypeNamed_args_type args)
      return rs{f_NewTypeNamed_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeNamed_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeNamed", M_REPLY, seqid);
  write_NewTypeNamed_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeVariable (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeVariable_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeVariable_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeVariable handler (f_NewTypeVariable_args_name args)
      return rs{f_NewTypeVariable_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeVariable_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeVariable", M_REPLY, seqid);
  write_NewTypeVariable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeList (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeList_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeList_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeList handler (f_NewTypeList_args_type args)
      return rs{f_NewTypeList_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeList_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeList", M_REPLY, seqid);
  write_NewTypeList_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeTuple (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeTuple_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeTuple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeTuple handler (f_NewTypeTuple_args_types args)
      return rs{f_NewTypeTuple_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeTuple_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeTuple", M_REPLY, seqid);
  write_NewTypeTuple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_graph (seqid, iprot, oprot, handler) = do
  args <- read_Graph_args iprot
  readMessageEnd iprot
  rs <- return (Graph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.graph handler (f_Graph_args_definition args)
      return rs{f_Graph_result_success= Just res})
    (\e  -> 
      return rs{f_Graph_result_missingFields =Just e}))
  writeMessageBegin oprot ("graph", M_REPLY, seqid);
  write_Graph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addNode (seqid, iprot, oprot, handler) = do
  args <- read_AddNode_args iprot
  readMessageEnd iprot
  rs <- return (AddNode_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addNode handler (f_AddNode_args_node args) (f_AddNode_args_definition args)
      return rs{f_AddNode_result_success= Just res})
    (\e  -> 
      return rs{f_AddNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("addNode", M_REPLY, seqid);
  write_AddNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateNode (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNode_args iprot
  readMessageEnd iprot
  rs <- return (UpdateNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateNode handler (f_UpdateNode_args_node args) (f_UpdateNode_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_UpdateNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateNode", M_REPLY, seqid);
  write_UpdateNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNode (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNode_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeNode handler (f_RemoveNode_args_node args) (f_RemoveNode_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_RemoveNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeNode", M_REPLY, seqid);
  write_RemoveNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_connect (seqid, iprot, oprot, handler) = do
  args <- read_Connect_args iprot
  readMessageEnd iprot
  rs <- return (Connect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.connect handler (f_Connect_args_srcNode args) (f_Connect_args_srcPort args) (f_Connect_args_dstNode args) (f_Connect_args_dstPort args) (f_Connect_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_Connect_result_missingFields =Just e}))
  writeMessageBegin oprot ("connect", M_REPLY, seqid);
  write_Connect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disconnect (seqid, iprot, oprot, handler) = do
  args <- read_Disconnect_args iprot
  readMessageEnd iprot
  rs <- return (Disconnect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.disconnect handler (f_Disconnect_args_srcNode args) (f_Disconnect_args_srcPort args) (f_Disconnect_args_dstNode args) (f_Disconnect_args_dstPort args) (f_Disconnect_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_Disconnect_result_missingFields =Just e}))
  writeMessageBegin oprot ("disconnect", M_REPLY, seqid);
  write_Disconnect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  readMessageEnd iprot
  rs <- return (Ping_result)
  res <- (do
    Iface.ping handler
    return rs)
  writeMessageBegin oprot ("ping", M_REPLY, seqid);
  write_Ping_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "projects" -> process_projects (seqid,iprot,oprot,handler)
  "createProject" -> process_createProject (seqid,iprot,oprot,handler)
  "openProject" -> process_openProject (seqid,iprot,oprot,handler)
  "closeProject" -> process_closeProject (seqid,iprot,oprot,handler)
  "setActiveProject" -> process_setActiveProject (seqid,iprot,oprot,handler)
  "libraries" -> process_libraries (seqid,iprot,oprot,handler)
  "createLibrary" -> process_createLibrary (seqid,iprot,oprot,handler)
  "loadLibrary" -> process_loadLibrary (seqid,iprot,oprot,handler)
  "unloadLibrary" -> process_unloadLibrary (seqid,iprot,oprot,handler)
  "storeLibrary" -> process_storeLibrary (seqid,iprot,oprot,handler)
  "libraryRootDef" -> process_libraryRootDef (seqid,iprot,oprot,handler)
  "defsGraph" -> process_defsGraph (seqid,iprot,oprot,handler)
  "newDefinition" -> process_newDefinition (seqid,iprot,oprot,handler)
  "addDefinition" -> process_addDefinition (seqid,iprot,oprot,handler)
  "updateDefinition" -> process_updateDefinition (seqid,iprot,oprot,handler)
  "removeDefinition" -> process_removeDefinition (seqid,iprot,oprot,handler)
  "definitionChildren" -> process_definitionChildren (seqid,iprot,oprot,handler)
  "definitionParent" -> process_definitionParent (seqid,iprot,oprot,handler)
  "newTypeModule" -> process_newTypeModule (seqid,iprot,oprot,handler)
  "newTypeClass" -> process_newTypeClass (seqid,iprot,oprot,handler)
  "newTypeFunction" -> process_newTypeFunction (seqid,iprot,oprot,handler)
  "newTypeUdefined" -> process_newTypeUdefined (seqid,iprot,oprot,handler)
  "newTypeNamed" -> process_newTypeNamed (seqid,iprot,oprot,handler)
  "newTypeVariable" -> process_newTypeVariable (seqid,iprot,oprot,handler)
  "newTypeList" -> process_newTypeList (seqid,iprot,oprot,handler)
  "newTypeTuple" -> process_newTypeTuple (seqid,iprot,oprot,handler)
  "graph" -> process_graph (seqid,iprot,oprot,handler)
  "addNode" -> process_addNode (seqid,iprot,oprot,handler)
  "updateNode" -> process_updateNode (seqid,iprot,oprot,handler)
  "removeNode" -> process_removeNode (seqid,iprot,oprot,handler)
  "connect" -> process_connect (seqid,iprot,oprot,handler)
  "disconnect" -> process_disconnect (seqid,iprot,oprot,handler)
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
