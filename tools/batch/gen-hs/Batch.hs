{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()

import  Attrs_Types
import  Defs_Types
import  Graph_Types
import  Libs_Types
import  Types_Types


import Batch_Types
import qualified Batch_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Libraries_args = Libraries_args deriving (Show,Eq,Typeable)
instance Hashable Libraries_args where
  hashWithSalt salt record = salt  
write_Libraries_args oprot record = do
  writeStructBegin oprot "Libraries_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_args_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Libraries_args_fields iprot record
read_Libraries_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_args_fields iprot (Libraries_args{})
  readStructEnd iprot
  return record
data Libraries_result = Libraries_result{f_Libraries_result_success :: Maybe (Vector.Vector Libs_Types.Library)} deriving (Show,Eq,Typeable)
instance Hashable Libraries_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_result_success record  
write_Libraries_result oprot record = do
  writeStructBegin oprot "Libraries_result"
  case f_Libraries_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter12 -> Libs_Types.write_Library oprot _viter12) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_result_fields iprot record = do
  (_,_t14,_id15) <- readFieldBegin iprot
  if _t14 == T_STOP then return record else
    case _id15 of 
      0 -> if _t14 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Library iprot)) in do {(_etype19,_size16) <- readListBegin iprot; f _size16})
        read_Libraries_result_fields iprot record{f_Libraries_result_success=Just s}
        else do
          skip iprot _t14
          read_Libraries_result_fields iprot record
      _ -> do
        skip iprot _t14
        readFieldEnd iprot
        read_Libraries_result_fields iprot record
read_Libraries_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_result_fields iprot (Libraries_result{f_Libraries_result_success=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_args = LoadLibrary_args{f_LoadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_args_library record  
write_LoadLibrary_args oprot record = do
  writeStructBegin oprot "LoadLibrary_args"
  case f_LoadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_args_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_library=Just s}
        else do
          skip iprot _t24
          read_LoadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_LoadLibrary_args_fields iprot record
read_LoadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_args_fields iprot (LoadLibrary_args{f_LoadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_result = LoadLibrary_result{f_LoadLibrary_result_success :: Maybe Libs_Types.Library,f_LoadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_result_success record   `hashWithSalt` f_LoadLibrary_result_missingFields record  
write_LoadLibrary_result oprot record = do
  writeStructBegin oprot "LoadLibrary_result"
  case f_LoadLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_result_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      0 -> if _t29 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_success=Just s}
        else do
          skip iprot _t29
          read_LoadLibrary_result_fields iprot record
      1 -> if _t29 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t29
          read_LoadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_LoadLibrary_result_fields iprot record
read_LoadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_result_fields iprot (LoadLibrary_result{f_LoadLibrary_result_success=Nothing,f_LoadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_args = UnloadLibrary_args{f_UnloadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_args_library record  
write_UnloadLibrary_args oprot record = do
  writeStructBegin oprot "UnloadLibrary_args"
  case f_UnloadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_args_fields iprot record = do
  (_,_t34,_id35) <- readFieldBegin iprot
  if _t34 == T_STOP then return record else
    case _id35 of 
      1 -> if _t34 == T_STRUCT then do
        s <- (read_Library iprot)
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_library=Just s}
        else do
          skip iprot _t34
          read_UnloadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t34
        readFieldEnd iprot
        read_UnloadLibrary_args_fields iprot record
read_UnloadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_args_fields iprot (UnloadLibrary_args{f_UnloadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_result = UnloadLibrary_result{f_UnloadLibrary_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_result_missingFields record  
write_UnloadLibrary_result oprot record = do
  writeStructBegin oprot "UnloadLibrary_result"
  case f_UnloadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_result_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      1 -> if _t39 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UnloadLibrary_result_fields iprot record{f_UnloadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t39
          read_UnloadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_UnloadLibrary_result_fields iprot record
read_UnloadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_result_fields iprot (UnloadLibrary_result{f_UnloadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_args = LibraryRootDef_args{f_LibraryRootDef_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_args_library record  
write_LibraryRootDef_args oprot record = do
  writeStructBegin oprot "LibraryRootDef_args"
  case f_LibraryRootDef_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_args_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LibraryRootDef_args_fields iprot record{f_LibraryRootDef_args_library=Just s}
        else do
          skip iprot _t44
          read_LibraryRootDef_args_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_LibraryRootDef_args_fields iprot record
read_LibraryRootDef_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_args_fields iprot (LibraryRootDef_args{f_LibraryRootDef_args_library=Nothing})
  readStructEnd iprot
  return record
data LibraryRootDef_result = LibraryRootDef_result{f_LibraryRootDef_result_success :: Maybe Defs_Types.NodeDef,f_LibraryRootDef_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable LibraryRootDef_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LibraryRootDef_result_success record   `hashWithSalt` f_LibraryRootDef_result_missingFields record  
write_LibraryRootDef_result oprot record = do
  writeStructBegin oprot "LibraryRootDef_result"
  case f_LibraryRootDef_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  case f_LibraryRootDef_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LibraryRootDef_result_fields iprot record = do
  (_,_t49,_id50) <- readFieldBegin iprot
  if _t49 == T_STOP then return record else
    case _id50 of 
      0 -> if _t49 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_success=Just s}
        else do
          skip iprot _t49
          read_LibraryRootDef_result_fields iprot record
      1 -> if _t49 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_LibraryRootDef_result_fields iprot record{f_LibraryRootDef_result_missingFields=Just s}
        else do
          skip iprot _t49
          read_LibraryRootDef_result_fields iprot record
      _ -> do
        skip iprot _t49
        readFieldEnd iprot
        read_LibraryRootDef_result_fields iprot record
read_LibraryRootDef_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LibraryRootDef_result_fields iprot (LibraryRootDef_result{f_LibraryRootDef_result_success=Nothing,f_LibraryRootDef_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_args = NewDefinition_args{f_NewDefinition_args_type :: Maybe Types_Types.Type,f_NewDefinition_args_imports :: Maybe (Vector.Vector Defs_Types.Import),f_NewDefinition_args_flags :: Maybe Attrs_Types.Flags,f_NewDefinition_args_attrs :: Maybe Attrs_Types.Attributes} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_args_type record   `hashWithSalt` f_NewDefinition_args_imports record   `hashWithSalt` f_NewDefinition_args_flags record   `hashWithSalt` f_NewDefinition_args_attrs record  
write_NewDefinition_args oprot record = do
  writeStructBegin oprot "NewDefinition_args"
  case f_NewDefinition_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_imports record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("imports",T_LIST,2)
    (let f = Vector.mapM_ (\_viter53 -> Defs_Types.write_Import oprot _viter53) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_NewDefinition_args_flags record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("flags",T_STRUCT,3)
    Attrs_Types.write_Flags oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_attrs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attrs",T_STRUCT,4)
    Attrs_Types.write_Attributes oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_args_fields iprot record = do
  (_,_t55,_id56) <- readFieldBegin iprot
  if _t55 == T_STOP then return record else
    case _id56 of 
      1 -> if _t55 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_type=Just s}
        else do
          skip iprot _t55
          read_NewDefinition_args_fields iprot record
      2 -> if _t55 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Import iprot)) in do {(_etype60,_size57) <- readListBegin iprot; f _size57})
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_imports=Just s}
        else do
          skip iprot _t55
          read_NewDefinition_args_fields iprot record
      3 -> if _t55 == T_STRUCT then do
        s <- (read_Flags iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_flags=Just s}
        else do
          skip iprot _t55
          read_NewDefinition_args_fields iprot record
      4 -> if _t55 == T_STRUCT then do
        s <- (read_Attributes iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_attrs=Just s}
        else do
          skip iprot _t55
          read_NewDefinition_args_fields iprot record
      _ -> do
        skip iprot _t55
        readFieldEnd iprot
        read_NewDefinition_args_fields iprot record
read_NewDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_args_fields iprot (NewDefinition_args{f_NewDefinition_args_type=Nothing,f_NewDefinition_args_imports=Nothing,f_NewDefinition_args_flags=Nothing,f_NewDefinition_args_attrs=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_result = NewDefinition_result{f_NewDefinition_result_success :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_result_success record  
write_NewDefinition_result oprot record = do
  writeStructBegin oprot "NewDefinition_result"
  case f_NewDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_result_fields iprot record = do
  (_,_t65,_id66) <- readFieldBegin iprot
  if _t65 == T_STOP then return record else
    case _id66 of 
      0 -> if _t65 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_NewDefinition_result_fields iprot record{f_NewDefinition_result_success=Just s}
        else do
          skip iprot _t65
          read_NewDefinition_result_fields iprot record
      _ -> do
        skip iprot _t65
        readFieldEnd iprot
        read_NewDefinition_result_fields iprot record
read_NewDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_result_fields iprot (NewDefinition_result{f_NewDefinition_result_success=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_args = AddDefinition_args{f_AddDefinition_args_definition :: Maybe Defs_Types.NodeDef,f_AddDefinition_args_parent :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_args_definition record   `hashWithSalt` f_AddDefinition_args_parent record  
write_AddDefinition_args oprot record = do
  writeStructBegin oprot "AddDefinition_args"
  case f_AddDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_parent record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parent",T_STRUCT,2)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_args_fields iprot record = do
  (_,_t70,_id71) <- readFieldBegin iprot
  if _t70 == T_STOP then return record else
    case _id71 of 
      1 -> if _t70 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_definition=Just s}
        else do
          skip iprot _t70
          read_AddDefinition_args_fields iprot record
      2 -> if _t70 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_parent=Just s}
        else do
          skip iprot _t70
          read_AddDefinition_args_fields iprot record
      _ -> do
        skip iprot _t70
        readFieldEnd iprot
        read_AddDefinition_args_fields iprot record
read_AddDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_args_fields iprot (AddDefinition_args{f_AddDefinition_args_definition=Nothing,f_AddDefinition_args_parent=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_result = AddDefinition_result{f_AddDefinition_result_success :: Maybe Defs_Types.NodeDef,f_AddDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_result_success record   `hashWithSalt` f_AddDefinition_result_missingFields record  
write_AddDefinition_result oprot record = do
  writeStructBegin oprot "AddDefinition_result"
  case f_AddDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_result_fields iprot record = do
  (_,_t75,_id76) <- readFieldBegin iprot
  if _t75 == T_STOP then return record else
    case _id76 of 
      0 -> if _t75 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_success=Just s}
        else do
          skip iprot _t75
          read_AddDefinition_result_fields iprot record
      1 -> if _t75 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_missingFields=Just s}
        else do
          skip iprot _t75
          read_AddDefinition_result_fields iprot record
      _ -> do
        skip iprot _t75
        readFieldEnd iprot
        read_AddDefinition_result_fields iprot record
read_AddDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_result_fields iprot (AddDefinition_result{f_AddDefinition_result_success=Nothing,f_AddDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_args = UpdateDefinition_args{f_UpdateDefinition_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_args_definition record  
write_UpdateDefinition_args oprot record = do
  writeStructBegin oprot "UpdateDefinition_args"
  case f_UpdateDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_args_fields iprot record = do
  (_,_t80,_id81) <- readFieldBegin iprot
  if _t80 == T_STOP then return record else
    case _id81 of 
      1 -> if _t80 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_definition=Just s}
        else do
          skip iprot _t80
          read_UpdateDefinition_args_fields iprot record
      _ -> do
        skip iprot _t80
        readFieldEnd iprot
        read_UpdateDefinition_args_fields iprot record
read_UpdateDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_args_fields iprot (UpdateDefinition_args{f_UpdateDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_result = UpdateDefinition_result{f_UpdateDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_result_missingFields record  
write_UpdateDefinition_result oprot record = do
  writeStructBegin oprot "UpdateDefinition_result"
  case f_UpdateDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_result_fields iprot record = do
  (_,_t85,_id86) <- readFieldBegin iprot
  if _t85 == T_STOP then return record else
    case _id86 of 
      1 -> if _t85 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateDefinition_result_fields iprot record{f_UpdateDefinition_result_missingFields=Just s}
        else do
          skip iprot _t85
          read_UpdateDefinition_result_fields iprot record
      _ -> do
        skip iprot _t85
        readFieldEnd iprot
        read_UpdateDefinition_result_fields iprot record
read_UpdateDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_result_fields iprot (UpdateDefinition_result{f_UpdateDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_args = RemoveDefinition_args{f_RemoveDefinition_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_args_definition record  
write_RemoveDefinition_args oprot record = do
  writeStructBegin oprot "RemoveDefinition_args"
  case f_RemoveDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_args_fields iprot record = do
  (_,_t90,_id91) <- readFieldBegin iprot
  if _t90 == T_STOP then return record else
    case _id91 of 
      1 -> if _t90 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_definition=Just s}
        else do
          skip iprot _t90
          read_RemoveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t90
        readFieldEnd iprot
        read_RemoveDefinition_args_fields iprot record
read_RemoveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_args_fields iprot (RemoveDefinition_args{f_RemoveDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_result = RemoveDefinition_result{f_RemoveDefinition_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_result_missingFields record  
write_RemoveDefinition_result oprot record = do
  writeStructBegin oprot "RemoveDefinition_result"
  case f_RemoveDefinition_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_result_fields iprot record = do
  (_,_t95,_id96) <- readFieldBegin iprot
  if _t95 == T_STOP then return record else
    case _id96 of 
      1 -> if _t95 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveDefinition_result_fields iprot record{f_RemoveDefinition_result_missingFields=Just s}
        else do
          skip iprot _t95
          read_RemoveDefinition_result_fields iprot record
      _ -> do
        skip iprot _t95
        readFieldEnd iprot
        read_RemoveDefinition_result_fields iprot record
read_RemoveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_result_fields iprot (RemoveDefinition_result{f_RemoveDefinition_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_args = DefinitionChildren_args{f_DefinitionChildren_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_args_definition record  
write_DefinitionChildren_args oprot record = do
  writeStructBegin oprot "DefinitionChildren_args"
  case f_DefinitionChildren_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_args_fields iprot record = do
  (_,_t100,_id101) <- readFieldBegin iprot
  if _t100 == T_STOP then return record else
    case _id101 of 
      1 -> if _t100 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_definition=Just s}
        else do
          skip iprot _t100
          read_DefinitionChildren_args_fields iprot record
      _ -> do
        skip iprot _t100
        readFieldEnd iprot
        read_DefinitionChildren_args_fields iprot record
read_DefinitionChildren_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_args_fields iprot (DefinitionChildren_args{f_DefinitionChildren_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_result = DefinitionChildren_result{f_DefinitionChildren_result_success :: Maybe (Vector.Vector Defs_Types.NodeDef),f_DefinitionChildren_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_result_success record   `hashWithSalt` f_DefinitionChildren_result_missingFields record  
write_DefinitionChildren_result oprot record = do
  writeStructBegin oprot "DefinitionChildren_result"
  case f_DefinitionChildren_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter104 -> Defs_Types.write_NodeDef oprot _viter104) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_DefinitionChildren_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_result_fields iprot record = do
  (_,_t106,_id107) <- readFieldBegin iprot
  if _t106 == T_STOP then return record else
    case _id107 of 
      0 -> if _t106 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_NodeDef iprot)) in do {(_etype111,_size108) <- readListBegin iprot; f _size108})
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_success=Just s}
        else do
          skip iprot _t106
          read_DefinitionChildren_result_fields iprot record
      1 -> if _t106 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_missingFields=Just s}
        else do
          skip iprot _t106
          read_DefinitionChildren_result_fields iprot record
      _ -> do
        skip iprot _t106
        readFieldEnd iprot
        read_DefinitionChildren_result_fields iprot record
read_DefinitionChildren_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_result_fields iprot (DefinitionChildren_result{f_DefinitionChildren_result_success=Nothing,f_DefinitionChildren_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_args = DefinitionParent_args{f_DefinitionParent_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_args_definition record  
write_DefinitionParent_args oprot record = do
  writeStructBegin oprot "DefinitionParent_args"
  case f_DefinitionParent_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_args_fields iprot record = do
  (_,_t116,_id117) <- readFieldBegin iprot
  if _t116 == T_STOP then return record else
    case _id117 of 
      1 -> if _t116 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_definition=Just s}
        else do
          skip iprot _t116
          read_DefinitionParent_args_fields iprot record
      _ -> do
        skip iprot _t116
        readFieldEnd iprot
        read_DefinitionParent_args_fields iprot record
read_DefinitionParent_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_args_fields iprot (DefinitionParent_args{f_DefinitionParent_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_result = DefinitionParent_result{f_DefinitionParent_result_success :: Maybe Defs_Types.NodeDef,f_DefinitionParent_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_result_success record   `hashWithSalt` f_DefinitionParent_result_missingFields record  
write_DefinitionParent_result oprot record = do
  writeStructBegin oprot "DefinitionParent_result"
  case f_DefinitionParent_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  case f_DefinitionParent_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_result_fields iprot record = do
  (_,_t121,_id122) <- readFieldBegin iprot
  if _t121 == T_STOP then return record else
    case _id122 of 
      0 -> if _t121 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_success=Just s}
        else do
          skip iprot _t121
          read_DefinitionParent_result_fields iprot record
      1 -> if _t121 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_missingFields=Just s}
        else do
          skip iprot _t121
          read_DefinitionParent_result_fields iprot record
      _ -> do
        skip iprot _t121
        readFieldEnd iprot
        read_DefinitionParent_result_fields iprot record
read_DefinitionParent_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_result_fields iprot (DefinitionParent_result{f_DefinitionParent_result_success=Nothing,f_DefinitionParent_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_args = NewTypeModule_args{f_NewTypeModule_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_args_name record  
write_NewTypeModule_args oprot record = do
  writeStructBegin oprot "NewTypeModule_args"
  case f_NewTypeModule_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_args_fields iprot record = do
  (_,_t126,_id127) <- readFieldBegin iprot
  if _t126 == T_STOP then return record else
    case _id127 of 
      1 -> if _t126 == T_STRING then do
        s <- readString iprot
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_name=Just s}
        else do
          skip iprot _t126
          read_NewTypeModule_args_fields iprot record
      _ -> do
        skip iprot _t126
        readFieldEnd iprot
        read_NewTypeModule_args_fields iprot record
read_NewTypeModule_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_args_fields iprot (NewTypeModule_args{f_NewTypeModule_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_result = NewTypeModule_result{f_NewTypeModule_result_success :: Maybe Types_Types.Type,f_NewTypeModule_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_result_success record   `hashWithSalt` f_NewTypeModule_result_missingFields record  
write_NewTypeModule_result oprot record = do
  writeStructBegin oprot "NewTypeModule_result"
  case f_NewTypeModule_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeModule_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_result_fields iprot record = do
  (_,_t131,_id132) <- readFieldBegin iprot
  if _t131 == T_STOP then return record else
    case _id132 of 
      0 -> if _t131 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_success=Just s}
        else do
          skip iprot _t131
          read_NewTypeModule_result_fields iprot record
      1 -> if _t131 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_missingFields=Just s}
        else do
          skip iprot _t131
          read_NewTypeModule_result_fields iprot record
      _ -> do
        skip iprot _t131
        readFieldEnd iprot
        read_NewTypeModule_result_fields iprot record
read_NewTypeModule_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_result_fields iprot (NewTypeModule_result{f_NewTypeModule_result_success=Nothing,f_NewTypeModule_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_args = NewTypeClass_args{f_NewTypeClass_args_name :: Maybe Text,f_NewTypeClass_args_params :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_args_name record   `hashWithSalt` f_NewTypeClass_args_params record  
write_NewTypeClass_args oprot record = do
  writeStructBegin oprot "NewTypeClass_args"
  case f_NewTypeClass_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_args_params record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("params",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_args_fields iprot record = do
  (_,_t136,_id137) <- readFieldBegin iprot
  if _t136 == T_STOP then return record else
    case _id137 of 
      1 -> if _t136 == T_STRING then do
        s <- readString iprot
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_name=Just s}
        else do
          skip iprot _t136
          read_NewTypeClass_args_fields iprot record
      2 -> if _t136 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_params=Just s}
        else do
          skip iprot _t136
          read_NewTypeClass_args_fields iprot record
      _ -> do
        skip iprot _t136
        readFieldEnd iprot
        read_NewTypeClass_args_fields iprot record
read_NewTypeClass_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_args_fields iprot (NewTypeClass_args{f_NewTypeClass_args_name=Nothing,f_NewTypeClass_args_params=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_result = NewTypeClass_result{f_NewTypeClass_result_success :: Maybe Types_Types.Type,f_NewTypeClass_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_result_success record   `hashWithSalt` f_NewTypeClass_result_missingFields record  
write_NewTypeClass_result oprot record = do
  writeStructBegin oprot "NewTypeClass_result"
  case f_NewTypeClass_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_result_fields iprot record = do
  (_,_t141,_id142) <- readFieldBegin iprot
  if _t141 == T_STOP then return record else
    case _id142 of 
      0 -> if _t141 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_success=Just s}
        else do
          skip iprot _t141
          read_NewTypeClass_result_fields iprot record
      1 -> if _t141 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_missingFields=Just s}
        else do
          skip iprot _t141
          read_NewTypeClass_result_fields iprot record
      _ -> do
        skip iprot _t141
        readFieldEnd iprot
        read_NewTypeClass_result_fields iprot record
read_NewTypeClass_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_result_fields iprot (NewTypeClass_result{f_NewTypeClass_result_success=Nothing,f_NewTypeClass_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_args = NewTypeFunction_args{f_NewTypeFunction_args_name :: Maybe Text,f_NewTypeFunction_args_inputs :: Maybe Types_Types.Type,f_NewTypeFunction_args_outputs :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_args_name record   `hashWithSalt` f_NewTypeFunction_args_inputs record   `hashWithSalt` f_NewTypeFunction_args_outputs record  
write_NewTypeFunction_args oprot record = do
  writeStructBegin oprot "NewTypeFunction_args"
  case f_NewTypeFunction_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_inputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inputs",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_outputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("outputs",T_STRUCT,3)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_args_fields iprot record = do
  (_,_t146,_id147) <- readFieldBegin iprot
  if _t146 == T_STOP then return record else
    case _id147 of 
      1 -> if _t146 == T_STRING then do
        s <- readString iprot
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_name=Just s}
        else do
          skip iprot _t146
          read_NewTypeFunction_args_fields iprot record
      2 -> if _t146 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_inputs=Just s}
        else do
          skip iprot _t146
          read_NewTypeFunction_args_fields iprot record
      3 -> if _t146 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_outputs=Just s}
        else do
          skip iprot _t146
          read_NewTypeFunction_args_fields iprot record
      _ -> do
        skip iprot _t146
        readFieldEnd iprot
        read_NewTypeFunction_args_fields iprot record
read_NewTypeFunction_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_args_fields iprot (NewTypeFunction_args{f_NewTypeFunction_args_name=Nothing,f_NewTypeFunction_args_inputs=Nothing,f_NewTypeFunction_args_outputs=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_result = NewTypeFunction_result{f_NewTypeFunction_result_success :: Maybe Types_Types.Type,f_NewTypeFunction_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_result_success record   `hashWithSalt` f_NewTypeFunction_result_missingFields record  
write_NewTypeFunction_result oprot record = do
  writeStructBegin oprot "NewTypeFunction_result"
  case f_NewTypeFunction_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_result_fields iprot record = do
  (_,_t151,_id152) <- readFieldBegin iprot
  if _t151 == T_STOP then return record else
    case _id152 of 
      0 -> if _t151 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_success=Just s}
        else do
          skip iprot _t151
          read_NewTypeFunction_result_fields iprot record
      1 -> if _t151 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_missingFields=Just s}
        else do
          skip iprot _t151
          read_NewTypeFunction_result_fields iprot record
      _ -> do
        skip iprot _t151
        readFieldEnd iprot
        read_NewTypeFunction_result_fields iprot record
read_NewTypeFunction_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_result_fields iprot (NewTypeFunction_result{f_NewTypeFunction_result_success=Nothing,f_NewTypeFunction_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeUdefined_args = NewTypeUdefined_args deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_args where
  hashWithSalt salt record = salt  
write_NewTypeUdefined_args oprot record = do
  writeStructBegin oprot "NewTypeUdefined_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_args_fields iprot record = do
  (_,_t156,_id157) <- readFieldBegin iprot
  if _t156 == T_STOP then return record else
    case _id157 of 
      _ -> do
        skip iprot _t156
        readFieldEnd iprot
        read_NewTypeUdefined_args_fields iprot record
read_NewTypeUdefined_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_args_fields iprot (NewTypeUdefined_args{})
  readStructEnd iprot
  return record
data NewTypeUdefined_result = NewTypeUdefined_result{f_NewTypeUdefined_result_success :: Maybe Types_Types.Type,f_NewTypeUdefined_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeUdefined_result_success record   `hashWithSalt` f_NewTypeUdefined_result_missingFields record  
write_NewTypeUdefined_result oprot record = do
  writeStructBegin oprot "NewTypeUdefined_result"
  case f_NewTypeUdefined_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeUdefined_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_result_fields iprot record = do
  (_,_t161,_id162) <- readFieldBegin iprot
  if _t161 == T_STOP then return record else
    case _id162 of 
      0 -> if _t161 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_success=Just s}
        else do
          skip iprot _t161
          read_NewTypeUdefined_result_fields iprot record
      1 -> if _t161 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_missingFields=Just s}
        else do
          skip iprot _t161
          read_NewTypeUdefined_result_fields iprot record
      _ -> do
        skip iprot _t161
        readFieldEnd iprot
        read_NewTypeUdefined_result_fields iprot record
read_NewTypeUdefined_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_result_fields iprot (NewTypeUdefined_result{f_NewTypeUdefined_result_success=Nothing,f_NewTypeUdefined_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_args = NewTypeNamed_args{f_NewTypeNamed_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_args_name record  
write_NewTypeNamed_args oprot record = do
  writeStructBegin oprot "NewTypeNamed_args"
  case f_NewTypeNamed_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_args_fields iprot record = do
  (_,_t166,_id167) <- readFieldBegin iprot
  if _t166 == T_STOP then return record else
    case _id167 of 
      1 -> if _t166 == T_STRING then do
        s <- readString iprot
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_name=Just s}
        else do
          skip iprot _t166
          read_NewTypeNamed_args_fields iprot record
      _ -> do
        skip iprot _t166
        readFieldEnd iprot
        read_NewTypeNamed_args_fields iprot record
read_NewTypeNamed_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_args_fields iprot (NewTypeNamed_args{f_NewTypeNamed_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_result = NewTypeNamed_result{f_NewTypeNamed_result_success :: Maybe Types_Types.Type,f_NewTypeNamed_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_result_success record   `hashWithSalt` f_NewTypeNamed_result_missingFields record  
write_NewTypeNamed_result oprot record = do
  writeStructBegin oprot "NewTypeNamed_result"
  case f_NewTypeNamed_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeNamed_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_result_fields iprot record = do
  (_,_t171,_id172) <- readFieldBegin iprot
  if _t171 == T_STOP then return record else
    case _id172 of 
      0 -> if _t171 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_success=Just s}
        else do
          skip iprot _t171
          read_NewTypeNamed_result_fields iprot record
      1 -> if _t171 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_missingFields=Just s}
        else do
          skip iprot _t171
          read_NewTypeNamed_result_fields iprot record
      _ -> do
        skip iprot _t171
        readFieldEnd iprot
        read_NewTypeNamed_result_fields iprot record
read_NewTypeNamed_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_result_fields iprot (NewTypeNamed_result{f_NewTypeNamed_result_success=Nothing,f_NewTypeNamed_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_args = NewTypeVariable_args{f_NewTypeVariable_args_name :: Maybe Text,f_NewTypeVariable_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_args_name record   `hashWithSalt` f_NewTypeVariable_args_type record  
write_NewTypeVariable_args oprot record = do
  writeStructBegin oprot "NewTypeVariable_args"
  case f_NewTypeVariable_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeVariable_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_args_fields iprot record = do
  (_,_t176,_id177) <- readFieldBegin iprot
  if _t176 == T_STOP then return record else
    case _id177 of 
      1 -> if _t176 == T_STRING then do
        s <- readString iprot
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_name=Just s}
        else do
          skip iprot _t176
          read_NewTypeVariable_args_fields iprot record
      2 -> if _t176 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_type=Just s}
        else do
          skip iprot _t176
          read_NewTypeVariable_args_fields iprot record
      _ -> do
        skip iprot _t176
        readFieldEnd iprot
        read_NewTypeVariable_args_fields iprot record
read_NewTypeVariable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_args_fields iprot (NewTypeVariable_args{f_NewTypeVariable_args_name=Nothing,f_NewTypeVariable_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_result = NewTypeVariable_result{f_NewTypeVariable_result_success :: Maybe Types_Types.Type,f_NewTypeVariable_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_result_success record   `hashWithSalt` f_NewTypeVariable_result_missingFields record  
write_NewTypeVariable_result oprot record = do
  writeStructBegin oprot "NewTypeVariable_result"
  case f_NewTypeVariable_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeVariable_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_result_fields iprot record = do
  (_,_t181,_id182) <- readFieldBegin iprot
  if _t181 == T_STOP then return record else
    case _id182 of 
      0 -> if _t181 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_success=Just s}
        else do
          skip iprot _t181
          read_NewTypeVariable_result_fields iprot record
      1 -> if _t181 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_missingFields=Just s}
        else do
          skip iprot _t181
          read_NewTypeVariable_result_fields iprot record
      _ -> do
        skip iprot _t181
        readFieldEnd iprot
        read_NewTypeVariable_result_fields iprot record
read_NewTypeVariable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_result_fields iprot (NewTypeVariable_result{f_NewTypeVariable_result_success=Nothing,f_NewTypeVariable_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_args = NewTypeList_args{f_NewTypeList_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_args_type record  
write_NewTypeList_args oprot record = do
  writeStructBegin oprot "NewTypeList_args"
  case f_NewTypeList_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_args_fields iprot record = do
  (_,_t186,_id187) <- readFieldBegin iprot
  if _t186 == T_STOP then return record else
    case _id187 of 
      1 -> if _t186 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_args_fields iprot record{f_NewTypeList_args_type=Just s}
        else do
          skip iprot _t186
          read_NewTypeList_args_fields iprot record
      _ -> do
        skip iprot _t186
        readFieldEnd iprot
        read_NewTypeList_args_fields iprot record
read_NewTypeList_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_args_fields iprot (NewTypeList_args{f_NewTypeList_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_result = NewTypeList_result{f_NewTypeList_result_success :: Maybe Types_Types.Type,f_NewTypeList_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_result_success record   `hashWithSalt` f_NewTypeList_result_missingFields record  
write_NewTypeList_result oprot record = do
  writeStructBegin oprot "NewTypeList_result"
  case f_NewTypeList_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeList_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_result_fields iprot record = do
  (_,_t191,_id192) <- readFieldBegin iprot
  if _t191 == T_STOP then return record else
    case _id192 of 
      0 -> if _t191 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_success=Just s}
        else do
          skip iprot _t191
          read_NewTypeList_result_fields iprot record
      1 -> if _t191 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_missingFields=Just s}
        else do
          skip iprot _t191
          read_NewTypeList_result_fields iprot record
      _ -> do
        skip iprot _t191
        readFieldEnd iprot
        read_NewTypeList_result_fields iprot record
read_NewTypeList_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_result_fields iprot (NewTypeList_result{f_NewTypeList_result_success=Nothing,f_NewTypeList_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_args = NewTypeTuple_args{f_NewTypeTuple_args_types :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_args_types record  
write_NewTypeTuple_args oprot record = do
  writeStructBegin oprot "NewTypeTuple_args"
  case f_NewTypeTuple_args_types record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("types",T_LIST,1)
    (let f = Vector.mapM_ (\_viter195 -> Types_Types.write_Type oprot _viter195) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_args_fields iprot record = do
  (_,_t197,_id198) <- readFieldBegin iprot
  if _t197 == T_STOP then return record else
    case _id198 of 
      1 -> if _t197 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype202,_size199) <- readListBegin iprot; f _size199})
        read_NewTypeTuple_args_fields iprot record{f_NewTypeTuple_args_types=Just s}
        else do
          skip iprot _t197
          read_NewTypeTuple_args_fields iprot record
      _ -> do
        skip iprot _t197
        readFieldEnd iprot
        read_NewTypeTuple_args_fields iprot record
read_NewTypeTuple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_args_fields iprot (NewTypeTuple_args{f_NewTypeTuple_args_types=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_result = NewTypeTuple_result{f_NewTypeTuple_result_success :: Maybe Types_Types.Type,f_NewTypeTuple_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_result_success record   `hashWithSalt` f_NewTypeTuple_result_missingFields record  
write_NewTypeTuple_result oprot record = do
  writeStructBegin oprot "NewTypeTuple_result"
  case f_NewTypeTuple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeTuple_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_result_fields iprot record = do
  (_,_t207,_id208) <- readFieldBegin iprot
  if _t207 == T_STOP then return record else
    case _id208 of 
      0 -> if _t207 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_success=Just s}
        else do
          skip iprot _t207
          read_NewTypeTuple_result_fields iprot record
      1 -> if _t207 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_missingFields=Just s}
        else do
          skip iprot _t207
          read_NewTypeTuple_result_fields iprot record
      _ -> do
        skip iprot _t207
        readFieldEnd iprot
        read_NewTypeTuple_result_fields iprot record
read_NewTypeTuple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_result_fields iprot (NewTypeTuple_result{f_NewTypeTuple_result_success=Nothing,f_NewTypeTuple_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Graph_args = Graph_args{f_Graph_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable Graph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_args_definition record  
write_Graph_args oprot record = do
  writeStructBegin oprot "Graph_args"
  case f_Graph_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_args_fields iprot record = do
  (_,_t212,_id213) <- readFieldBegin iprot
  if _t212 == T_STOP then return record else
    case _id213 of 
      1 -> if _t212 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_Graph_args_fields iprot record{f_Graph_args_definition=Just s}
        else do
          skip iprot _t212
          read_Graph_args_fields iprot record
      _ -> do
        skip iprot _t212
        readFieldEnd iprot
        read_Graph_args_fields iprot record
read_Graph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_args_fields iprot (Graph_args{f_Graph_args_definition=Nothing})
  readStructEnd iprot
  return record
data Graph_result = Graph_result{f_Graph_result_success :: Maybe Graph_Types.Graph,f_Graph_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Graph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_result_success record   `hashWithSalt` f_Graph_result_missingFields record  
write_Graph_result oprot record = do
  writeStructBegin oprot "Graph_result"
  case f_Graph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Graph oprot _v
    writeFieldEnd oprot}
  case f_Graph_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_result_fields iprot record = do
  (_,_t217,_id218) <- readFieldBegin iprot
  if _t217 == T_STOP then return record else
    case _id218 of 
      0 -> if _t217 == T_STRUCT then do
        s <- (read_Graph iprot)
        read_Graph_result_fields iprot record{f_Graph_result_success=Just s}
        else do
          skip iprot _t217
          read_Graph_result_fields iprot record
      1 -> if _t217 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Graph_result_fields iprot record{f_Graph_result_missingFields=Just s}
        else do
          skip iprot _t217
          read_Graph_result_fields iprot record
      _ -> do
        skip iprot _t217
        readFieldEnd iprot
        read_Graph_result_fields iprot record
read_Graph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_result_fields iprot (Graph_result{f_Graph_result_success=Nothing,f_Graph_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data AddNode_args = AddNode_args{f_AddNode_args_node :: Maybe Graph_Types.Node,f_AddNode_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable AddNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_args_node record   `hashWithSalt` f_AddNode_args_definition record  
write_AddNode_args oprot record = do
  writeStructBegin oprot "AddNode_args"
  case f_AddNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_args_fields iprot record = do
  (_,_t222,_id223) <- readFieldBegin iprot
  if _t222 == T_STOP then return record else
    case _id223 of 
      1 -> if _t222 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_node=Just s}
        else do
          skip iprot _t222
          read_AddNode_args_fields iprot record
      2 -> if _t222 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_definition=Just s}
        else do
          skip iprot _t222
          read_AddNode_args_fields iprot record
      _ -> do
        skip iprot _t222
        readFieldEnd iprot
        read_AddNode_args_fields iprot record
read_AddNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_args_fields iprot (AddNode_args{f_AddNode_args_node=Nothing,f_AddNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data AddNode_result = AddNode_result{f_AddNode_result_success :: Maybe Graph_Types.Node,f_AddNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable AddNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_result_success record   `hashWithSalt` f_AddNode_result_missingFields record  
write_AddNode_result oprot record = do
  writeStructBegin oprot "AddNode_result"
  case f_AddNode_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_result_fields iprot record = do
  (_,_t227,_id228) <- readFieldBegin iprot
  if _t227 == T_STOP then return record else
    case _id228 of 
      0 -> if _t227 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_success=Just s}
        else do
          skip iprot _t227
          read_AddNode_result_fields iprot record
      1 -> if _t227 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_missingFields=Just s}
        else do
          skip iprot _t227
          read_AddNode_result_fields iprot record
      _ -> do
        skip iprot _t227
        readFieldEnd iprot
        read_AddNode_result_fields iprot record
read_AddNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_result_fields iprot (AddNode_result{f_AddNode_result_success=Nothing,f_AddNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_args = UpdateNode_args{f_UpdateNode_args_node :: Maybe Graph_Types.Node,f_UpdateNode_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_args_node record   `hashWithSalt` f_UpdateNode_args_definition record  
write_UpdateNode_args oprot record = do
  writeStructBegin oprot "UpdateNode_args"
  case f_UpdateNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_args_fields iprot record = do
  (_,_t232,_id233) <- readFieldBegin iprot
  if _t232 == T_STOP then return record else
    case _id233 of 
      1 -> if _t232 == T_STRUCT then do
        s <- (read_Node iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_node=Just s}
        else do
          skip iprot _t232
          read_UpdateNode_args_fields iprot record
      2 -> if _t232 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_definition=Just s}
        else do
          skip iprot _t232
          read_UpdateNode_args_fields iprot record
      _ -> do
        skip iprot _t232
        readFieldEnd iprot
        read_UpdateNode_args_fields iprot record
read_UpdateNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_args_fields iprot (UpdateNode_args{f_UpdateNode_args_node=Nothing,f_UpdateNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_result = UpdateNode_result{f_UpdateNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_result_missingFields record  
write_UpdateNode_result oprot record = do
  writeStructBegin oprot "UpdateNode_result"
  case f_UpdateNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_result_fields iprot record = do
  (_,_t237,_id238) <- readFieldBegin iprot
  if _t237 == T_STOP then return record else
    case _id238 of 
      1 -> if _t237 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_UpdateNode_result_fields iprot record{f_UpdateNode_result_missingFields=Just s}
        else do
          skip iprot _t237
          read_UpdateNode_result_fields iprot record
      _ -> do
        skip iprot _t237
        readFieldEnd iprot
        read_UpdateNode_result_fields iprot record
read_UpdateNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_result_fields iprot (UpdateNode_result{f_UpdateNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_args = RemoveNode_args{f_RemoveNode_args_node :: Maybe Graph_Types.Node,f_RemoveNode_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_args_node record   `hashWithSalt` f_RemoveNode_args_definition record  
write_RemoveNode_args oprot record = do
  writeStructBegin oprot "RemoveNode_args"
  case f_RemoveNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_args_fields iprot record = do
  (_,_t242,_id243) <- readFieldBegin iprot
  if _t242 == T_STOP then return record else
    case _id243 of 
      1 -> if _t242 == T_STRUCT then do
        s <- (read_Node iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_node=Just s}
        else do
          skip iprot _t242
          read_RemoveNode_args_fields iprot record
      2 -> if _t242 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_definition=Just s}
        else do
          skip iprot _t242
          read_RemoveNode_args_fields iprot record
      _ -> do
        skip iprot _t242
        readFieldEnd iprot
        read_RemoveNode_args_fields iprot record
read_RemoveNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_args_fields iprot (RemoveNode_args{f_RemoveNode_args_node=Nothing,f_RemoveNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_result = RemoveNode_result{f_RemoveNode_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_result_missingFields record  
write_RemoveNode_result oprot record = do
  writeStructBegin oprot "RemoveNode_result"
  case f_RemoveNode_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_result_fields iprot record = do
  (_,_t247,_id248) <- readFieldBegin iprot
  if _t247 == T_STOP then return record else
    case _id248 of 
      1 -> if _t247 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_RemoveNode_result_fields iprot record{f_RemoveNode_result_missingFields=Just s}
        else do
          skip iprot _t247
          read_RemoveNode_result_fields iprot record
      _ -> do
        skip iprot _t247
        readFieldEnd iprot
        read_RemoveNode_result_fields iprot record
read_RemoveNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_result_fields iprot (RemoveNode_result{f_RemoveNode_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Connect_args = Connect_args{f_Connect_args_srcNode :: Maybe Graph_Types.Node,f_Connect_args_srcPort :: Maybe (Vector.Vector Int32),f_Connect_args_dstNode :: Maybe Graph_Types.Node,f_Connect_args_dstPort :: Maybe (Vector.Vector Int32),f_Connect_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable Connect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_args_srcNode record   `hashWithSalt` f_Connect_args_srcPort record   `hashWithSalt` f_Connect_args_dstNode record   `hashWithSalt` f_Connect_args_dstPort record   `hashWithSalt` f_Connect_args_definition record  
write_Connect_args oprot record = do
  writeStructBegin oprot "Connect_args"
  case f_Connect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter251 -> writeI32 oprot _viter251) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter252 -> writeI32 oprot _viter252) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_args_fields iprot record = do
  (_,_t254,_id255) <- readFieldBegin iprot
  if _t254 == T_STOP then return record else
    case _id255 of 
      1 -> if _t254 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_srcNode=Just s}
        else do
          skip iprot _t254
          read_Connect_args_fields iprot record
      2 -> if _t254 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype259,_size256) <- readListBegin iprot; f _size256})
        read_Connect_args_fields iprot record{f_Connect_args_srcPort=Just s}
        else do
          skip iprot _t254
          read_Connect_args_fields iprot record
      3 -> if _t254 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_dstNode=Just s}
        else do
          skip iprot _t254
          read_Connect_args_fields iprot record
      4 -> if _t254 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype264,_size261) <- readListBegin iprot; f _size261})
        read_Connect_args_fields iprot record{f_Connect_args_dstPort=Just s}
        else do
          skip iprot _t254
          read_Connect_args_fields iprot record
      5 -> if _t254 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_Connect_args_fields iprot record{f_Connect_args_definition=Just s}
        else do
          skip iprot _t254
          read_Connect_args_fields iprot record
      _ -> do
        skip iprot _t254
        readFieldEnd iprot
        read_Connect_args_fields iprot record
read_Connect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_args_fields iprot (Connect_args{f_Connect_args_srcNode=Nothing,f_Connect_args_srcPort=Nothing,f_Connect_args_dstNode=Nothing,f_Connect_args_dstPort=Nothing,f_Connect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Connect_result = Connect_result{f_Connect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Connect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_result_missingFields record  
write_Connect_result oprot record = do
  writeStructBegin oprot "Connect_result"
  case f_Connect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_result_fields iprot record = do
  (_,_t269,_id270) <- readFieldBegin iprot
  if _t269 == T_STOP then return record else
    case _id270 of 
      1 -> if _t269 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Connect_result_fields iprot record{f_Connect_result_missingFields=Just s}
        else do
          skip iprot _t269
          read_Connect_result_fields iprot record
      _ -> do
        skip iprot _t269
        readFieldEnd iprot
        read_Connect_result_fields iprot record
read_Connect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_result_fields iprot (Connect_result{f_Connect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Disconnect_args = Disconnect_args{f_Disconnect_args_srcNode :: Maybe Graph_Types.Node,f_Disconnect_args_srcPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_dstNode :: Maybe Graph_Types.Node,f_Disconnect_args_dstPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_definition :: Maybe Defs_Types.NodeDef} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_args_srcNode record   `hashWithSalt` f_Disconnect_args_srcPort record   `hashWithSalt` f_Disconnect_args_dstNode record   `hashWithSalt` f_Disconnect_args_dstPort record   `hashWithSalt` f_Disconnect_args_definition record  
write_Disconnect_args oprot record = do
  writeStructBegin oprot "Disconnect_args"
  case f_Disconnect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter273 -> writeI32 oprot _viter273) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter274 -> writeI32 oprot _viter274) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_NodeDef oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_args_fields iprot record = do
  (_,_t276,_id277) <- readFieldBegin iprot
  if _t276 == T_STOP then return record else
    case _id277 of 
      1 -> if _t276 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcNode=Just s}
        else do
          skip iprot _t276
          read_Disconnect_args_fields iprot record
      2 -> if _t276 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype281,_size278) <- readListBegin iprot; f _size278})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcPort=Just s}
        else do
          skip iprot _t276
          read_Disconnect_args_fields iprot record
      3 -> if _t276 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstNode=Just s}
        else do
          skip iprot _t276
          read_Disconnect_args_fields iprot record
      4 -> if _t276 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype286,_size283) <- readListBegin iprot; f _size283})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstPort=Just s}
        else do
          skip iprot _t276
          read_Disconnect_args_fields iprot record
      5 -> if _t276 == T_STRUCT then do
        s <- (read_NodeDef iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_definition=Just s}
        else do
          skip iprot _t276
          read_Disconnect_args_fields iprot record
      _ -> do
        skip iprot _t276
        readFieldEnd iprot
        read_Disconnect_args_fields iprot record
read_Disconnect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_args_fields iprot (Disconnect_args{f_Disconnect_args_srcNode=Nothing,f_Disconnect_args_srcPort=Nothing,f_Disconnect_args_dstNode=Nothing,f_Disconnect_args_dstPort=Nothing,f_Disconnect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Disconnect_result = Disconnect_result{f_Disconnect_result_missingFields :: Maybe ArgumentException} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_result_missingFields record  
write_Disconnect_result oprot record = do
  writeStructBegin oprot "Disconnect_result"
  case f_Disconnect_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_ArgumentException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_result_fields iprot record = do
  (_,_t291,_id292) <- readFieldBegin iprot
  if _t291 == T_STOP then return record else
    case _id292 of 
      1 -> if _t291 == T_STRUCT then do
        s <- (read_ArgumentException iprot)
        read_Disconnect_result_fields iprot record{f_Disconnect_result_missingFields=Just s}
        else do
          skip iprot _t291
          read_Disconnect_result_fields iprot record
      _ -> do
        skip iprot _t291
        readFieldEnd iprot
        read_Disconnect_result_fields iprot record
read_Disconnect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_result_fields iprot (Disconnect_result{f_Disconnect_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data Ping_args = Ping_args deriving (Show,Eq,Typeable)
instance Hashable Ping_args where
  hashWithSalt salt record = salt  
write_Ping_args oprot record = do
  writeStructBegin oprot "Ping_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_args_fields iprot record = do
  (_,_t296,_id297) <- readFieldBegin iprot
  if _t296 == T_STOP then return record else
    case _id297 of 
      _ -> do
        skip iprot _t296
        readFieldEnd iprot
        read_Ping_args_fields iprot record
read_Ping_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_args_fields iprot (Ping_args{})
  readStructEnd iprot
  return record
data Ping_result = Ping_result deriving (Show,Eq,Typeable)
instance Hashable Ping_result where
  hashWithSalt salt record = salt  
write_Ping_result oprot record = do
  writeStructBegin oprot "Ping_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_result_fields iprot record = do
  (_,_t301,_id302) <- readFieldBegin iprot
  if _t301 == T_STOP then return record else
    case _id302 of 
      _ -> do
        skip iprot _t301
        readFieldEnd iprot
        read_Ping_result_fields iprot record
read_Ping_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_result_fields iprot (Ping_result{})
  readStructEnd iprot
  return record
process_libraries (seqid, iprot, oprot, handler) = do
  args <- read_Libraries_args iprot
  readMessageEnd iprot
  rs <- return (Libraries_result Nothing)
  res <- (do
    res <- Iface.libraries handler
    return rs{f_Libraries_result_success= Just res})
  writeMessageBegin oprot ("libraries", M_REPLY, seqid);
  write_Libraries_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_loadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_LoadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (LoadLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.loadLibrary handler (f_LoadLibrary_args_library args)
      return rs{f_LoadLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_LoadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("loadLibrary", M_REPLY, seqid);
  write_LoadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_unloadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_UnloadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (UnloadLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.unloadLibrary handler (f_UnloadLibrary_args_library args)
      return rs)
    (\e  -> 
      return rs{f_UnloadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("unloadLibrary", M_REPLY, seqid);
  write_UnloadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_libraryRootDef (seqid, iprot, oprot, handler) = do
  args <- read_LibraryRootDef_args iprot
  readMessageEnd iprot
  rs <- return (LibraryRootDef_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.libraryRootDef handler (f_LibraryRootDef_args_library args)
      return rs{f_LibraryRootDef_result_success= Just res})
    (\e  -> 
      return rs{f_LibraryRootDef_result_missingFields =Just e}))
  writeMessageBegin oprot ("libraryRootDef", M_REPLY, seqid);
  write_LibraryRootDef_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newDefinition (seqid, iprot, oprot, handler) = do
  args <- read_NewDefinition_args iprot
  readMessageEnd iprot
  rs <- return (NewDefinition_result Nothing)
  res <- (do
    res <- Iface.newDefinition handler (f_NewDefinition_args_type args) (f_NewDefinition_args_imports args) (f_NewDefinition_args_flags args) (f_NewDefinition_args_attrs args)
    return rs{f_NewDefinition_result_success= Just res})
  writeMessageBegin oprot ("newDefinition", M_REPLY, seqid);
  write_NewDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addDefinition (seqid, iprot, oprot, handler) = do
  args <- read_AddDefinition_args iprot
  readMessageEnd iprot
  rs <- return (AddDefinition_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addDefinition handler (f_AddDefinition_args_definition args) (f_AddDefinition_args_parent args)
      return rs{f_AddDefinition_result_success= Just res})
    (\e  -> 
      return rs{f_AddDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("addDefinition", M_REPLY, seqid);
  write_AddDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateDefinition (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDefinition_args iprot
  readMessageEnd iprot
  rs <- return (UpdateDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateDefinition handler (f_UpdateDefinition_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_UpdateDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateDefinition", M_REPLY, seqid);
  write_UpdateDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeDefinition (seqid, iprot, oprot, handler) = do
  args <- read_RemoveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (RemoveDefinition_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeDefinition handler (f_RemoveDefinition_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_RemoveDefinition_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeDefinition", M_REPLY, seqid);
  write_RemoveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionChildren (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionChildren_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionChildren_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionChildren handler (f_DefinitionChildren_args_definition args)
      return rs{f_DefinitionChildren_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionChildren_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionChildren", M_REPLY, seqid);
  write_DefinitionChildren_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionParent (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionParent_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionParent_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.definitionParent handler (f_DefinitionParent_args_definition args)
      return rs{f_DefinitionParent_result_success= Just res})
    (\e  -> 
      return rs{f_DefinitionParent_result_missingFields =Just e}))
  writeMessageBegin oprot ("definitionParent", M_REPLY, seqid);
  write_DefinitionParent_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeModule (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeModule_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeModule_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeModule handler (f_NewTypeModule_args_name args)
      return rs{f_NewTypeModule_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeModule_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeModule", M_REPLY, seqid);
  write_NewTypeModule_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeClass (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeClass_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeClass_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeClass handler (f_NewTypeClass_args_name args) (f_NewTypeClass_args_params args)
      return rs{f_NewTypeClass_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeClass_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeClass", M_REPLY, seqid);
  write_NewTypeClass_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeFunction (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeFunction_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeFunction_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeFunction handler (f_NewTypeFunction_args_name args) (f_NewTypeFunction_args_inputs args) (f_NewTypeFunction_args_outputs args)
      return rs{f_NewTypeFunction_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeFunction_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeFunction", M_REPLY, seqid);
  write_NewTypeFunction_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeUdefined (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeUdefined_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeUdefined_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeUdefined handler
      return rs{f_NewTypeUdefined_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeUdefined_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeUdefined", M_REPLY, seqid);
  write_NewTypeUdefined_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeNamed (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeNamed_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeNamed_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeNamed handler (f_NewTypeNamed_args_name args)
      return rs{f_NewTypeNamed_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeNamed_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeNamed", M_REPLY, seqid);
  write_NewTypeNamed_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeVariable (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeVariable_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeVariable_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeVariable handler (f_NewTypeVariable_args_name args) (f_NewTypeVariable_args_type args)
      return rs{f_NewTypeVariable_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeVariable_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeVariable", M_REPLY, seqid);
  write_NewTypeVariable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeList (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeList_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeList_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeList handler (f_NewTypeList_args_type args)
      return rs{f_NewTypeList_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeList_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeList", M_REPLY, seqid);
  write_NewTypeList_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeTuple (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeTuple_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeTuple_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.newTypeTuple handler (f_NewTypeTuple_args_types args)
      return rs{f_NewTypeTuple_result_success= Just res})
    (\e  -> 
      return rs{f_NewTypeTuple_result_missingFields =Just e}))
  writeMessageBegin oprot ("newTypeTuple", M_REPLY, seqid);
  write_NewTypeTuple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_graph (seqid, iprot, oprot, handler) = do
  args <- read_Graph_args iprot
  readMessageEnd iprot
  rs <- return (Graph_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.graph handler (f_Graph_args_definition args)
      return rs{f_Graph_result_success= Just res})
    (\e  -> 
      return rs{f_Graph_result_missingFields =Just e}))
  writeMessageBegin oprot ("graph", M_REPLY, seqid);
  write_Graph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addNode (seqid, iprot, oprot, handler) = do
  args <- read_AddNode_args iprot
  readMessageEnd iprot
  rs <- return (AddNode_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.addNode handler (f_AddNode_args_node args) (f_AddNode_args_definition args)
      return rs{f_AddNode_result_success= Just res})
    (\e  -> 
      return rs{f_AddNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("addNode", M_REPLY, seqid);
  write_AddNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateNode (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNode_args iprot
  readMessageEnd iprot
  rs <- return (UpdateNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.updateNode handler (f_UpdateNode_args_node args) (f_UpdateNode_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_UpdateNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("updateNode", M_REPLY, seqid);
  write_UpdateNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNode (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNode_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNode_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.removeNode handler (f_RemoveNode_args_node args) (f_RemoveNode_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_RemoveNode_result_missingFields =Just e}))
  writeMessageBegin oprot ("removeNode", M_REPLY, seqid);
  write_RemoveNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_connect (seqid, iprot, oprot, handler) = do
  args <- read_Connect_args iprot
  readMessageEnd iprot
  rs <- return (Connect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.connect handler (f_Connect_args_srcNode args) (f_Connect_args_srcPort args) (f_Connect_args_dstNode args) (f_Connect_args_dstPort args) (f_Connect_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_Connect_result_missingFields =Just e}))
  writeMessageBegin oprot ("connect", M_REPLY, seqid);
  write_Connect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disconnect (seqid, iprot, oprot, handler) = do
  args <- read_Disconnect_args iprot
  readMessageEnd iprot
  rs <- return (Disconnect_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.disconnect handler (f_Disconnect_args_srcNode args) (f_Disconnect_args_srcPort args) (f_Disconnect_args_dstNode args) (f_Disconnect_args_dstPort args) (f_Disconnect_args_definition args)
      return rs)
    (\e  -> 
      return rs{f_Disconnect_result_missingFields =Just e}))
  writeMessageBegin oprot ("disconnect", M_REPLY, seqid);
  write_Disconnect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  readMessageEnd iprot
  rs <- return (Ping_result)
  res <- (do
    Iface.ping handler
    return rs)
  writeMessageBegin oprot ("ping", M_REPLY, seqid);
  write_Ping_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "libraries" -> process_libraries (seqid,iprot,oprot,handler)
  "loadLibrary" -> process_loadLibrary (seqid,iprot,oprot,handler)
  "unloadLibrary" -> process_unloadLibrary (seqid,iprot,oprot,handler)
  "libraryRootDef" -> process_libraryRootDef (seqid,iprot,oprot,handler)
  "newDefinition" -> process_newDefinition (seqid,iprot,oprot,handler)
  "addDefinition" -> process_addDefinition (seqid,iprot,oprot,handler)
  "updateDefinition" -> process_updateDefinition (seqid,iprot,oprot,handler)
  "removeDefinition" -> process_removeDefinition (seqid,iprot,oprot,handler)
  "definitionChildren" -> process_definitionChildren (seqid,iprot,oprot,handler)
  "definitionParent" -> process_definitionParent (seqid,iprot,oprot,handler)
  "newTypeModule" -> process_newTypeModule (seqid,iprot,oprot,handler)
  "newTypeClass" -> process_newTypeClass (seqid,iprot,oprot,handler)
  "newTypeFunction" -> process_newTypeFunction (seqid,iprot,oprot,handler)
  "newTypeUdefined" -> process_newTypeUdefined (seqid,iprot,oprot,handler)
  "newTypeNamed" -> process_newTypeNamed (seqid,iprot,oprot,handler)
  "newTypeVariable" -> process_newTypeVariable (seqid,iprot,oprot,handler)
  "newTypeList" -> process_newTypeList (seqid,iprot,oprot,handler)
  "newTypeTuple" -> process_newTypeTuple (seqid,iprot,oprot,handler)
  "graph" -> process_graph (seqid,iprot,oprot,handler)
  "addNode" -> process_addNode (seqid,iprot,oprot,handler)
  "updateNode" -> process_updateNode (seqid,iprot,oprot,handler)
  "removeNode" -> process_removeNode (seqid,iprot,oprot,handler)
  "connect" -> process_connect (seqid,iprot,oprot,handler)
  "disconnect" -> process_disconnect (seqid,iprot,oprot,handler)
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
