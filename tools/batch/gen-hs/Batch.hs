{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.0)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Batch where
import Prelude ( Bool(..), Enum, Double, String, Maybe(..),
                 Eq, Show, Ord,
                 return, length, IO, fromIntegral, fromEnum, toEnum,
                 (.), (&&), (||), (==), (++), ($), (-) )

import Control.Exception
import Data.ByteString.Lazy
import Data.Hashable
import Data.Int
import Data.Text.Lazy ( Text )
import qualified Data.Text.Lazy as TL
import Data.Typeable ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector

import Thrift
import Thrift.Types ()

import  Attrs_Types
import  Defs_Types
import  Graph_Types
import  Libs_Types
import  Types_Types


import Batch_Types
import qualified Batch_Iface as Iface
-- HELPER FUNCTIONS AND STRUCTURES --

data Libraries_args = Libraries_args deriving (Show,Eq,Typeable)
instance Hashable Libraries_args where
  hashWithSalt salt record = salt  
write_Libraries_args oprot record = do
  writeStructBegin oprot "Libraries_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_args_fields iprot record = do
  (_,_t8,_id9) <- readFieldBegin iprot
  if _t8 == T_STOP then return record else
    case _id9 of 
      _ -> do
        skip iprot _t8
        readFieldEnd iprot
        read_Libraries_args_fields iprot record
read_Libraries_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_args_fields iprot (Libraries_args{})
  readStructEnd iprot
  return record
data Libraries_result = Libraries_result{f_Libraries_result_success :: Maybe (Vector.Vector Libs_Types.Library)} deriving (Show,Eq,Typeable)
instance Hashable Libraries_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Libraries_result_success record  
write_Libraries_result oprot record = do
  writeStructBegin oprot "Libraries_result"
  case f_Libraries_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter12 -> Libs_Types.write_Library oprot _viter12) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Libraries_result_fields iprot record = do
  (_,_t14,_id15) <- readFieldBegin iprot
  if _t14 == T_STOP then return record else
    case _id15 of 
      0 -> if _t14 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Library iprot)) in do {(_etype19,_size16) <- readListBegin iprot; f _size16})
        read_Libraries_result_fields iprot record{f_Libraries_result_success=Just s}
        else do
          skip iprot _t14
          read_Libraries_result_fields iprot record
      _ -> do
        skip iprot _t14
        readFieldEnd iprot
        read_Libraries_result_fields iprot record
read_Libraries_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Libraries_result_fields iprot (Libraries_result{f_Libraries_result_success=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_args = LoadLibrary_args{f_LoadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_args_library record  
write_LoadLibrary_args oprot record = do
  writeStructBegin oprot "LoadLibrary_args"
  case f_LoadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_args_fields iprot record = do
  (_,_t24,_id25) <- readFieldBegin iprot
  if _t24 == T_STOP then return record else
    case _id25 of 
      1 -> if _t24 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_args_fields iprot record{f_LoadLibrary_args_library=Just s}
        else do
          skip iprot _t24
          read_LoadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t24
        readFieldEnd iprot
        read_LoadLibrary_args_fields iprot record
read_LoadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_args_fields iprot (LoadLibrary_args{f_LoadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data LoadLibrary_result = LoadLibrary_result{f_LoadLibrary_result_success :: Maybe Libs_Types.Library,f_LoadLibrary_result_missingFields :: Maybe MissingFieldsException} deriving (Show,Eq,Typeable)
instance Hashable LoadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_LoadLibrary_result_success record   `hashWithSalt` f_LoadLibrary_result_missingFields record  
write_LoadLibrary_result oprot record = do
  writeStructBegin oprot "LoadLibrary_result"
  case f_LoadLibrary_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  case f_LoadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_MissingFieldsException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_LoadLibrary_result_fields iprot record = do
  (_,_t29,_id30) <- readFieldBegin iprot
  if _t29 == T_STOP then return record else
    case _id30 of 
      0 -> if _t29 == T_STRUCT then do
        s <- (read_Library iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_success=Just s}
        else do
          skip iprot _t29
          read_LoadLibrary_result_fields iprot record
      1 -> if _t29 == T_STRUCT then do
        s <- (read_MissingFieldsException iprot)
        read_LoadLibrary_result_fields iprot record{f_LoadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t29
          read_LoadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t29
        readFieldEnd iprot
        read_LoadLibrary_result_fields iprot record
read_LoadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_LoadLibrary_result_fields iprot (LoadLibrary_result{f_LoadLibrary_result_success=Nothing,f_LoadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_args = UnloadLibrary_args{f_UnloadLibrary_args_library :: Maybe Libs_Types.Library} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_args_library record  
write_UnloadLibrary_args oprot record = do
  writeStructBegin oprot "UnloadLibrary_args"
  case f_UnloadLibrary_args_library record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("library",T_STRUCT,1)
    Libs_Types.write_Library oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_args_fields iprot record = do
  (_,_t34,_id35) <- readFieldBegin iprot
  if _t34 == T_STOP then return record else
    case _id35 of 
      1 -> if _t34 == T_STRUCT then do
        s <- (read_Library iprot)
        read_UnloadLibrary_args_fields iprot record{f_UnloadLibrary_args_library=Just s}
        else do
          skip iprot _t34
          read_UnloadLibrary_args_fields iprot record
      _ -> do
        skip iprot _t34
        readFieldEnd iprot
        read_UnloadLibrary_args_fields iprot record
read_UnloadLibrary_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_args_fields iprot (UnloadLibrary_args{f_UnloadLibrary_args_library=Nothing})
  readStructEnd iprot
  return record
data UnloadLibrary_result = UnloadLibrary_result{f_UnloadLibrary_result_missingFields :: Maybe MissingFieldsException} deriving (Show,Eq,Typeable)
instance Hashable UnloadLibrary_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_UnloadLibrary_result_missingFields record  
write_UnloadLibrary_result oprot record = do
  writeStructBegin oprot "UnloadLibrary_result"
  case f_UnloadLibrary_result_missingFields record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("missingFields",T_STRUCT,1)
    write_MissingFieldsException oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UnloadLibrary_result_fields iprot record = do
  (_,_t39,_id40) <- readFieldBegin iprot
  if _t39 == T_STOP then return record else
    case _id40 of 
      1 -> if _t39 == T_STRUCT then do
        s <- (read_MissingFieldsException iprot)
        read_UnloadLibrary_result_fields iprot record{f_UnloadLibrary_result_missingFields=Just s}
        else do
          skip iprot _t39
          read_UnloadLibrary_result_fields iprot record
      _ -> do
        skip iprot _t39
        readFieldEnd iprot
        read_UnloadLibrary_result_fields iprot record
read_UnloadLibrary_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UnloadLibrary_result_fields iprot (UnloadLibrary_result{f_UnloadLibrary_result_missingFields=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_args = NewDefinition_args{f_NewDefinition_args_type :: Maybe Types_Types.Type,f_NewDefinition_args_flags :: Maybe Attrs_Types.Flags,f_NewDefinition_args_attrs :: Maybe Attrs_Types.Attributes} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_args_type record   `hashWithSalt` f_NewDefinition_args_flags record   `hashWithSalt` f_NewDefinition_args_attrs record  
write_NewDefinition_args oprot record = do
  writeStructBegin oprot "NewDefinition_args"
  case f_NewDefinition_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_flags record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("flags",T_STRUCT,2)
    Attrs_Types.write_Flags oprot _v
    writeFieldEnd oprot}
  case f_NewDefinition_args_attrs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("attrs",T_STRUCT,3)
    Attrs_Types.write_Attributes oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_args_fields iprot record = do
  (_,_t44,_id45) <- readFieldBegin iprot
  if _t44 == T_STOP then return record else
    case _id45 of 
      1 -> if _t44 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_type=Just s}
        else do
          skip iprot _t44
          read_NewDefinition_args_fields iprot record
      2 -> if _t44 == T_STRUCT then do
        s <- (read_Flags iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_flags=Just s}
        else do
          skip iprot _t44
          read_NewDefinition_args_fields iprot record
      3 -> if _t44 == T_STRUCT then do
        s <- (read_Attributes iprot)
        read_NewDefinition_args_fields iprot record{f_NewDefinition_args_attrs=Just s}
        else do
          skip iprot _t44
          read_NewDefinition_args_fields iprot record
      _ -> do
        skip iprot _t44
        readFieldEnd iprot
        read_NewDefinition_args_fields iprot record
read_NewDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_args_fields iprot (NewDefinition_args{f_NewDefinition_args_type=Nothing,f_NewDefinition_args_flags=Nothing,f_NewDefinition_args_attrs=Nothing})
  readStructEnd iprot
  return record
data NewDefinition_result = NewDefinition_result{f_NewDefinition_result_success :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable NewDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewDefinition_result_success record  
write_NewDefinition_result oprot record = do
  writeStructBegin oprot "NewDefinition_result"
  case f_NewDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewDefinition_result_fields iprot record = do
  (_,_t49,_id50) <- readFieldBegin iprot
  if _t49 == T_STOP then return record else
    case _id50 of 
      0 -> if _t49 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_NewDefinition_result_fields iprot record{f_NewDefinition_result_success=Just s}
        else do
          skip iprot _t49
          read_NewDefinition_result_fields iprot record
      _ -> do
        skip iprot _t49
        readFieldEnd iprot
        read_NewDefinition_result_fields iprot record
read_NewDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewDefinition_result_fields iprot (NewDefinition_result{f_NewDefinition_result_success=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_args = AddDefinition_args{f_AddDefinition_args_definition :: Maybe Defs_Types.NodeDefinition,f_AddDefinition_args_parent :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_args_definition record   `hashWithSalt` f_AddDefinition_args_parent record  
write_AddDefinition_args oprot record = do
  writeStructBegin oprot "AddDefinition_args"
  case f_AddDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  case f_AddDefinition_args_parent record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("parent",T_STRUCT,2)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_args_fields iprot record = do
  (_,_t54,_id55) <- readFieldBegin iprot
  if _t54 == T_STOP then return record else
    case _id55 of 
      1 -> if _t54 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_definition=Just s}
        else do
          skip iprot _t54
          read_AddDefinition_args_fields iprot record
      2 -> if _t54 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_AddDefinition_args_fields iprot record{f_AddDefinition_args_parent=Just s}
        else do
          skip iprot _t54
          read_AddDefinition_args_fields iprot record
      _ -> do
        skip iprot _t54
        readFieldEnd iprot
        read_AddDefinition_args_fields iprot record
read_AddDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_args_fields iprot (AddDefinition_args{f_AddDefinition_args_definition=Nothing,f_AddDefinition_args_parent=Nothing})
  readStructEnd iprot
  return record
data AddDefinition_result = AddDefinition_result{f_AddDefinition_result_success :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable AddDefinition_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddDefinition_result_success record  
write_AddDefinition_result oprot record = do
  writeStructBegin oprot "AddDefinition_result"
  case f_AddDefinition_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddDefinition_result_fields iprot record = do
  (_,_t59,_id60) <- readFieldBegin iprot
  if _t59 == T_STOP then return record else
    case _id60 of 
      0 -> if _t59 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_AddDefinition_result_fields iprot record{f_AddDefinition_result_success=Just s}
        else do
          skip iprot _t59
          read_AddDefinition_result_fields iprot record
      _ -> do
        skip iprot _t59
        readFieldEnd iprot
        read_AddDefinition_result_fields iprot record
read_AddDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddDefinition_result_fields iprot (AddDefinition_result{f_AddDefinition_result_success=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_args = UpdateDefinition_args{f_UpdateDefinition_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateDefinition_args_definition record  
write_UpdateDefinition_args oprot record = do
  writeStructBegin oprot "UpdateDefinition_args"
  case f_UpdateDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_args_fields iprot record = do
  (_,_t64,_id65) <- readFieldBegin iprot
  if _t64 == T_STOP then return record else
    case _id65 of 
      1 -> if _t64 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_UpdateDefinition_args_fields iprot record{f_UpdateDefinition_args_definition=Just s}
        else do
          skip iprot _t64
          read_UpdateDefinition_args_fields iprot record
      _ -> do
        skip iprot _t64
        readFieldEnd iprot
        read_UpdateDefinition_args_fields iprot record
read_UpdateDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_args_fields iprot (UpdateDefinition_args{f_UpdateDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateDefinition_result = UpdateDefinition_result deriving (Show,Eq,Typeable)
instance Hashable UpdateDefinition_result where
  hashWithSalt salt record = salt  
write_UpdateDefinition_result oprot record = do
  writeStructBegin oprot "UpdateDefinition_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateDefinition_result_fields iprot record = do
  (_,_t69,_id70) <- readFieldBegin iprot
  if _t69 == T_STOP then return record else
    case _id70 of 
      _ -> do
        skip iprot _t69
        readFieldEnd iprot
        read_UpdateDefinition_result_fields iprot record
read_UpdateDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateDefinition_result_fields iprot (UpdateDefinition_result{})
  readStructEnd iprot
  return record
data RemoveDefinition_args = RemoveDefinition_args{f_RemoveDefinition_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveDefinition_args_definition record  
write_RemoveDefinition_args oprot record = do
  writeStructBegin oprot "RemoveDefinition_args"
  case f_RemoveDefinition_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_args_fields iprot record = do
  (_,_t74,_id75) <- readFieldBegin iprot
  if _t74 == T_STOP then return record else
    case _id75 of 
      1 -> if _t74 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_RemoveDefinition_args_fields iprot record{f_RemoveDefinition_args_definition=Just s}
        else do
          skip iprot _t74
          read_RemoveDefinition_args_fields iprot record
      _ -> do
        skip iprot _t74
        readFieldEnd iprot
        read_RemoveDefinition_args_fields iprot record
read_RemoveDefinition_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_args_fields iprot (RemoveDefinition_args{f_RemoveDefinition_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveDefinition_result = RemoveDefinition_result deriving (Show,Eq,Typeable)
instance Hashable RemoveDefinition_result where
  hashWithSalt salt record = salt  
write_RemoveDefinition_result oprot record = do
  writeStructBegin oprot "RemoveDefinition_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveDefinition_result_fields iprot record = do
  (_,_t79,_id80) <- readFieldBegin iprot
  if _t79 == T_STOP then return record else
    case _id80 of 
      _ -> do
        skip iprot _t79
        readFieldEnd iprot
        read_RemoveDefinition_result_fields iprot record
read_RemoveDefinition_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveDefinition_result_fields iprot (RemoveDefinition_result{})
  readStructEnd iprot
  return record
data DefinitionChildren_args = DefinitionChildren_args{f_DefinitionChildren_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_args_definition record  
write_DefinitionChildren_args oprot record = do
  writeStructBegin oprot "DefinitionChildren_args"
  case f_DefinitionChildren_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_args_fields iprot record = do
  (_,_t84,_id85) <- readFieldBegin iprot
  if _t84 == T_STOP then return record else
    case _id85 of 
      1 -> if _t84 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_DefinitionChildren_args_fields iprot record{f_DefinitionChildren_args_definition=Just s}
        else do
          skip iprot _t84
          read_DefinitionChildren_args_fields iprot record
      _ -> do
        skip iprot _t84
        readFieldEnd iprot
        read_DefinitionChildren_args_fields iprot record
read_DefinitionChildren_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_args_fields iprot (DefinitionChildren_args{f_DefinitionChildren_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionChildren_result = DefinitionChildren_result{f_DefinitionChildren_result_success :: Maybe (Vector.Vector Defs_Types.NodeDefinition)} deriving (Show,Eq,Typeable)
instance Hashable DefinitionChildren_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionChildren_result_success record  
write_DefinitionChildren_result oprot record = do
  writeStructBegin oprot "DefinitionChildren_result"
  case f_DefinitionChildren_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_LIST,0)
    (let f = Vector.mapM_ (\_viter88 -> Defs_Types.write_NodeDefinition oprot _viter88) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionChildren_result_fields iprot record = do
  (_,_t90,_id91) <- readFieldBegin iprot
  if _t90 == T_STOP then return record else
    case _id91 of 
      0 -> if _t90 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_NodeDefinition iprot)) in do {(_etype95,_size92) <- readListBegin iprot; f _size92})
        read_DefinitionChildren_result_fields iprot record{f_DefinitionChildren_result_success=Just s}
        else do
          skip iprot _t90
          read_DefinitionChildren_result_fields iprot record
      _ -> do
        skip iprot _t90
        readFieldEnd iprot
        read_DefinitionChildren_result_fields iprot record
read_DefinitionChildren_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionChildren_result_fields iprot (DefinitionChildren_result{f_DefinitionChildren_result_success=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_args = DefinitionParent_args{f_DefinitionParent_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_args_definition record  
write_DefinitionParent_args oprot record = do
  writeStructBegin oprot "DefinitionParent_args"
  case f_DefinitionParent_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_args_fields iprot record = do
  (_,_t100,_id101) <- readFieldBegin iprot
  if _t100 == T_STOP then return record else
    case _id101 of 
      1 -> if _t100 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_DefinitionParent_args_fields iprot record{f_DefinitionParent_args_definition=Just s}
        else do
          skip iprot _t100
          read_DefinitionParent_args_fields iprot record
      _ -> do
        skip iprot _t100
        readFieldEnd iprot
        read_DefinitionParent_args_fields iprot record
read_DefinitionParent_args iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_args_fields iprot (DefinitionParent_args{f_DefinitionParent_args_definition=Nothing})
  readStructEnd iprot
  return record
data DefinitionParent_result = DefinitionParent_result{f_DefinitionParent_result_success :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable DefinitionParent_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_DefinitionParent_result_success record  
write_DefinitionParent_result oprot record = do
  writeStructBegin oprot "DefinitionParent_result"
  case f_DefinitionParent_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_DefinitionParent_result_fields iprot record = do
  (_,_t105,_id106) <- readFieldBegin iprot
  if _t105 == T_STOP then return record else
    case _id106 of 
      0 -> if _t105 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_DefinitionParent_result_fields iprot record{f_DefinitionParent_result_success=Just s}
        else do
          skip iprot _t105
          read_DefinitionParent_result_fields iprot record
      _ -> do
        skip iprot _t105
        readFieldEnd iprot
        read_DefinitionParent_result_fields iprot record
read_DefinitionParent_result iprot = do
  _ <- readStructBegin iprot
  record <- read_DefinitionParent_result_fields iprot (DefinitionParent_result{f_DefinitionParent_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_args = NewTypeModule_args{f_NewTypeModule_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_args_name record  
write_NewTypeModule_args oprot record = do
  writeStructBegin oprot "NewTypeModule_args"
  case f_NewTypeModule_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_args_fields iprot record = do
  (_,_t110,_id111) <- readFieldBegin iprot
  if _t110 == T_STOP then return record else
    case _id111 of 
      1 -> if _t110 == T_STRING then do
        s <- readString iprot
        read_NewTypeModule_args_fields iprot record{f_NewTypeModule_args_name=Just s}
        else do
          skip iprot _t110
          read_NewTypeModule_args_fields iprot record
      _ -> do
        skip iprot _t110
        readFieldEnd iprot
        read_NewTypeModule_args_fields iprot record
read_NewTypeModule_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_args_fields iprot (NewTypeModule_args{f_NewTypeModule_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeModule_result = NewTypeModule_result{f_NewTypeModule_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeModule_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeModule_result_success record  
write_NewTypeModule_result oprot record = do
  writeStructBegin oprot "NewTypeModule_result"
  case f_NewTypeModule_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeModule_result_fields iprot record = do
  (_,_t115,_id116) <- readFieldBegin iprot
  if _t115 == T_STOP then return record else
    case _id116 of 
      0 -> if _t115 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeModule_result_fields iprot record{f_NewTypeModule_result_success=Just s}
        else do
          skip iprot _t115
          read_NewTypeModule_result_fields iprot record
      _ -> do
        skip iprot _t115
        readFieldEnd iprot
        read_NewTypeModule_result_fields iprot record
read_NewTypeModule_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeModule_result_fields iprot (NewTypeModule_result{f_NewTypeModule_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_args = NewTypeClass_args{f_NewTypeClass_args_name :: Maybe Text,f_NewTypeClass_args_params :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_args_name record   `hashWithSalt` f_NewTypeClass_args_params record  
write_NewTypeClass_args oprot record = do
  writeStructBegin oprot "NewTypeClass_args"
  case f_NewTypeClass_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeClass_args_params record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("params",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_args_fields iprot record = do
  (_,_t120,_id121) <- readFieldBegin iprot
  if _t120 == T_STOP then return record else
    case _id121 of 
      1 -> if _t120 == T_STRING then do
        s <- readString iprot
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_name=Just s}
        else do
          skip iprot _t120
          read_NewTypeClass_args_fields iprot record
      2 -> if _t120 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_args_fields iprot record{f_NewTypeClass_args_params=Just s}
        else do
          skip iprot _t120
          read_NewTypeClass_args_fields iprot record
      _ -> do
        skip iprot _t120
        readFieldEnd iprot
        read_NewTypeClass_args_fields iprot record
read_NewTypeClass_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_args_fields iprot (NewTypeClass_args{f_NewTypeClass_args_name=Nothing,f_NewTypeClass_args_params=Nothing})
  readStructEnd iprot
  return record
data NewTypeClass_result = NewTypeClass_result{f_NewTypeClass_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeClass_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeClass_result_success record  
write_NewTypeClass_result oprot record = do
  writeStructBegin oprot "NewTypeClass_result"
  case f_NewTypeClass_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeClass_result_fields iprot record = do
  (_,_t125,_id126) <- readFieldBegin iprot
  if _t125 == T_STOP then return record else
    case _id126 of 
      0 -> if _t125 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeClass_result_fields iprot record{f_NewTypeClass_result_success=Just s}
        else do
          skip iprot _t125
          read_NewTypeClass_result_fields iprot record
      _ -> do
        skip iprot _t125
        readFieldEnd iprot
        read_NewTypeClass_result_fields iprot record
read_NewTypeClass_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeClass_result_fields iprot (NewTypeClass_result{f_NewTypeClass_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_args = NewTypeFunction_args{f_NewTypeFunction_args_name :: Maybe Text,f_NewTypeFunction_args_inputs :: Maybe Types_Types.Type,f_NewTypeFunction_args_outputs :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_args_name record   `hashWithSalt` f_NewTypeFunction_args_inputs record   `hashWithSalt` f_NewTypeFunction_args_outputs record  
write_NewTypeFunction_args oprot record = do
  writeStructBegin oprot "NewTypeFunction_args"
  case f_NewTypeFunction_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_inputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("inputs",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  case f_NewTypeFunction_args_outputs record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("outputs",T_STRUCT,3)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_args_fields iprot record = do
  (_,_t130,_id131) <- readFieldBegin iprot
  if _t130 == T_STOP then return record else
    case _id131 of 
      1 -> if _t130 == T_STRING then do
        s <- readString iprot
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_name=Just s}
        else do
          skip iprot _t130
          read_NewTypeFunction_args_fields iprot record
      2 -> if _t130 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_inputs=Just s}
        else do
          skip iprot _t130
          read_NewTypeFunction_args_fields iprot record
      3 -> if _t130 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_args_fields iprot record{f_NewTypeFunction_args_outputs=Just s}
        else do
          skip iprot _t130
          read_NewTypeFunction_args_fields iprot record
      _ -> do
        skip iprot _t130
        readFieldEnd iprot
        read_NewTypeFunction_args_fields iprot record
read_NewTypeFunction_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_args_fields iprot (NewTypeFunction_args{f_NewTypeFunction_args_name=Nothing,f_NewTypeFunction_args_inputs=Nothing,f_NewTypeFunction_args_outputs=Nothing})
  readStructEnd iprot
  return record
data NewTypeFunction_result = NewTypeFunction_result{f_NewTypeFunction_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeFunction_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeFunction_result_success record  
write_NewTypeFunction_result oprot record = do
  writeStructBegin oprot "NewTypeFunction_result"
  case f_NewTypeFunction_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeFunction_result_fields iprot record = do
  (_,_t135,_id136) <- readFieldBegin iprot
  if _t135 == T_STOP then return record else
    case _id136 of 
      0 -> if _t135 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeFunction_result_fields iprot record{f_NewTypeFunction_result_success=Just s}
        else do
          skip iprot _t135
          read_NewTypeFunction_result_fields iprot record
      _ -> do
        skip iprot _t135
        readFieldEnd iprot
        read_NewTypeFunction_result_fields iprot record
read_NewTypeFunction_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeFunction_result_fields iprot (NewTypeFunction_result{f_NewTypeFunction_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeUdefined_args = NewTypeUdefined_args deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_args where
  hashWithSalt salt record = salt  
write_NewTypeUdefined_args oprot record = do
  writeStructBegin oprot "NewTypeUdefined_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_args_fields iprot record = do
  (_,_t140,_id141) <- readFieldBegin iprot
  if _t140 == T_STOP then return record else
    case _id141 of 
      _ -> do
        skip iprot _t140
        readFieldEnd iprot
        read_NewTypeUdefined_args_fields iprot record
read_NewTypeUdefined_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_args_fields iprot (NewTypeUdefined_args{})
  readStructEnd iprot
  return record
data NewTypeUdefined_result = NewTypeUdefined_result{f_NewTypeUdefined_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeUdefined_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeUdefined_result_success record  
write_NewTypeUdefined_result oprot record = do
  writeStructBegin oprot "NewTypeUdefined_result"
  case f_NewTypeUdefined_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeUdefined_result_fields iprot record = do
  (_,_t145,_id146) <- readFieldBegin iprot
  if _t145 == T_STOP then return record else
    case _id146 of 
      0 -> if _t145 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeUdefined_result_fields iprot record{f_NewTypeUdefined_result_success=Just s}
        else do
          skip iprot _t145
          read_NewTypeUdefined_result_fields iprot record
      _ -> do
        skip iprot _t145
        readFieldEnd iprot
        read_NewTypeUdefined_result_fields iprot record
read_NewTypeUdefined_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeUdefined_result_fields iprot (NewTypeUdefined_result{f_NewTypeUdefined_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_args = NewTypeNamed_args{f_NewTypeNamed_args_name :: Maybe Text} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_args_name record  
write_NewTypeNamed_args oprot record = do
  writeStructBegin oprot "NewTypeNamed_args"
  case f_NewTypeNamed_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_args_fields iprot record = do
  (_,_t150,_id151) <- readFieldBegin iprot
  if _t150 == T_STOP then return record else
    case _id151 of 
      1 -> if _t150 == T_STRING then do
        s <- readString iprot
        read_NewTypeNamed_args_fields iprot record{f_NewTypeNamed_args_name=Just s}
        else do
          skip iprot _t150
          read_NewTypeNamed_args_fields iprot record
      _ -> do
        skip iprot _t150
        readFieldEnd iprot
        read_NewTypeNamed_args_fields iprot record
read_NewTypeNamed_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_args_fields iprot (NewTypeNamed_args{f_NewTypeNamed_args_name=Nothing})
  readStructEnd iprot
  return record
data NewTypeNamed_result = NewTypeNamed_result{f_NewTypeNamed_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeNamed_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeNamed_result_success record  
write_NewTypeNamed_result oprot record = do
  writeStructBegin oprot "NewTypeNamed_result"
  case f_NewTypeNamed_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeNamed_result_fields iprot record = do
  (_,_t155,_id156) <- readFieldBegin iprot
  if _t155 == T_STOP then return record else
    case _id156 of 
      0 -> if _t155 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeNamed_result_fields iprot record{f_NewTypeNamed_result_success=Just s}
        else do
          skip iprot _t155
          read_NewTypeNamed_result_fields iprot record
      _ -> do
        skip iprot _t155
        readFieldEnd iprot
        read_NewTypeNamed_result_fields iprot record
read_NewTypeNamed_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeNamed_result_fields iprot (NewTypeNamed_result{f_NewTypeNamed_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_args = NewTypeVariable_args{f_NewTypeVariable_args_name :: Maybe Text,f_NewTypeVariable_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_args_name record   `hashWithSalt` f_NewTypeVariable_args_type record  
write_NewTypeVariable_args oprot record = do
  writeStructBegin oprot "NewTypeVariable_args"
  case f_NewTypeVariable_args_name record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("name",T_STRING,1)
    writeString oprot _v
    writeFieldEnd oprot}
  case f_NewTypeVariable_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,2)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_args_fields iprot record = do
  (_,_t160,_id161) <- readFieldBegin iprot
  if _t160 == T_STOP then return record else
    case _id161 of 
      1 -> if _t160 == T_STRING then do
        s <- readString iprot
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_name=Just s}
        else do
          skip iprot _t160
          read_NewTypeVariable_args_fields iprot record
      2 -> if _t160 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_args_fields iprot record{f_NewTypeVariable_args_type=Just s}
        else do
          skip iprot _t160
          read_NewTypeVariable_args_fields iprot record
      _ -> do
        skip iprot _t160
        readFieldEnd iprot
        read_NewTypeVariable_args_fields iprot record
read_NewTypeVariable_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_args_fields iprot (NewTypeVariable_args{f_NewTypeVariable_args_name=Nothing,f_NewTypeVariable_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeVariable_result = NewTypeVariable_result{f_NewTypeVariable_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeVariable_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeVariable_result_success record  
write_NewTypeVariable_result oprot record = do
  writeStructBegin oprot "NewTypeVariable_result"
  case f_NewTypeVariable_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeVariable_result_fields iprot record = do
  (_,_t165,_id166) <- readFieldBegin iprot
  if _t165 == T_STOP then return record else
    case _id166 of 
      0 -> if _t165 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeVariable_result_fields iprot record{f_NewTypeVariable_result_success=Just s}
        else do
          skip iprot _t165
          read_NewTypeVariable_result_fields iprot record
      _ -> do
        skip iprot _t165
        readFieldEnd iprot
        read_NewTypeVariable_result_fields iprot record
read_NewTypeVariable_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeVariable_result_fields iprot (NewTypeVariable_result{f_NewTypeVariable_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_args = NewTypeList_args{f_NewTypeList_args_type :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_args_type record  
write_NewTypeList_args oprot record = do
  writeStructBegin oprot "NewTypeList_args"
  case f_NewTypeList_args_type record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("type",T_STRUCT,1)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_args_fields iprot record = do
  (_,_t170,_id171) <- readFieldBegin iprot
  if _t170 == T_STOP then return record else
    case _id171 of 
      1 -> if _t170 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_args_fields iprot record{f_NewTypeList_args_type=Just s}
        else do
          skip iprot _t170
          read_NewTypeList_args_fields iprot record
      _ -> do
        skip iprot _t170
        readFieldEnd iprot
        read_NewTypeList_args_fields iprot record
read_NewTypeList_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_args_fields iprot (NewTypeList_args{f_NewTypeList_args_type=Nothing})
  readStructEnd iprot
  return record
data NewTypeList_result = NewTypeList_result{f_NewTypeList_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeList_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeList_result_success record  
write_NewTypeList_result oprot record = do
  writeStructBegin oprot "NewTypeList_result"
  case f_NewTypeList_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeList_result_fields iprot record = do
  (_,_t175,_id176) <- readFieldBegin iprot
  if _t175 == T_STOP then return record else
    case _id176 of 
      0 -> if _t175 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeList_result_fields iprot record{f_NewTypeList_result_success=Just s}
        else do
          skip iprot _t175
          read_NewTypeList_result_fields iprot record
      _ -> do
        skip iprot _t175
        readFieldEnd iprot
        read_NewTypeList_result_fields iprot record
read_NewTypeList_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeList_result_fields iprot (NewTypeList_result{f_NewTypeList_result_success=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_args = NewTypeTuple_args{f_NewTypeTuple_args_types :: Maybe (Vector.Vector Types_Types.Type)} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_args_types record  
write_NewTypeTuple_args oprot record = do
  writeStructBegin oprot "NewTypeTuple_args"
  case f_NewTypeTuple_args_types record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("types",T_LIST,1)
    (let f = Vector.mapM_ (\_viter179 -> Types_Types.write_Type oprot _viter179) in do {writeListBegin oprot (T_STRUCT,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_args_fields iprot record = do
  (_,_t181,_id182) <- readFieldBegin iprot
  if _t181 == T_STOP then return record else
    case _id182 of 
      1 -> if _t181 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) ((read_Type iprot)) in do {(_etype186,_size183) <- readListBegin iprot; f _size183})
        read_NewTypeTuple_args_fields iprot record{f_NewTypeTuple_args_types=Just s}
        else do
          skip iprot _t181
          read_NewTypeTuple_args_fields iprot record
      _ -> do
        skip iprot _t181
        readFieldEnd iprot
        read_NewTypeTuple_args_fields iprot record
read_NewTypeTuple_args iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_args_fields iprot (NewTypeTuple_args{f_NewTypeTuple_args_types=Nothing})
  readStructEnd iprot
  return record
data NewTypeTuple_result = NewTypeTuple_result{f_NewTypeTuple_result_success :: Maybe Types_Types.Type} deriving (Show,Eq,Typeable)
instance Hashable NewTypeTuple_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_NewTypeTuple_result_success record  
write_NewTypeTuple_result oprot record = do
  writeStructBegin oprot "NewTypeTuple_result"
  case f_NewTypeTuple_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Types_Types.write_Type oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_NewTypeTuple_result_fields iprot record = do
  (_,_t191,_id192) <- readFieldBegin iprot
  if _t191 == T_STOP then return record else
    case _id192 of 
      0 -> if _t191 == T_STRUCT then do
        s <- (read_Type iprot)
        read_NewTypeTuple_result_fields iprot record{f_NewTypeTuple_result_success=Just s}
        else do
          skip iprot _t191
          read_NewTypeTuple_result_fields iprot record
      _ -> do
        skip iprot _t191
        readFieldEnd iprot
        read_NewTypeTuple_result_fields iprot record
read_NewTypeTuple_result iprot = do
  _ <- readStructBegin iprot
  record <- read_NewTypeTuple_result_fields iprot (NewTypeTuple_result{f_NewTypeTuple_result_success=Nothing})
  readStructEnd iprot
  return record
data Graph_args = Graph_args{f_Graph_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable Graph_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_args_definition record  
write_Graph_args oprot record = do
  writeStructBegin oprot "Graph_args"
  case f_Graph_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,1)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_args_fields iprot record = do
  (_,_t196,_id197) <- readFieldBegin iprot
  if _t196 == T_STOP then return record else
    case _id197 of 
      1 -> if _t196 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_Graph_args_fields iprot record{f_Graph_args_definition=Just s}
        else do
          skip iprot _t196
          read_Graph_args_fields iprot record
      _ -> do
        skip iprot _t196
        readFieldEnd iprot
        read_Graph_args_fields iprot record
read_Graph_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_args_fields iprot (Graph_args{f_Graph_args_definition=Nothing})
  readStructEnd iprot
  return record
data Graph_result = Graph_result{f_Graph_result_success :: Maybe Graph_Types.Graph} deriving (Show,Eq,Typeable)
instance Hashable Graph_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_Graph_result_success record  
write_Graph_result oprot record = do
  writeStructBegin oprot "Graph_result"
  case f_Graph_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Graph oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Graph_result_fields iprot record = do
  (_,_t201,_id202) <- readFieldBegin iprot
  if _t201 == T_STOP then return record else
    case _id202 of 
      0 -> if _t201 == T_STRUCT then do
        s <- (read_Graph iprot)
        read_Graph_result_fields iprot record{f_Graph_result_success=Just s}
        else do
          skip iprot _t201
          read_Graph_result_fields iprot record
      _ -> do
        skip iprot _t201
        readFieldEnd iprot
        read_Graph_result_fields iprot record
read_Graph_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Graph_result_fields iprot (Graph_result{f_Graph_result_success=Nothing})
  readStructEnd iprot
  return record
data AddNode_args = AddNode_args{f_AddNode_args_node :: Maybe Graph_Types.Node,f_AddNode_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable AddNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_args_node record   `hashWithSalt` f_AddNode_args_definition record  
write_AddNode_args oprot record = do
  writeStructBegin oprot "AddNode_args"
  case f_AddNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_AddNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_args_fields iprot record = do
  (_,_t206,_id207) <- readFieldBegin iprot
  if _t206 == T_STOP then return record else
    case _id207 of 
      1 -> if _t206 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_node=Just s}
        else do
          skip iprot _t206
          read_AddNode_args_fields iprot record
      2 -> if _t206 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_AddNode_args_fields iprot record{f_AddNode_args_definition=Just s}
        else do
          skip iprot _t206
          read_AddNode_args_fields iprot record
      _ -> do
        skip iprot _t206
        readFieldEnd iprot
        read_AddNode_args_fields iprot record
read_AddNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_args_fields iprot (AddNode_args{f_AddNode_args_node=Nothing,f_AddNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data AddNode_result = AddNode_result{f_AddNode_result_success :: Maybe Graph_Types.Node} deriving (Show,Eq,Typeable)
instance Hashable AddNode_result where
  hashWithSalt salt record = salt   `hashWithSalt` f_AddNode_result_success record  
write_AddNode_result oprot record = do
  writeStructBegin oprot "AddNode_result"
  case f_AddNode_result_success record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("success",T_STRUCT,0)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_AddNode_result_fields iprot record = do
  (_,_t211,_id212) <- readFieldBegin iprot
  if _t211 == T_STOP then return record else
    case _id212 of 
      0 -> if _t211 == T_STRUCT then do
        s <- (read_Node iprot)
        read_AddNode_result_fields iprot record{f_AddNode_result_success=Just s}
        else do
          skip iprot _t211
          read_AddNode_result_fields iprot record
      _ -> do
        skip iprot _t211
        readFieldEnd iprot
        read_AddNode_result_fields iprot record
read_AddNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_AddNode_result_fields iprot (AddNode_result{f_AddNode_result_success=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_args = UpdateNode_args{f_UpdateNode_args_node :: Maybe Graph_Types.Node,f_UpdateNode_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_UpdateNode_args_node record   `hashWithSalt` f_UpdateNode_args_definition record  
write_UpdateNode_args oprot record = do
  writeStructBegin oprot "UpdateNode_args"
  case f_UpdateNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_UpdateNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_args_fields iprot record = do
  (_,_t216,_id217) <- readFieldBegin iprot
  if _t216 == T_STOP then return record else
    case _id217 of 
      1 -> if _t216 == T_STRUCT then do
        s <- (read_Node iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_node=Just s}
        else do
          skip iprot _t216
          read_UpdateNode_args_fields iprot record
      2 -> if _t216 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_UpdateNode_args_fields iprot record{f_UpdateNode_args_definition=Just s}
        else do
          skip iprot _t216
          read_UpdateNode_args_fields iprot record
      _ -> do
        skip iprot _t216
        readFieldEnd iprot
        read_UpdateNode_args_fields iprot record
read_UpdateNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_args_fields iprot (UpdateNode_args{f_UpdateNode_args_node=Nothing,f_UpdateNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data UpdateNode_result = UpdateNode_result deriving (Show,Eq,Typeable)
instance Hashable UpdateNode_result where
  hashWithSalt salt record = salt  
write_UpdateNode_result oprot record = do
  writeStructBegin oprot "UpdateNode_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_UpdateNode_result_fields iprot record = do
  (_,_t221,_id222) <- readFieldBegin iprot
  if _t221 == T_STOP then return record else
    case _id222 of 
      _ -> do
        skip iprot _t221
        readFieldEnd iprot
        read_UpdateNode_result_fields iprot record
read_UpdateNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_UpdateNode_result_fields iprot (UpdateNode_result{})
  readStructEnd iprot
  return record
data RemoveNode_args = RemoveNode_args{f_RemoveNode_args_node :: Maybe Graph_Types.Node,f_RemoveNode_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_RemoveNode_args_node record   `hashWithSalt` f_RemoveNode_args_definition record  
write_RemoveNode_args oprot record = do
  writeStructBegin oprot "RemoveNode_args"
  case f_RemoveNode_args_node record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("node",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_RemoveNode_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,2)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_args_fields iprot record = do
  (_,_t226,_id227) <- readFieldBegin iprot
  if _t226 == T_STOP then return record else
    case _id227 of 
      1 -> if _t226 == T_STRUCT then do
        s <- (read_Node iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_node=Just s}
        else do
          skip iprot _t226
          read_RemoveNode_args_fields iprot record
      2 -> if _t226 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_RemoveNode_args_fields iprot record{f_RemoveNode_args_definition=Just s}
        else do
          skip iprot _t226
          read_RemoveNode_args_fields iprot record
      _ -> do
        skip iprot _t226
        readFieldEnd iprot
        read_RemoveNode_args_fields iprot record
read_RemoveNode_args iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_args_fields iprot (RemoveNode_args{f_RemoveNode_args_node=Nothing,f_RemoveNode_args_definition=Nothing})
  readStructEnd iprot
  return record
data RemoveNode_result = RemoveNode_result deriving (Show,Eq,Typeable)
instance Hashable RemoveNode_result where
  hashWithSalt salt record = salt  
write_RemoveNode_result oprot record = do
  writeStructBegin oprot "RemoveNode_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_RemoveNode_result_fields iprot record = do
  (_,_t231,_id232) <- readFieldBegin iprot
  if _t231 == T_STOP then return record else
    case _id232 of 
      _ -> do
        skip iprot _t231
        readFieldEnd iprot
        read_RemoveNode_result_fields iprot record
read_RemoveNode_result iprot = do
  _ <- readStructBegin iprot
  record <- read_RemoveNode_result_fields iprot (RemoveNode_result{})
  readStructEnd iprot
  return record
data Connect_args = Connect_args{f_Connect_args_srcNode :: Maybe Graph_Types.Node,f_Connect_args_srcPort :: Maybe (Vector.Vector Int32),f_Connect_args_dstNode :: Maybe Graph_Types.Node,f_Connect_args_dstPort :: Maybe (Vector.Vector Int32),f_Connect_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable Connect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Connect_args_srcNode record   `hashWithSalt` f_Connect_args_srcPort record   `hashWithSalt` f_Connect_args_dstNode record   `hashWithSalt` f_Connect_args_dstPort record   `hashWithSalt` f_Connect_args_definition record  
write_Connect_args oprot record = do
  writeStructBegin oprot "Connect_args"
  case f_Connect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter235 -> writeI32 oprot _viter235) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Connect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter236 -> writeI32 oprot _viter236) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Connect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_args_fields iprot record = do
  (_,_t238,_id239) <- readFieldBegin iprot
  if _t238 == T_STOP then return record else
    case _id239 of 
      1 -> if _t238 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_srcNode=Just s}
        else do
          skip iprot _t238
          read_Connect_args_fields iprot record
      2 -> if _t238 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype243,_size240) <- readListBegin iprot; f _size240})
        read_Connect_args_fields iprot record{f_Connect_args_srcPort=Just s}
        else do
          skip iprot _t238
          read_Connect_args_fields iprot record
      3 -> if _t238 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Connect_args_fields iprot record{f_Connect_args_dstNode=Just s}
        else do
          skip iprot _t238
          read_Connect_args_fields iprot record
      4 -> if _t238 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype248,_size245) <- readListBegin iprot; f _size245})
        read_Connect_args_fields iprot record{f_Connect_args_dstPort=Just s}
        else do
          skip iprot _t238
          read_Connect_args_fields iprot record
      5 -> if _t238 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_Connect_args_fields iprot record{f_Connect_args_definition=Just s}
        else do
          skip iprot _t238
          read_Connect_args_fields iprot record
      _ -> do
        skip iprot _t238
        readFieldEnd iprot
        read_Connect_args_fields iprot record
read_Connect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_args_fields iprot (Connect_args{f_Connect_args_srcNode=Nothing,f_Connect_args_srcPort=Nothing,f_Connect_args_dstNode=Nothing,f_Connect_args_dstPort=Nothing,f_Connect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Connect_result = Connect_result deriving (Show,Eq,Typeable)
instance Hashable Connect_result where
  hashWithSalt salt record = salt  
write_Connect_result oprot record = do
  writeStructBegin oprot "Connect_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Connect_result_fields iprot record = do
  (_,_t253,_id254) <- readFieldBegin iprot
  if _t253 == T_STOP then return record else
    case _id254 of 
      _ -> do
        skip iprot _t253
        readFieldEnd iprot
        read_Connect_result_fields iprot record
read_Connect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Connect_result_fields iprot (Connect_result{})
  readStructEnd iprot
  return record
data Disconnect_args = Disconnect_args{f_Disconnect_args_srcNode :: Maybe Graph_Types.Node,f_Disconnect_args_srcPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_dstNode :: Maybe Graph_Types.Node,f_Disconnect_args_dstPort :: Maybe (Vector.Vector Int32),f_Disconnect_args_definition :: Maybe Defs_Types.NodeDefinition} deriving (Show,Eq,Typeable)
instance Hashable Disconnect_args where
  hashWithSalt salt record = salt   `hashWithSalt` f_Disconnect_args_srcNode record   `hashWithSalt` f_Disconnect_args_srcPort record   `hashWithSalt` f_Disconnect_args_dstNode record   `hashWithSalt` f_Disconnect_args_dstPort record   `hashWithSalt` f_Disconnect_args_definition record  
write_Disconnect_args oprot record = do
  writeStructBegin oprot "Disconnect_args"
  case f_Disconnect_args_srcNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcNode",T_STRUCT,1)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_srcPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("srcPort",T_LIST,2)
    (let f = Vector.mapM_ (\_viter257 -> writeI32 oprot _viter257) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_dstNode record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstNode",T_STRUCT,3)
    Graph_Types.write_Node oprot _v
    writeFieldEnd oprot}
  case f_Disconnect_args_dstPort record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("dstPort",T_LIST,4)
    (let f = Vector.mapM_ (\_viter258 -> writeI32 oprot _viter258) in do {writeListBegin oprot (T_I32,fromIntegral $ Vector.length _v); f _v;writeListEnd oprot})
    writeFieldEnd oprot}
  case f_Disconnect_args_definition record of {Nothing -> return (); Just _v -> do
    writeFieldBegin oprot ("definition",T_STRUCT,5)
    Defs_Types.write_NodeDefinition oprot _v
    writeFieldEnd oprot}
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_args_fields iprot record = do
  (_,_t260,_id261) <- readFieldBegin iprot
  if _t260 == T_STOP then return record else
    case _id261 of 
      1 -> if _t260 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcNode=Just s}
        else do
          skip iprot _t260
          read_Disconnect_args_fields iprot record
      2 -> if _t260 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype265,_size262) <- readListBegin iprot; f _size262})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_srcPort=Just s}
        else do
          skip iprot _t260
          read_Disconnect_args_fields iprot record
      3 -> if _t260 == T_STRUCT then do
        s <- (read_Node iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstNode=Just s}
        else do
          skip iprot _t260
          read_Disconnect_args_fields iprot record
      4 -> if _t260 == T_LIST then do
        s <- (let f n = Vector.replicateM (fromIntegral n) (readI32 iprot) in do {(_etype270,_size267) <- readListBegin iprot; f _size267})
        read_Disconnect_args_fields iprot record{f_Disconnect_args_dstPort=Just s}
        else do
          skip iprot _t260
          read_Disconnect_args_fields iprot record
      5 -> if _t260 == T_STRUCT then do
        s <- (read_NodeDefinition iprot)
        read_Disconnect_args_fields iprot record{f_Disconnect_args_definition=Just s}
        else do
          skip iprot _t260
          read_Disconnect_args_fields iprot record
      _ -> do
        skip iprot _t260
        readFieldEnd iprot
        read_Disconnect_args_fields iprot record
read_Disconnect_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_args_fields iprot (Disconnect_args{f_Disconnect_args_srcNode=Nothing,f_Disconnect_args_srcPort=Nothing,f_Disconnect_args_dstNode=Nothing,f_Disconnect_args_dstPort=Nothing,f_Disconnect_args_definition=Nothing})
  readStructEnd iprot
  return record
data Disconnect_result = Disconnect_result deriving (Show,Eq,Typeable)
instance Hashable Disconnect_result where
  hashWithSalt salt record = salt  
write_Disconnect_result oprot record = do
  writeStructBegin oprot "Disconnect_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Disconnect_result_fields iprot record = do
  (_,_t275,_id276) <- readFieldBegin iprot
  if _t275 == T_STOP then return record else
    case _id276 of 
      _ -> do
        skip iprot _t275
        readFieldEnd iprot
        read_Disconnect_result_fields iprot record
read_Disconnect_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Disconnect_result_fields iprot (Disconnect_result{})
  readStructEnd iprot
  return record
data Ping_args = Ping_args deriving (Show,Eq,Typeable)
instance Hashable Ping_args where
  hashWithSalt salt record = salt  
write_Ping_args oprot record = do
  writeStructBegin oprot "Ping_args"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_args_fields iprot record = do
  (_,_t280,_id281) <- readFieldBegin iprot
  if _t280 == T_STOP then return record else
    case _id281 of 
      _ -> do
        skip iprot _t280
        readFieldEnd iprot
        read_Ping_args_fields iprot record
read_Ping_args iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_args_fields iprot (Ping_args{})
  readStructEnd iprot
  return record
data Ping_result = Ping_result deriving (Show,Eq,Typeable)
instance Hashable Ping_result where
  hashWithSalt salt record = salt  
write_Ping_result oprot record = do
  writeStructBegin oprot "Ping_result"
  writeFieldStop oprot
  writeStructEnd oprot
read_Ping_result_fields iprot record = do
  (_,_t285,_id286) <- readFieldBegin iprot
  if _t285 == T_STOP then return record else
    case _id286 of 
      _ -> do
        skip iprot _t285
        readFieldEnd iprot
        read_Ping_result_fields iprot record
read_Ping_result iprot = do
  _ <- readStructBegin iprot
  record <- read_Ping_result_fields iprot (Ping_result{})
  readStructEnd iprot
  return record
process_libraries (seqid, iprot, oprot, handler) = do
  args <- read_Libraries_args iprot
  readMessageEnd iprot
  rs <- return (Libraries_result Nothing)
  res <- (do
    res <- Iface.libraries handler
    return rs{f_Libraries_result_success= Just res})
  writeMessageBegin oprot ("libraries", M_REPLY, seqid);
  write_Libraries_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_loadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_LoadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (LoadLibrary_result Nothing Nothing)
  res <- (Control.Exception.catch
    (do
      res <- Iface.loadLibrary handler (f_LoadLibrary_args_library args)
      return rs{f_LoadLibrary_result_success= Just res})
    (\e  -> 
      return rs{f_LoadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("loadLibrary", M_REPLY, seqid);
  write_LoadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_unloadLibrary (seqid, iprot, oprot, handler) = do
  args <- read_UnloadLibrary_args iprot
  readMessageEnd iprot
  rs <- return (UnloadLibrary_result Nothing)
  res <- (Control.Exception.catch
    (do
      Iface.unloadLibrary handler (f_UnloadLibrary_args_library args)
      return rs)
    (\e  -> 
      return rs{f_UnloadLibrary_result_missingFields =Just e}))
  writeMessageBegin oprot ("unloadLibrary", M_REPLY, seqid);
  write_UnloadLibrary_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newDefinition (seqid, iprot, oprot, handler) = do
  args <- read_NewDefinition_args iprot
  readMessageEnd iprot
  rs <- return (NewDefinition_result Nothing)
  res <- (do
    res <- Iface.newDefinition handler (f_NewDefinition_args_type args) (f_NewDefinition_args_flags args) (f_NewDefinition_args_attrs args)
    return rs{f_NewDefinition_result_success= Just res})
  writeMessageBegin oprot ("newDefinition", M_REPLY, seqid);
  write_NewDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addDefinition (seqid, iprot, oprot, handler) = do
  args <- read_AddDefinition_args iprot
  readMessageEnd iprot
  rs <- return (AddDefinition_result Nothing)
  res <- (do
    res <- Iface.addDefinition handler (f_AddDefinition_args_definition args) (f_AddDefinition_args_parent args)
    return rs{f_AddDefinition_result_success= Just res})
  writeMessageBegin oprot ("addDefinition", M_REPLY, seqid);
  write_AddDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateDefinition (seqid, iprot, oprot, handler) = do
  args <- read_UpdateDefinition_args iprot
  readMessageEnd iprot
  rs <- return (UpdateDefinition_result)
  res <- (do
    Iface.updateDefinition handler (f_UpdateDefinition_args_definition args)
    return rs)
  writeMessageBegin oprot ("updateDefinition", M_REPLY, seqid);
  write_UpdateDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeDefinition (seqid, iprot, oprot, handler) = do
  args <- read_RemoveDefinition_args iprot
  readMessageEnd iprot
  rs <- return (RemoveDefinition_result)
  res <- (do
    Iface.removeDefinition handler (f_RemoveDefinition_args_definition args)
    return rs)
  writeMessageBegin oprot ("removeDefinition", M_REPLY, seqid);
  write_RemoveDefinition_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionChildren (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionChildren_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionChildren_result Nothing)
  res <- (do
    res <- Iface.definitionChildren handler (f_DefinitionChildren_args_definition args)
    return rs{f_DefinitionChildren_result_success= Just res})
  writeMessageBegin oprot ("definitionChildren", M_REPLY, seqid);
  write_DefinitionChildren_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_definitionParent (seqid, iprot, oprot, handler) = do
  args <- read_DefinitionParent_args iprot
  readMessageEnd iprot
  rs <- return (DefinitionParent_result Nothing)
  res <- (do
    res <- Iface.definitionParent handler (f_DefinitionParent_args_definition args)
    return rs{f_DefinitionParent_result_success= Just res})
  writeMessageBegin oprot ("definitionParent", M_REPLY, seqid);
  write_DefinitionParent_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeModule (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeModule_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeModule_result Nothing)
  res <- (do
    res <- Iface.newTypeModule handler (f_NewTypeModule_args_name args)
    return rs{f_NewTypeModule_result_success= Just res})
  writeMessageBegin oprot ("newTypeModule", M_REPLY, seqid);
  write_NewTypeModule_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeClass (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeClass_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeClass_result Nothing)
  res <- (do
    res <- Iface.newTypeClass handler (f_NewTypeClass_args_name args) (f_NewTypeClass_args_params args)
    return rs{f_NewTypeClass_result_success= Just res})
  writeMessageBegin oprot ("newTypeClass", M_REPLY, seqid);
  write_NewTypeClass_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeFunction (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeFunction_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeFunction_result Nothing)
  res <- (do
    res <- Iface.newTypeFunction handler (f_NewTypeFunction_args_name args) (f_NewTypeFunction_args_inputs args) (f_NewTypeFunction_args_outputs args)
    return rs{f_NewTypeFunction_result_success= Just res})
  writeMessageBegin oprot ("newTypeFunction", M_REPLY, seqid);
  write_NewTypeFunction_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeUdefined (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeUdefined_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeUdefined_result Nothing)
  res <- (do
    res <- Iface.newTypeUdefined handler
    return rs{f_NewTypeUdefined_result_success= Just res})
  writeMessageBegin oprot ("newTypeUdefined", M_REPLY, seqid);
  write_NewTypeUdefined_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeNamed (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeNamed_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeNamed_result Nothing)
  res <- (do
    res <- Iface.newTypeNamed handler (f_NewTypeNamed_args_name args)
    return rs{f_NewTypeNamed_result_success= Just res})
  writeMessageBegin oprot ("newTypeNamed", M_REPLY, seqid);
  write_NewTypeNamed_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeVariable (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeVariable_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeVariable_result Nothing)
  res <- (do
    res <- Iface.newTypeVariable handler (f_NewTypeVariable_args_name args) (f_NewTypeVariable_args_type args)
    return rs{f_NewTypeVariable_result_success= Just res})
  writeMessageBegin oprot ("newTypeVariable", M_REPLY, seqid);
  write_NewTypeVariable_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeList (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeList_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeList_result Nothing)
  res <- (do
    res <- Iface.newTypeList handler (f_NewTypeList_args_type args)
    return rs{f_NewTypeList_result_success= Just res})
  writeMessageBegin oprot ("newTypeList", M_REPLY, seqid);
  write_NewTypeList_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_newTypeTuple (seqid, iprot, oprot, handler) = do
  args <- read_NewTypeTuple_args iprot
  readMessageEnd iprot
  rs <- return (NewTypeTuple_result Nothing)
  res <- (do
    res <- Iface.newTypeTuple handler (f_NewTypeTuple_args_types args)
    return rs{f_NewTypeTuple_result_success= Just res})
  writeMessageBegin oprot ("newTypeTuple", M_REPLY, seqid);
  write_NewTypeTuple_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_graph (seqid, iprot, oprot, handler) = do
  args <- read_Graph_args iprot
  readMessageEnd iprot
  rs <- return (Graph_result Nothing)
  res <- (do
    res <- Iface.graph handler (f_Graph_args_definition args)
    return rs{f_Graph_result_success= Just res})
  writeMessageBegin oprot ("graph", M_REPLY, seqid);
  write_Graph_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_addNode (seqid, iprot, oprot, handler) = do
  args <- read_AddNode_args iprot
  readMessageEnd iprot
  rs <- return (AddNode_result Nothing)
  res <- (do
    res <- Iface.addNode handler (f_AddNode_args_node args) (f_AddNode_args_definition args)
    return rs{f_AddNode_result_success= Just res})
  writeMessageBegin oprot ("addNode", M_REPLY, seqid);
  write_AddNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_updateNode (seqid, iprot, oprot, handler) = do
  args <- read_UpdateNode_args iprot
  readMessageEnd iprot
  rs <- return (UpdateNode_result)
  res <- (do
    Iface.updateNode handler (f_UpdateNode_args_node args) (f_UpdateNode_args_definition args)
    return rs)
  writeMessageBegin oprot ("updateNode", M_REPLY, seqid);
  write_UpdateNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_removeNode (seqid, iprot, oprot, handler) = do
  args <- read_RemoveNode_args iprot
  readMessageEnd iprot
  rs <- return (RemoveNode_result)
  res <- (do
    Iface.removeNode handler (f_RemoveNode_args_node args) (f_RemoveNode_args_definition args)
    return rs)
  writeMessageBegin oprot ("removeNode", M_REPLY, seqid);
  write_RemoveNode_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_connect (seqid, iprot, oprot, handler) = do
  args <- read_Connect_args iprot
  readMessageEnd iprot
  rs <- return (Connect_result)
  res <- (do
    Iface.connect handler (f_Connect_args_srcNode args) (f_Connect_args_srcPort args) (f_Connect_args_dstNode args) (f_Connect_args_dstPort args) (f_Connect_args_definition args)
    return rs)
  writeMessageBegin oprot ("connect", M_REPLY, seqid);
  write_Connect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_disconnect (seqid, iprot, oprot, handler) = do
  args <- read_Disconnect_args iprot
  readMessageEnd iprot
  rs <- return (Disconnect_result)
  res <- (do
    Iface.disconnect handler (f_Disconnect_args_srcNode args) (f_Disconnect_args_srcPort args) (f_Disconnect_args_dstNode args) (f_Disconnect_args_dstPort args) (f_Disconnect_args_definition args)
    return rs)
  writeMessageBegin oprot ("disconnect", M_REPLY, seqid);
  write_Disconnect_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
process_ping (seqid, iprot, oprot, handler) = do
  args <- read_Ping_args iprot
  readMessageEnd iprot
  rs <- return (Ping_result)
  res <- (do
    Iface.ping handler
    return rs)
  writeMessageBegin oprot ("ping", M_REPLY, seqid);
  write_Ping_result oprot res
  writeMessageEnd oprot
  tFlush (getTransport oprot)
proc_ handler (iprot,oprot) (name,typ,seqid) = case name of
  "libraries" -> process_libraries (seqid,iprot,oprot,handler)
  "loadLibrary" -> process_loadLibrary (seqid,iprot,oprot,handler)
  "unloadLibrary" -> process_unloadLibrary (seqid,iprot,oprot,handler)
  "newDefinition" -> process_newDefinition (seqid,iprot,oprot,handler)
  "addDefinition" -> process_addDefinition (seqid,iprot,oprot,handler)
  "updateDefinition" -> process_updateDefinition (seqid,iprot,oprot,handler)
  "removeDefinition" -> process_removeDefinition (seqid,iprot,oprot,handler)
  "definitionChildren" -> process_definitionChildren (seqid,iprot,oprot,handler)
  "definitionParent" -> process_definitionParent (seqid,iprot,oprot,handler)
  "newTypeModule" -> process_newTypeModule (seqid,iprot,oprot,handler)
  "newTypeClass" -> process_newTypeClass (seqid,iprot,oprot,handler)
  "newTypeFunction" -> process_newTypeFunction (seqid,iprot,oprot,handler)
  "newTypeUdefined" -> process_newTypeUdefined (seqid,iprot,oprot,handler)
  "newTypeNamed" -> process_newTypeNamed (seqid,iprot,oprot,handler)
  "newTypeVariable" -> process_newTypeVariable (seqid,iprot,oprot,handler)
  "newTypeList" -> process_newTypeList (seqid,iprot,oprot,handler)
  "newTypeTuple" -> process_newTypeTuple (seqid,iprot,oprot,handler)
  "graph" -> process_graph (seqid,iprot,oprot,handler)
  "addNode" -> process_addNode (seqid,iprot,oprot,handler)
  "updateNode" -> process_updateNode (seqid,iprot,oprot,handler)
  "removeNode" -> process_removeNode (seqid,iprot,oprot,handler)
  "connect" -> process_connect (seqid,iprot,oprot,handler)
  "disconnect" -> process_disconnect (seqid,iprot,oprot,handler)
  "ping" -> process_ping (seqid,iprot,oprot,handler)
  _ -> do
    skip iprot T_STRUCT
    readMessageEnd iprot
    writeMessageBegin oprot (name,M_EXCEPTION,seqid)
    writeAppExn oprot (AppExn AE_UNKNOWN_METHOD ("Unknown function " ++ TL.unpack name))
    writeMessageEnd oprot
    tFlush (getTransport oprot)
process handler (iprot, oprot) = do
  (name, typ, seqid) <- readMessageBegin iprot
  proc_ handler (iprot,oprot) (name,typ,seqid)
  return True
