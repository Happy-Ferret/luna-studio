// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: parser.proto

#ifndef PROTOBUF_parser_2eproto__INCLUDED
#define PROTOBUF_parser_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "expr.pb.h"
#include "pat.pb.h"
#include "type.pb.h"
// @@protoc_insertion_point(includes)

namespace generated {
namespace proto {
namespace parser {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_parser_2eproto();
void protobuf_AssignDesc_parser_2eproto();
void protobuf_ShutdownFile_parser_2eproto();

class Parse;
class Parse_Expr;
class Parse_Expr_Request;
class Parse_Expr_Status;
class Parse_Pat;
class Parse_Pat_Request;
class Parse_Pat_Status;
class Parse_Type;
class Parse_Type_Request;
class Parse_Type_Status;
class Parse_NodeExpr;
class Parse_NodeExpr_Request;
class Parse_NodeExpr_Status;

// ===================================================================

class Parse_Expr_Request : public ::google::protobuf::Message {
 public:
  Parse_Expr_Request();
  virtual ~Parse_Expr_Request();

  Parse_Expr_Request(const Parse_Expr_Request& from);

  inline Parse_Expr_Request& operator=(const Parse_Expr_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Expr_Request& default_instance();

  void Swap(Parse_Expr_Request* other);

  // implements Message ----------------------------------------------

  Parse_Expr_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Expr_Request& from);
  void MergeFrom(const Parse_Expr_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Expr.Request)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Expr_Request* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Expr_Status : public ::google::protobuf::Message {
 public:
  Parse_Expr_Status();
  virtual ~Parse_Expr_Status();

  Parse_Expr_Status(const Parse_Expr_Status& from);

  inline Parse_Expr_Status& operator=(const Parse_Expr_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Expr_Status& default_instance();

  void Swap(Parse_Expr_Status* other);

  // implements Message ----------------------------------------------

  Parse_Expr_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Expr_Status& from);
  void MergeFrom(const Parse_Expr_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .generated.proto.expr.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Expr.Status)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* expr_;
  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Expr_Status* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Expr : public ::google::protobuf::Message {
 public:
  Parse_Expr();
  virtual ~Parse_Expr();

  Parse_Expr(const Parse_Expr& from);

  inline Parse_Expr& operator=(const Parse_Expr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Expr& default_instance();

  void Swap(Parse_Expr* other);

  // implements Message ----------------------------------------------

  Parse_Expr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Expr& from);
  void MergeFrom(const Parse_Expr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Parse_Expr_Request Request;
  typedef Parse_Expr_Status Status;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Expr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Expr* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Pat_Request : public ::google::protobuf::Message {
 public:
  Parse_Pat_Request();
  virtual ~Parse_Pat_Request();

  Parse_Pat_Request(const Parse_Pat_Request& from);

  inline Parse_Pat_Request& operator=(const Parse_Pat_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Pat_Request& default_instance();

  void Swap(Parse_Pat_Request* other);

  // implements Message ----------------------------------------------

  Parse_Pat_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Pat_Request& from);
  void MergeFrom(const Parse_Pat_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Pat.Request)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Pat_Request* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Pat_Status : public ::google::protobuf::Message {
 public:
  Parse_Pat_Status();
  virtual ~Parse_Pat_Status();

  Parse_Pat_Status(const Parse_Pat_Status& from);

  inline Parse_Pat_Status& operator=(const Parse_Pat_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Pat_Status& default_instance();

  void Swap(Parse_Pat_Status* other);

  // implements Message ----------------------------------------------

  Parse_Pat_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Pat_Status& from);
  void MergeFrom(const Parse_Pat_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .generated.proto.pat.Pat pat = 1;
  inline bool has_pat() const;
  inline void clear_pat();
  static const int kPatFieldNumber = 1;
  inline const ::generated::proto::pat::Pat& pat() const;
  inline ::generated::proto::pat::Pat* mutable_pat();
  inline ::generated::proto::pat::Pat* release_pat();
  inline void set_allocated_pat(::generated::proto::pat::Pat* pat);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Pat.Status)
 private:
  inline void set_has_pat();
  inline void clear_has_pat();
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::pat::Pat* pat_;
  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Pat_Status* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Pat : public ::google::protobuf::Message {
 public:
  Parse_Pat();
  virtual ~Parse_Pat();

  Parse_Pat(const Parse_Pat& from);

  inline Parse_Pat& operator=(const Parse_Pat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Pat& default_instance();

  void Swap(Parse_Pat* other);

  // implements Message ----------------------------------------------

  Parse_Pat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Pat& from);
  void MergeFrom(const Parse_Pat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Parse_Pat_Request Request;
  typedef Parse_Pat_Status Status;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Pat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Pat* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Type_Request : public ::google::protobuf::Message {
 public:
  Parse_Type_Request();
  virtual ~Parse_Type_Request();

  Parse_Type_Request(const Parse_Type_Request& from);

  inline Parse_Type_Request& operator=(const Parse_Type_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Type_Request& default_instance();

  void Swap(Parse_Type_Request* other);

  // implements Message ----------------------------------------------

  Parse_Type_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Type_Request& from);
  void MergeFrom(const Parse_Type_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Type.Request)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Type_Request* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Type_Status : public ::google::protobuf::Message {
 public:
  Parse_Type_Status();
  virtual ~Parse_Type_Status();

  Parse_Type_Status(const Parse_Type_Status& from);

  inline Parse_Type_Status& operator=(const Parse_Type_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Type_Status& default_instance();

  void Swap(Parse_Type_Status* other);

  // implements Message ----------------------------------------------

  Parse_Type_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Type_Status& from);
  void MergeFrom(const Parse_Type_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .generated.proto.type.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::generated::proto::type::Type& type() const;
  inline ::generated::proto::type::Type* mutable_type();
  inline ::generated::proto::type::Type* release_type();
  inline void set_allocated_type(::generated::proto::type::Type* type);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Type.Status)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::type::Type* type_;
  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Type_Status* default_instance_;
};
// -------------------------------------------------------------------

class Parse_Type : public ::google::protobuf::Message {
 public:
  Parse_Type();
  virtual ~Parse_Type();

  Parse_Type(const Parse_Type& from);

  inline Parse_Type& operator=(const Parse_Type& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_Type& default_instance();

  void Swap(Parse_Type* other);

  // implements Message ----------------------------------------------

  Parse_Type* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_Type& from);
  void MergeFrom(const Parse_Type& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Parse_Type_Request Request;
  typedef Parse_Type_Status Status;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.Type)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_Type* default_instance_;
};
// -------------------------------------------------------------------

class Parse_NodeExpr_Request : public ::google::protobuf::Message {
 public:
  Parse_NodeExpr_Request();
  virtual ~Parse_NodeExpr_Request();

  Parse_NodeExpr_Request(const Parse_NodeExpr_Request& from);

  inline Parse_NodeExpr_Request& operator=(const Parse_NodeExpr_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_NodeExpr_Request& default_instance();

  void Swap(Parse_NodeExpr_Request* other);

  // implements Message ----------------------------------------------

  Parse_NodeExpr_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_NodeExpr_Request& from);
  void MergeFrom(const Parse_NodeExpr_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string str = 1;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 1;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.NodeExpr.Request)
 private:
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_NodeExpr_Request* default_instance_;
};
// -------------------------------------------------------------------

class Parse_NodeExpr_Status : public ::google::protobuf::Message {
 public:
  Parse_NodeExpr_Status();
  virtual ~Parse_NodeExpr_Status();

  Parse_NodeExpr_Status(const Parse_NodeExpr_Status& from);

  inline Parse_NodeExpr_Status& operator=(const Parse_NodeExpr_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_NodeExpr_Status& default_instance();

  void Swap(Parse_NodeExpr_Status* other);

  // implements Message ----------------------------------------------

  Parse_NodeExpr_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_NodeExpr_Status& from);
  void MergeFrom(const Parse_NodeExpr_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .generated.proto.expr.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  // required string str = 2;
  inline bool has_str() const;
  inline void clear_str();
  static const int kStrFieldNumber = 2;
  inline const ::std::string& str() const;
  inline void set_str(const ::std::string& value);
  inline void set_str(const char* value);
  inline void set_str(const char* value, size_t size);
  inline ::std::string* mutable_str();
  inline ::std::string* release_str();
  inline void set_allocated_str(::std::string* str);

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.NodeExpr.Status)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();
  inline void set_has_str();
  inline void clear_has_str();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* expr_;
  ::std::string* str_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_NodeExpr_Status* default_instance_;
};
// -------------------------------------------------------------------

class Parse_NodeExpr : public ::google::protobuf::Message {
 public:
  Parse_NodeExpr();
  virtual ~Parse_NodeExpr();

  Parse_NodeExpr(const Parse_NodeExpr& from);

  inline Parse_NodeExpr& operator=(const Parse_NodeExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse_NodeExpr& default_instance();

  void Swap(Parse_NodeExpr* other);

  // implements Message ----------------------------------------------

  Parse_NodeExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse_NodeExpr& from);
  void MergeFrom(const Parse_NodeExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Parse_NodeExpr_Request Request;
  typedef Parse_NodeExpr_Status Status;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse.NodeExpr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse_NodeExpr* default_instance_;
};
// -------------------------------------------------------------------

class Parse : public ::google::protobuf::Message {
 public:
  Parse();
  virtual ~Parse();

  Parse(const Parse& from);

  inline Parse& operator=(const Parse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parse& default_instance();

  void Swap(Parse* other);

  // implements Message ----------------------------------------------

  Parse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parse& from);
  void MergeFrom(const Parse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Parse_Expr Expr;
  typedef Parse_Pat Pat;
  typedef Parse_Type Type;
  typedef Parse_NodeExpr NodeExpr;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:generated.proto.parser.Parse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_parser_2eproto();
  friend void protobuf_AssignDesc_parser_2eproto();
  friend void protobuf_ShutdownFile_parser_2eproto();

  void InitAsDefaultInstance();
  static Parse* default_instance_;
};
// ===================================================================


// ===================================================================

// Parse_Expr_Request

// required string str = 1;
inline bool Parse_Expr_Request::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Expr_Request::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Expr_Request::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Expr_Request::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Expr_Request::str() const {
  return *str_;
}
inline void Parse_Expr_Request::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Expr_Request::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Expr_Request::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Expr_Request::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Expr_Request::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Expr_Request::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Expr_Status

// required .generated.proto.expr.Expr expr = 1;
inline bool Parse_Expr_Status::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Expr_Status::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Expr_Status::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Expr_Status::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& Parse_Expr_Status::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* Parse_Expr_Status::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* Parse_Expr_Status::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Parse_Expr_Status::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// required string str = 2;
inline bool Parse_Expr_Status::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parse_Expr_Status::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parse_Expr_Status::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parse_Expr_Status::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Expr_Status::str() const {
  return *str_;
}
inline void Parse_Expr_Status::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Expr_Status::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Expr_Status::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Expr_Status::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Expr_Status::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Expr_Status::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Expr

// -------------------------------------------------------------------

// Parse_Pat_Request

// required string str = 1;
inline bool Parse_Pat_Request::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Pat_Request::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Pat_Request::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Pat_Request::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Pat_Request::str() const {
  return *str_;
}
inline void Parse_Pat_Request::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Pat_Request::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Pat_Request::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Pat_Request::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Pat_Request::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Pat_Request::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Pat_Status

// required .generated.proto.pat.Pat pat = 1;
inline bool Parse_Pat_Status::has_pat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Pat_Status::set_has_pat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Pat_Status::clear_has_pat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Pat_Status::clear_pat() {
  if (pat_ != NULL) pat_->::generated::proto::pat::Pat::Clear();
  clear_has_pat();
}
inline const ::generated::proto::pat::Pat& Parse_Pat_Status::pat() const {
  return pat_ != NULL ? *pat_ : *default_instance_->pat_;
}
inline ::generated::proto::pat::Pat* Parse_Pat_Status::mutable_pat() {
  set_has_pat();
  if (pat_ == NULL) pat_ = new ::generated::proto::pat::Pat;
  return pat_;
}
inline ::generated::proto::pat::Pat* Parse_Pat_Status::release_pat() {
  clear_has_pat();
  ::generated::proto::pat::Pat* temp = pat_;
  pat_ = NULL;
  return temp;
}
inline void Parse_Pat_Status::set_allocated_pat(::generated::proto::pat::Pat* pat) {
  delete pat_;
  pat_ = pat;
  if (pat) {
    set_has_pat();
  } else {
    clear_has_pat();
  }
}

// required string str = 2;
inline bool Parse_Pat_Status::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parse_Pat_Status::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parse_Pat_Status::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parse_Pat_Status::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Pat_Status::str() const {
  return *str_;
}
inline void Parse_Pat_Status::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Pat_Status::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Pat_Status::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Pat_Status::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Pat_Status::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Pat_Status::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Pat

// -------------------------------------------------------------------

// Parse_Type_Request

// required string str = 1;
inline bool Parse_Type_Request::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Type_Request::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Type_Request::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Type_Request::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Type_Request::str() const {
  return *str_;
}
inline void Parse_Type_Request::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Type_Request::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Type_Request::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Type_Request::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Type_Request::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Type_Request::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Type_Status

// required .generated.proto.type.Type type = 1;
inline bool Parse_Type_Status::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_Type_Status::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_Type_Status::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_Type_Status::clear_type() {
  if (type_ != NULL) type_->::generated::proto::type::Type::Clear();
  clear_has_type();
}
inline const ::generated::proto::type::Type& Parse_Type_Status::type() const {
  return type_ != NULL ? *type_ : *default_instance_->type_;
}
inline ::generated::proto::type::Type* Parse_Type_Status::mutable_type() {
  set_has_type();
  if (type_ == NULL) type_ = new ::generated::proto::type::Type;
  return type_;
}
inline ::generated::proto::type::Type* Parse_Type_Status::release_type() {
  clear_has_type();
  ::generated::proto::type::Type* temp = type_;
  type_ = NULL;
  return temp;
}
inline void Parse_Type_Status::set_allocated_type(::generated::proto::type::Type* type) {
  delete type_;
  type_ = type;
  if (type) {
    set_has_type();
  } else {
    clear_has_type();
  }
}

// required string str = 2;
inline bool Parse_Type_Status::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parse_Type_Status::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parse_Type_Status::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parse_Type_Status::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_Type_Status::str() const {
  return *str_;
}
inline void Parse_Type_Status::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Type_Status::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_Type_Status::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_Type_Status::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_Type_Status::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_Type_Status::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_Type

// -------------------------------------------------------------------

// Parse_NodeExpr_Request

// required string str = 1;
inline bool Parse_NodeExpr_Request::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_NodeExpr_Request::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_NodeExpr_Request::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_NodeExpr_Request::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_NodeExpr_Request::str() const {
  return *str_;
}
inline void Parse_NodeExpr_Request::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_NodeExpr_Request::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_NodeExpr_Request::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_NodeExpr_Request::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_NodeExpr_Request::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_NodeExpr_Request::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_NodeExpr_Status

// required .generated.proto.expr.Expr expr = 1;
inline bool Parse_NodeExpr_Status::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parse_NodeExpr_Status::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parse_NodeExpr_Status::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parse_NodeExpr_Status::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& Parse_NodeExpr_Status::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* Parse_NodeExpr_Status::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* Parse_NodeExpr_Status::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Parse_NodeExpr_Status::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// required string str = 2;
inline bool Parse_NodeExpr_Status::has_str() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parse_NodeExpr_Status::set_has_str() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parse_NodeExpr_Status::clear_has_str() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parse_NodeExpr_Status::clear_str() {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    str_->clear();
  }
  clear_has_str();
}
inline const ::std::string& Parse_NodeExpr_Status::str() const {
  return *str_;
}
inline void Parse_NodeExpr_Status::set_str(const ::std::string& value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_NodeExpr_Status::set_str(const char* value) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(value);
}
inline void Parse_NodeExpr_Status::set_str(const char* value, size_t size) {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  str_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parse_NodeExpr_Status::mutable_str() {
  set_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    str_ = new ::std::string;
  }
  return str_;
}
inline ::std::string* Parse_NodeExpr_Status::release_str() {
  clear_has_str();
  if (str_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = str_;
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parse_NodeExpr_Status::set_allocated_str(::std::string* str) {
  if (str_ != &::google::protobuf::internal::kEmptyString) {
    delete str_;
  }
  if (str) {
    set_has_str();
    str_ = str;
  } else {
    clear_has_str();
    str_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Parse_NodeExpr

// -------------------------------------------------------------------

// Parse


// @@protoc_insertion_point(namespace_scope)

}  // namespace parser
}  // namespace proto
}  // namespace generated

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_parser_2eproto__INCLUDED
