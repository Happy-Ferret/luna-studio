// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: expr.proto

#ifndef PROTOBUF_expr_2eproto__INCLUDED
#define PROTOBUF_expr_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pat.pb.h"
#include "lit.pb.h"
#include "type.pb.h"
// @@protoc_insertion_point(includes)

namespace generated {
namespace proto {
namespace expr {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_expr_2eproto();
void protobuf_AssignDesc_expr_2eproto();
void protobuf_ShutdownFile_expr_2eproto();

class Expr;
class NOP;
class Accessor;
class TypeAlias;
class TypeDef;
class App;
class AppCons_;
class Assignment;
class RecordUpdate;
class Data;
class ConD;
class Con_;
class Condition;
class Function;
class Lambda;
class Grouped;
class Import;
class ImportNative;
class Infix;
class List;
class Lit;
class Tuple;
class Typed;
class Var;
class Wildcard;
class RangeFromTo;
class RangeFrom;
class Field;
class Arg;
class Native;
class NativeCode;
class NativeVar;
class Ref;
class RefType;
class Case;
class Match;

enum Expr_Cls {
  Expr_Cls_NOP = 1,
  Expr_Cls_TypeAlias = 2,
  Expr_Cls_TypeDef = 3,
  Expr_Cls_Accessor = 4,
  Expr_Cls_App = 5,
  Expr_Cls_AppCons_ = 6,
  Expr_Cls_Assignment = 7,
  Expr_Cls_RecordUpdate = 8,
  Expr_Cls_Data = 9,
  Expr_Cls_ConD = 10,
  Expr_Cls_Con_ = 11,
  Expr_Cls_Condition = 31,
  Expr_Cls_Function = 12,
  Expr_Cls_Lambda = 13,
  Expr_Cls_Grouped = 32,
  Expr_Cls_Import = 14,
  Expr_Cls_ImportNative = 35,
  Expr_Cls_Infix = 15,
  Expr_Cls_List = 16,
  Expr_Cls_Lit = 17,
  Expr_Cls_Tuple = 18,
  Expr_Cls_Typed = 19,
  Expr_Cls_Var = 20,
  Expr_Cls_Wildcard = 21,
  Expr_Cls_RangeFromTo = 22,
  Expr_Cls_RangeFrom = 23,
  Expr_Cls_Field = 24,
  Expr_Cls_Arg = 25,
  Expr_Cls_Native = 26,
  Expr_Cls_NativeCode = 27,
  Expr_Cls_NativeVar = 28,
  Expr_Cls_Ref = 33,
  Expr_Cls_RefType = 34,
  Expr_Cls_Case = 29,
  Expr_Cls_Match = 30
};
bool Expr_Cls_IsValid(int value);
const Expr_Cls Expr_Cls_Cls_MIN = Expr_Cls_NOP;
const Expr_Cls Expr_Cls_Cls_MAX = Expr_Cls_ImportNative;
const int Expr_Cls_Cls_ARRAYSIZE = Expr_Cls_Cls_MAX + 1;

const ::google::protobuf::EnumDescriptor* Expr_Cls_descriptor();
inline const ::std::string& Expr_Cls_Name(Expr_Cls value) {
  return ::google::protobuf::internal::NameOfEnum(
    Expr_Cls_descriptor(), value);
}
inline bool Expr_Cls_Parse(
    const ::std::string& name, Expr_Cls* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Expr_Cls>(
    Expr_Cls_descriptor(), name, value);
}
// ===================================================================

class Expr : public ::google::protobuf::Message {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  void Swap(Expr* other);

  // implements Message ----------------------------------------------

  Expr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Expr_Cls Cls;
  static const Cls NOP = Expr_Cls_NOP;
  static const Cls TypeAlias = Expr_Cls_TypeAlias;
  static const Cls TypeDef = Expr_Cls_TypeDef;
  static const Cls Accessor = Expr_Cls_Accessor;
  static const Cls App = Expr_Cls_App;
  static const Cls AppCons_ = Expr_Cls_AppCons_;
  static const Cls Assignment = Expr_Cls_Assignment;
  static const Cls RecordUpdate = Expr_Cls_RecordUpdate;
  static const Cls Data = Expr_Cls_Data;
  static const Cls ConD = Expr_Cls_ConD;
  static const Cls Con_ = Expr_Cls_Con_;
  static const Cls Condition = Expr_Cls_Condition;
  static const Cls Function = Expr_Cls_Function;
  static const Cls Lambda = Expr_Cls_Lambda;
  static const Cls Grouped = Expr_Cls_Grouped;
  static const Cls Import = Expr_Cls_Import;
  static const Cls ImportNative = Expr_Cls_ImportNative;
  static const Cls Infix = Expr_Cls_Infix;
  static const Cls List = Expr_Cls_List;
  static const Cls Lit = Expr_Cls_Lit;
  static const Cls Tuple = Expr_Cls_Tuple;
  static const Cls Typed = Expr_Cls_Typed;
  static const Cls Var = Expr_Cls_Var;
  static const Cls Wildcard = Expr_Cls_Wildcard;
  static const Cls RangeFromTo = Expr_Cls_RangeFromTo;
  static const Cls RangeFrom = Expr_Cls_RangeFrom;
  static const Cls Field = Expr_Cls_Field;
  static const Cls Arg = Expr_Cls_Arg;
  static const Cls Native = Expr_Cls_Native;
  static const Cls NativeCode = Expr_Cls_NativeCode;
  static const Cls NativeVar = Expr_Cls_NativeVar;
  static const Cls Ref = Expr_Cls_Ref;
  static const Cls RefType = Expr_Cls_RefType;
  static const Cls Case = Expr_Cls_Case;
  static const Cls Match = Expr_Cls_Match;
  static inline bool Cls_IsValid(int value) {
    return Expr_Cls_IsValid(value);
  }
  static const Cls Cls_MIN =
    Expr_Cls_Cls_MIN;
  static const Cls Cls_MAX =
    Expr_Cls_Cls_MAX;
  static const int Cls_ARRAYSIZE =
    Expr_Cls_Cls_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Cls_descriptor() {
    return Expr_Cls_descriptor();
  }
  static inline const ::std::string& Cls_Name(Cls value) {
    return Expr_Cls_Name(value);
  }
  static inline bool Cls_Parse(const ::std::string& name,
      Cls* value) {
    return Expr_Cls_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .generated.proto.expr.Expr.Cls cls = 1;
  inline bool has_cls() const;
  inline void clear_cls();
  static const int kClsFieldNumber = 1;
  inline ::generated::proto::expr::Expr_Cls cls() const;
  inline void set_cls(::generated::proto::expr::Expr_Cls value);

  // optional int32 id = 2 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Expr)
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Expr)
 private:
  inline void set_has_cls();
  inline void clear_has_cls();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int cls_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Expr* default_instance_;
};
// -------------------------------------------------------------------

class NOP : public ::google::protobuf::Message {
 public:
  NOP();
  virtual ~NOP();

  NOP(const NOP& from);

  inline NOP& operator=(const NOP& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NOP& default_instance();

  void Swap(NOP* other);

  // implements Message ----------------------------------------------

  NOP* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NOP& from);
  void MergeFrom(const NOP& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kExtFieldNumber = 100;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::NOP >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.NOP)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static NOP* default_instance_;
};
// -------------------------------------------------------------------

class Accessor : public ::google::protobuf::Message {
 public:
  Accessor();
  virtual ~Accessor();

  Accessor(const Accessor& from);

  inline Accessor& operator=(const Accessor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Accessor& default_instance();

  void Swap(Accessor* other);

  // implements Message ----------------------------------------------

  Accessor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Accessor& from);
  void MergeFrom(const Accessor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .generated.proto.expr.Expr dst = 2;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& dst() const;
  inline ::generated::proto::expr::Expr* mutable_dst();
  inline ::generated::proto::expr::Expr* release_dst();
  inline void set_allocated_dst(::generated::proto::expr::Expr* dst);

  static const int kExtFieldNumber = 101;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Accessor >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Accessor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_dst();
  inline void clear_has_dst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::generated::proto::expr::Expr* dst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Accessor* default_instance_;
};
// -------------------------------------------------------------------

class TypeAlias : public ::google::protobuf::Message {
 public:
  TypeAlias();
  virtual ~TypeAlias();

  TypeAlias(const TypeAlias& from);

  inline TypeAlias& operator=(const TypeAlias& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeAlias& default_instance();

  void Swap(TypeAlias* other);

  // implements Message ----------------------------------------------

  TypeAlias* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeAlias& from);
  void MergeFrom(const TypeAlias& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.type.Type srcType = 1;
  inline bool has_srctype() const;
  inline void clear_srctype();
  static const int kSrcTypeFieldNumber = 1;
  inline const ::generated::proto::type::Type& srctype() const;
  inline ::generated::proto::type::Type* mutable_srctype();
  inline ::generated::proto::type::Type* release_srctype();
  inline void set_allocated_srctype(::generated::proto::type::Type* srctype);

  // optional .generated.proto.type.Type dstType = 2;
  inline bool has_dsttype() const;
  inline void clear_dsttype();
  static const int kDstTypeFieldNumber = 2;
  inline const ::generated::proto::type::Type& dsttype() const;
  inline ::generated::proto::type::Type* mutable_dsttype();
  inline ::generated::proto::type::Type* release_dsttype();
  inline void set_allocated_dsttype(::generated::proto::type::Type* dsttype);

  static const int kExtFieldNumber = 127;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::TypeAlias >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.TypeAlias)
 private:
  inline void set_has_srctype();
  inline void clear_has_srctype();
  inline void set_has_dsttype();
  inline void clear_has_dsttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::type::Type* srctype_;
  ::generated::proto::type::Type* dsttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static TypeAlias* default_instance_;
};
// -------------------------------------------------------------------

class TypeDef : public ::google::protobuf::Message {
 public:
  TypeDef();
  virtual ~TypeDef();

  TypeDef(const TypeDef& from);

  inline TypeDef& operator=(const TypeDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TypeDef& default_instance();

  void Swap(TypeDef* other);

  // implements Message ----------------------------------------------

  TypeDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TypeDef& from);
  void MergeFrom(const TypeDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.type.Type srcType = 1;
  inline bool has_srctype() const;
  inline void clear_srctype();
  static const int kSrcTypeFieldNumber = 1;
  inline const ::generated::proto::type::Type& srctype() const;
  inline ::generated::proto::type::Type* mutable_srctype();
  inline ::generated::proto::type::Type* release_srctype();
  inline void set_allocated_srctype(::generated::proto::type::Type* srctype);

  // optional .generated.proto.type.Type dstType = 2;
  inline bool has_dsttype() const;
  inline void clear_dsttype();
  static const int kDstTypeFieldNumber = 2;
  inline const ::generated::proto::type::Type& dsttype() const;
  inline ::generated::proto::type::Type* mutable_dsttype();
  inline ::generated::proto::type::Type* release_dsttype();
  inline void set_allocated_dsttype(::generated::proto::type::Type* dsttype);

  static const int kExtFieldNumber = 128;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::TypeDef >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.TypeDef)
 private:
  inline void set_has_srctype();
  inline void clear_has_srctype();
  inline void set_has_dsttype();
  inline void clear_has_dsttype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::type::Type* srctype_;
  ::generated::proto::type::Type* dsttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static TypeDef* default_instance_;
};
// -------------------------------------------------------------------

class App : public ::google::protobuf::Message {
 public:
  App();
  virtual ~App();

  App(const App& from);

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const App& default_instance();

  void Swap(App* other);

  // implements Message ----------------------------------------------

  App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& src() const;
  inline ::generated::proto::expr::Expr* mutable_src();
  inline ::generated::proto::expr::Expr* release_src();
  inline void set_allocated_src(::generated::proto::expr::Expr* src);

  // repeated .generated.proto.expr.Expr args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& args(int index) const;
  inline ::generated::proto::expr::Expr* mutable_args(int index);
  inline ::generated::proto::expr::Expr* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_args();

  static const int kExtFieldNumber = 102;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::App >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.App)
 private:
  inline void set_has_src();
  inline void clear_has_src();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* src_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static App* default_instance_;
};
// -------------------------------------------------------------------

class AppCons_ : public ::google::protobuf::Message {
 public:
  AppCons_();
  virtual ~AppCons_();

  AppCons_(const AppCons_& from);

  inline AppCons_& operator=(const AppCons_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppCons_& default_instance();

  void Swap(AppCons_* other);

  // implements Message ----------------------------------------------

  AppCons_* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AppCons_& from);
  void MergeFrom(const AppCons_& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr args = 1;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& args(int index) const;
  inline ::generated::proto::expr::Expr* mutable_args(int index);
  inline ::generated::proto::expr::Expr* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_args();

  static const int kExtFieldNumber = 103;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::AppCons_ >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.AppCons_)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > args_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static AppCons_* default_instance_;
};
// -------------------------------------------------------------------

class Assignment : public ::google::protobuf::Message {
 public:
  Assignment();
  virtual ~Assignment();

  Assignment(const Assignment& from);

  inline Assignment& operator=(const Assignment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Assignment& default_instance();

  void Swap(Assignment* other);

  // implements Message ----------------------------------------------

  Assignment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Assignment& from);
  void MergeFrom(const Assignment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.pat.Pat pat = 1;
  inline bool has_pat() const;
  inline void clear_pat();
  static const int kPatFieldNumber = 1;
  inline const ::generated::proto::pat::Pat& pat() const;
  inline ::generated::proto::pat::Pat* mutable_pat();
  inline ::generated::proto::pat::Pat* release_pat();
  inline void set_allocated_pat(::generated::proto::pat::Pat* pat);

  // optional .generated.proto.expr.Expr dst = 2;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& dst() const;
  inline ::generated::proto::expr::Expr* mutable_dst();
  inline ::generated::proto::expr::Expr* release_dst();
  inline void set_allocated_dst(::generated::proto::expr::Expr* dst);

  static const int kExtFieldNumber = 104;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Assignment >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Assignment)
 private:
  inline void set_has_pat();
  inline void clear_has_pat();
  inline void set_has_dst();
  inline void clear_has_dst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::pat::Pat* pat_;
  ::generated::proto::expr::Expr* dst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Assignment* default_instance_;
};
// -------------------------------------------------------------------

class RecordUpdate : public ::google::protobuf::Message {
 public:
  RecordUpdate();
  virtual ~RecordUpdate();

  RecordUpdate(const RecordUpdate& from);

  inline RecordUpdate& operator=(const RecordUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecordUpdate& default_instance();

  void Swap(RecordUpdate* other);

  // implements Message ----------------------------------------------

  RecordUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecordUpdate& from);
  void MergeFrom(const RecordUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& src() const;
  inline ::generated::proto::expr::Expr* mutable_src();
  inline ::generated::proto::expr::Expr* release_src();
  inline void set_allocated_src(::generated::proto::expr::Expr* src);

  // repeated string selectors = 2;
  inline int selectors_size() const;
  inline void clear_selectors();
  static const int kSelectorsFieldNumber = 2;
  inline const ::std::string& selectors(int index) const;
  inline ::std::string* mutable_selectors(int index);
  inline void set_selectors(int index, const ::std::string& value);
  inline void set_selectors(int index, const char* value);
  inline void set_selectors(int index, const char* value, size_t size);
  inline ::std::string* add_selectors();
  inline void add_selectors(const ::std::string& value);
  inline void add_selectors(const char* value);
  inline void add_selectors(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& selectors() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_selectors();

  // optional .generated.proto.expr.Expr expr = 3;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  static const int kExtFieldNumber = 129;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::RecordUpdate >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.RecordUpdate)
 private:
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_expr();
  inline void clear_has_expr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* src_;
  ::google::protobuf::RepeatedPtrField< ::std::string> selectors_;
  ::generated::proto::expr::Expr* expr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static RecordUpdate* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.type.Type cls = 1;
  inline bool has_cls() const;
  inline void clear_cls();
  static const int kClsFieldNumber = 1;
  inline const ::generated::proto::type::Type& cls() const;
  inline ::generated::proto::type::Type* mutable_cls();
  inline ::generated::proto::type::Type* release_cls();
  inline void set_allocated_cls(::generated::proto::type::Type* cls);

  // repeated .generated.proto.expr.Expr cons = 2;
  inline int cons_size() const;
  inline void clear_cons();
  static const int kConsFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& cons(int index) const;
  inline ::generated::proto::expr::Expr* mutable_cons(int index);
  inline ::generated::proto::expr::Expr* add_cons();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      cons() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_cons();

  // repeated .generated.proto.expr.Expr classes = 3;
  inline int classes_size() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& classes(int index) const;
  inline ::generated::proto::expr::Expr* mutable_classes(int index);
  inline ::generated::proto::expr::Expr* add_classes();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      classes() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_classes();

  // repeated .generated.proto.expr.Expr methods = 4;
  inline int methods_size() const;
  inline void clear_methods();
  static const int kMethodsFieldNumber = 4;
  inline const ::generated::proto::expr::Expr& methods(int index) const;
  inline ::generated::proto::expr::Expr* mutable_methods(int index);
  inline ::generated::proto::expr::Expr* add_methods();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      methods() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_methods();

  static const int kExtFieldNumber = 105;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Data >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Data)
 private:
  inline void set_has_cls();
  inline void clear_has_cls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::type::Type* cls_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > cons_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > classes_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > methods_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class ConD : public ::google::protobuf::Message {
 public:
  ConD();
  virtual ~ConD();

  ConD(const ConD& from);

  inline ConD& operator=(const ConD& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConD& default_instance();

  void Swap(ConD* other);

  // implements Message ----------------------------------------------

  ConD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConD& from);
  void MergeFrom(const ConD& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .generated.proto.expr.Expr fields = 2;
  inline int fields_size() const;
  inline void clear_fields();
  static const int kFieldsFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& fields(int index) const;
  inline ::generated::proto::expr::Expr* mutable_fields(int index);
  inline ::generated::proto::expr::Expr* add_fields();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      fields() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_fields();

  static const int kExtFieldNumber = 126;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::ConD >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.ConD)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static ConD* default_instance_;
};
// -------------------------------------------------------------------

class Con_ : public ::google::protobuf::Message {
 public:
  Con_();
  virtual ~Con_();

  Con_(const Con_& from);

  inline Con_& operator=(const Con_& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Con_& default_instance();

  void Swap(Con_* other);

  // implements Message ----------------------------------------------

  Con_* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Con_& from);
  void MergeFrom(const Con_& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  static const int kExtFieldNumber = 106;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Con_ >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Con_)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Con_* default_instance_;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  void Swap(Condition* other);

  // implements Message ----------------------------------------------

  Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr cond = 1;
  inline bool has_cond() const;
  inline void clear_cond();
  static const int kCondFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& cond() const;
  inline ::generated::proto::expr::Expr* mutable_cond();
  inline ::generated::proto::expr::Expr* release_cond();
  inline void set_allocated_cond(::generated::proto::expr::Expr* cond);

  // repeated .generated.proto.expr.Expr success = 2;
  inline int success_size() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& success(int index) const;
  inline ::generated::proto::expr::Expr* mutable_success(int index);
  inline ::generated::proto::expr::Expr* add_success();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      success() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_success();

  // repeated .generated.proto.expr.Expr failure = 3;
  inline int failure_size() const;
  inline void clear_failure();
  static const int kFailureFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& failure(int index) const;
  inline ::generated::proto::expr::Expr* mutable_failure(int index);
  inline ::generated::proto::expr::Expr* add_failure();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      failure() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_failure();

  static const int kExtFieldNumber = 131;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Condition >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Condition)
 private:
  inline void set_has_cond();
  inline void clear_has_cond();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* cond_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > success_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > failure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Condition* default_instance_;
};
// -------------------------------------------------------------------

class Function : public ::google::protobuf::Message {
 public:
  Function();
  virtual ~Function();

  Function(const Function& from);

  inline Function& operator=(const Function& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Function& default_instance();

  void Swap(Function* other);

  // implements Message ----------------------------------------------

  Function* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Function& from);
  void MergeFrom(const Function& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string path = 1;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path(int index) const;
  inline ::std::string* mutable_path(int index);
  inline void set_path(int index, const ::std::string& value);
  inline void set_path(int index, const char* value);
  inline void set_path(int index, const char* value, size_t size);
  inline ::std::string* add_path();
  inline void add_path(const ::std::string& value);
  inline void add_path(const char* value);
  inline void add_path(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& path() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_path();

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .generated.proto.expr.Expr inputs = 3;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& inputs(int index) const;
  inline ::generated::proto::expr::Expr* mutable_inputs(int index);
  inline ::generated::proto::expr::Expr* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_inputs();

  // optional .generated.proto.type.Type output = 4;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 4;
  inline const ::generated::proto::type::Type& output() const;
  inline ::generated::proto::type::Type* mutable_output();
  inline ::generated::proto::type::Type* release_output();
  inline void set_allocated_output(::generated::proto::type::Type* output);

  // repeated .generated.proto.expr.Expr body = 5;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 5;
  inline const ::generated::proto::expr::Expr& body(int index) const;
  inline ::generated::proto::expr::Expr* mutable_body(int index);
  inline ::generated::proto::expr::Expr* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_body();

  static const int kExtFieldNumber = 107;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Function >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Function)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> path_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > inputs_;
  ::generated::proto::type::Type* output_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Function* default_instance_;
};
// -------------------------------------------------------------------

class Lambda : public ::google::protobuf::Message {
 public:
  Lambda();
  virtual ~Lambda();

  Lambda(const Lambda& from);

  inline Lambda& operator=(const Lambda& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lambda& default_instance();

  void Swap(Lambda* other);

  // implements Message ----------------------------------------------

  Lambda* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lambda& from);
  void MergeFrom(const Lambda& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr inputs = 1;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& inputs(int index) const;
  inline ::generated::proto::expr::Expr* mutable_inputs(int index);
  inline ::generated::proto::expr::Expr* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_inputs();

  // optional .generated.proto.type.Type output = 2;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 2;
  inline const ::generated::proto::type::Type& output() const;
  inline ::generated::proto::type::Type* mutable_output();
  inline ::generated::proto::type::Type* release_output();
  inline void set_allocated_output(::generated::proto::type::Type* output);

  // repeated .generated.proto.expr.Expr body = 3;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& body(int index) const;
  inline ::generated::proto::expr::Expr* mutable_body(int index);
  inline ::generated::proto::expr::Expr* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_body();

  static const int kExtFieldNumber = 108;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Lambda >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Lambda)
 private:
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > inputs_;
  ::generated::proto::type::Type* output_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Lambda* default_instance_;
};
// -------------------------------------------------------------------

class Grouped : public ::google::protobuf::Message {
 public:
  Grouped();
  virtual ~Grouped();

  Grouped(const Grouped& from);

  inline Grouped& operator=(const Grouped& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Grouped& default_instance();

  void Swap(Grouped* other);

  // implements Message ----------------------------------------------

  Grouped* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Grouped& from);
  void MergeFrom(const Grouped& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  static const int kExtFieldNumber = 132;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Grouped >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Grouped)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* expr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Grouped* default_instance_;
};
// -------------------------------------------------------------------

class Import : public ::google::protobuf::Message {
 public:
  Import();
  virtual ~Import();

  Import(const Import& from);

  inline Import& operator=(const Import& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Import& default_instance();

  void Swap(Import* other);

  // implements Message ----------------------------------------------

  Import* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Import& from);
  void MergeFrom(const Import& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string path = 1;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path(int index) const;
  inline ::std::string* mutable_path(int index);
  inline void set_path(int index, const ::std::string& value);
  inline void set_path(int index, const char* value);
  inline void set_path(int index, const char* value, size_t size);
  inline ::std::string* add_path();
  inline void add_path(const ::std::string& value);
  inline void add_path(const char* value);
  inline void add_path(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& path() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_path();

  // optional .generated.proto.expr.Expr target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& target() const;
  inline ::generated::proto::expr::Expr* mutable_target();
  inline ::generated::proto::expr::Expr* release_target();
  inline void set_allocated_target(::generated::proto::expr::Expr* target);

  // optional string rename = 3;
  inline bool has_rename() const;
  inline void clear_rename();
  static const int kRenameFieldNumber = 3;
  inline const ::std::string& rename() const;
  inline void set_rename(const ::std::string& value);
  inline void set_rename(const char* value);
  inline void set_rename(const char* value, size_t size);
  inline ::std::string* mutable_rename();
  inline ::std::string* release_rename();
  inline void set_allocated_rename(::std::string* rename);

  static const int kExtFieldNumber = 109;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Import >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Import)
 private:
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_rename();
  inline void clear_has_rename();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> path_;
  ::generated::proto::expr::Expr* target_;
  ::std::string* rename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Import* default_instance_;
};
// -------------------------------------------------------------------

class ImportNative : public ::google::protobuf::Message {
 public:
  ImportNative();
  virtual ~ImportNative();

  ImportNative(const ImportNative& from);

  inline ImportNative& operator=(const ImportNative& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportNative& default_instance();

  void Swap(ImportNative* other);

  // implements Message ----------------------------------------------

  ImportNative* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImportNative& from);
  void MergeFrom(const ImportNative& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr segments = 1;
  inline int segments_size() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& segments(int index) const;
  inline ::generated::proto::expr::Expr* mutable_segments(int index);
  inline ::generated::proto::expr::Expr* add_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_segments();

  static const int kExtFieldNumber = 135;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::ImportNative >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.ImportNative)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static ImportNative* default_instance_;
};
// -------------------------------------------------------------------

class Infix : public ::google::protobuf::Message {
 public:
  Infix();
  virtual ~Infix();

  Infix(const Infix& from);

  inline Infix& operator=(const Infix& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Infix& default_instance();

  void Swap(Infix* other);

  // implements Message ----------------------------------------------

  Infix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Infix& from);
  void MergeFrom(const Infix& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .generated.proto.expr.Expr src = 2;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& src() const;
  inline ::generated::proto::expr::Expr* mutable_src();
  inline ::generated::proto::expr::Expr* release_src();
  inline void set_allocated_src(::generated::proto::expr::Expr* src);

  // optional .generated.proto.expr.Expr dst = 3;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& dst() const;
  inline ::generated::proto::expr::Expr* mutable_dst();
  inline ::generated::proto::expr::Expr* release_dst();
  inline void set_allocated_dst(::generated::proto::expr::Expr* dst);

  static const int kExtFieldNumber = 110;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Infix >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Infix)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dst();
  inline void clear_has_dst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::generated::proto::expr::Expr* src_;
  ::generated::proto::expr::Expr* dst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Infix* default_instance_;
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  void Swap(List* other);

  // implements Message ----------------------------------------------

  List* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& items(int index) const;
  inline ::generated::proto::expr::Expr* mutable_items(int index);
  inline ::generated::proto::expr::Expr* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_items();

  static const int kExtFieldNumber = 111;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::List >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.List)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static List* default_instance_;
};
// -------------------------------------------------------------------

class Lit : public ::google::protobuf::Message {
 public:
  Lit();
  virtual ~Lit();

  Lit(const Lit& from);

  inline Lit& operator=(const Lit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lit& default_instance();

  void Swap(Lit* other);

  // implements Message ----------------------------------------------

  Lit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lit& from);
  void MergeFrom(const Lit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.lit.Lit lvalue = 1;
  inline bool has_lvalue() const;
  inline void clear_lvalue();
  static const int kLvalueFieldNumber = 1;
  inline const ::generated::proto::lit::Lit& lvalue() const;
  inline ::generated::proto::lit::Lit* mutable_lvalue();
  inline ::generated::proto::lit::Lit* release_lvalue();
  inline void set_allocated_lvalue(::generated::proto::lit::Lit* lvalue);

  static const int kExtFieldNumber = 112;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Lit >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Lit)
 private:
  inline void set_has_lvalue();
  inline void clear_has_lvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::lit::Lit* lvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Lit* default_instance_;
};
// -------------------------------------------------------------------

class Tuple : public ::google::protobuf::Message {
 public:
  Tuple();
  virtual ~Tuple();

  Tuple(const Tuple& from);

  inline Tuple& operator=(const Tuple& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tuple& default_instance();

  void Swap(Tuple* other);

  // implements Message ----------------------------------------------

  Tuple* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tuple& from);
  void MergeFrom(const Tuple& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& items(int index) const;
  inline ::generated::proto::expr::Expr* mutable_items(int index);
  inline ::generated::proto::expr::Expr* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_items();

  static const int kExtFieldNumber = 113;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Tuple >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Tuple)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Tuple* default_instance_;
};
// -------------------------------------------------------------------

class Typed : public ::google::protobuf::Message {
 public:
  Typed();
  virtual ~Typed();

  Typed(const Typed& from);

  inline Typed& operator=(const Typed& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Typed& default_instance();

  void Swap(Typed* other);

  // implements Message ----------------------------------------------

  Typed* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Typed& from);
  void MergeFrom(const Typed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.type.Type cls = 1;
  inline bool has_cls() const;
  inline void clear_cls();
  static const int kClsFieldNumber = 1;
  inline const ::generated::proto::type::Type& cls() const;
  inline ::generated::proto::type::Type* mutable_cls();
  inline ::generated::proto::type::Type* release_cls();
  inline void set_allocated_cls(::generated::proto::type::Type* cls);

  // optional .generated.proto.expr.Expr expr = 2;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  static const int kExtFieldNumber = 114;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Typed >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Typed)
 private:
  inline void set_has_cls();
  inline void clear_has_cls();
  inline void set_has_expr();
  inline void clear_has_expr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::type::Type* cls_;
  ::generated::proto::expr::Expr* expr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Typed* default_instance_;
};
// -------------------------------------------------------------------

class Var : public ::google::protobuf::Message {
 public:
  Var();
  virtual ~Var();

  Var(const Var& from);

  inline Var& operator=(const Var& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Var& default_instance();

  void Swap(Var* other);

  // implements Message ----------------------------------------------

  Var* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Var& from);
  void MergeFrom(const Var& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  static const int kExtFieldNumber = 115;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Var >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Var)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Var* default_instance_;
};
// -------------------------------------------------------------------

class Wildcard : public ::google::protobuf::Message {
 public:
  Wildcard();
  virtual ~Wildcard();

  Wildcard(const Wildcard& from);

  inline Wildcard& operator=(const Wildcard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Wildcard& default_instance();

  void Swap(Wildcard* other);

  // implements Message ----------------------------------------------

  Wildcard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Wildcard& from);
  void MergeFrom(const Wildcard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  static const int kExtFieldNumber = 116;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Wildcard >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Wildcard)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Wildcard* default_instance_;
};
// -------------------------------------------------------------------

class RangeFromTo : public ::google::protobuf::Message {
 public:
  RangeFromTo();
  virtual ~RangeFromTo();

  RangeFromTo(const RangeFromTo& from);

  inline RangeFromTo& operator=(const RangeFromTo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeFromTo& default_instance();

  void Swap(RangeFromTo* other);

  // implements Message ----------------------------------------------

  RangeFromTo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeFromTo& from);
  void MergeFrom(const RangeFromTo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& start() const;
  inline ::generated::proto::expr::Expr* mutable_start();
  inline ::generated::proto::expr::Expr* release_start();
  inline void set_allocated_start(::generated::proto::expr::Expr* start);

  // optional .generated.proto.expr.Expr end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& end() const;
  inline ::generated::proto::expr::Expr* mutable_end();
  inline ::generated::proto::expr::Expr* release_end();
  inline void set_allocated_end(::generated::proto::expr::Expr* end);

  static const int kExtFieldNumber = 117;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::RangeFromTo >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.RangeFromTo)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* start_;
  ::generated::proto::expr::Expr* end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static RangeFromTo* default_instance_;
};
// -------------------------------------------------------------------

class RangeFrom : public ::google::protobuf::Message {
 public:
  RangeFrom();
  virtual ~RangeFrom();

  RangeFrom(const RangeFrom& from);

  inline RangeFrom& operator=(const RangeFrom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeFrom& default_instance();

  void Swap(RangeFrom* other);

  // implements Message ----------------------------------------------

  RangeFrom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangeFrom& from);
  void MergeFrom(const RangeFrom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& start() const;
  inline ::generated::proto::expr::Expr* mutable_start();
  inline ::generated::proto::expr::Expr* release_start();
  inline void set_allocated_start(::generated::proto::expr::Expr* start);

  static const int kExtFieldNumber = 118;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::RangeFrom >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.RangeFrom)
 private:
  inline void set_has_start();
  inline void clear_has_start();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* start_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static RangeFrom* default_instance_;
};
// -------------------------------------------------------------------

class Field : public ::google::protobuf::Message {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Field& default_instance();

  void Swap(Field* other);

  // implements Message ----------------------------------------------

  Field* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .generated.proto.type.Type cls = 2;
  inline bool has_cls() const;
  inline void clear_cls();
  static const int kClsFieldNumber = 2;
  inline const ::generated::proto::type::Type& cls() const;
  inline ::generated::proto::type::Type* mutable_cls();
  inline ::generated::proto::type::Type* release_cls();
  inline void set_allocated_cls(::generated::proto::type::Type* cls);

  // optional .generated.proto.expr.Expr value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::generated::proto::expr::Expr& value() const;
  inline ::generated::proto::expr::Expr* mutable_value();
  inline ::generated::proto::expr::Expr* release_value();
  inline void set_allocated_value(::generated::proto::expr::Expr* value);

  static const int kExtFieldNumber = 119;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Field >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Field)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_cls();
  inline void clear_has_cls();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::generated::proto::type::Type* cls_;
  ::generated::proto::expr::Expr* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Field* default_instance_;
};
// -------------------------------------------------------------------

class Arg : public ::google::protobuf::Message {
 public:
  Arg();
  virtual ~Arg();

  Arg(const Arg& from);

  inline Arg& operator=(const Arg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arg& default_instance();

  void Swap(Arg* other);

  // implements Message ----------------------------------------------

  Arg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arg& from);
  void MergeFrom(const Arg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.pat.Pat pat = 1;
  inline bool has_pat() const;
  inline void clear_pat();
  static const int kPatFieldNumber = 1;
  inline const ::generated::proto::pat::Pat& pat() const;
  inline ::generated::proto::pat::Pat* mutable_pat();
  inline ::generated::proto::pat::Pat* release_pat();
  inline void set_allocated_pat(::generated::proto::pat::Pat* pat);

  // optional .generated.proto.expr.Expr value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& value() const;
  inline ::generated::proto::expr::Expr* mutable_value();
  inline ::generated::proto::expr::Expr* release_value();
  inline void set_allocated_value(::generated::proto::expr::Expr* value);

  static const int kExtFieldNumber = 120;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Arg >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Arg)
 private:
  inline void set_has_pat();
  inline void clear_has_pat();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::pat::Pat* pat_;
  ::generated::proto::expr::Expr* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Arg* default_instance_;
};
// -------------------------------------------------------------------

class Native : public ::google::protobuf::Message {
 public:
  Native();
  virtual ~Native();

  Native(const Native& from);

  inline Native& operator=(const Native& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Native& default_instance();

  void Swap(Native* other);

  // implements Message ----------------------------------------------

  Native* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Native& from);
  void MergeFrom(const Native& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .generated.proto.expr.Expr segments = 1;
  inline int segments_size() const;
  inline void clear_segments();
  static const int kSegmentsFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& segments(int index) const;
  inline ::generated::proto::expr::Expr* mutable_segments(int index);
  inline ::generated::proto::expr::Expr* add_segments();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      segments() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_segments();

  static const int kExtFieldNumber = 121;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Native >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Native)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > segments_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Native* default_instance_;
};
// -------------------------------------------------------------------

class NativeCode : public ::google::protobuf::Message {
 public:
  NativeCode();
  virtual ~NativeCode();

  NativeCode(const NativeCode& from);

  inline NativeCode& operator=(const NativeCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NativeCode& default_instance();

  void Swap(NativeCode* other);

  // implements Message ----------------------------------------------

  NativeCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NativeCode& from);
  void MergeFrom(const NativeCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  static const int kExtFieldNumber = 122;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::NativeCode >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.NativeCode)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static NativeCode* default_instance_;
};
// -------------------------------------------------------------------

class NativeVar : public ::google::protobuf::Message {
 public:
  NativeVar();
  virtual ~NativeVar();

  NativeVar(const NativeVar& from);

  inline NativeVar& operator=(const NativeVar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NativeVar& default_instance();

  void Swap(NativeVar* other);

  // implements Message ----------------------------------------------

  NativeVar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NativeVar& from);
  void MergeFrom(const NativeVar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  static const int kExtFieldNumber = 123;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::NativeVar >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.NativeVar)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static NativeVar* default_instance_;
};
// -------------------------------------------------------------------

class Ref : public ::google::protobuf::Message {
 public:
  Ref();
  virtual ~Ref();

  Ref(const Ref& from);

  inline Ref& operator=(const Ref& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ref& default_instance();

  void Swap(Ref* other);

  // implements Message ----------------------------------------------

  Ref* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ref& from);
  void MergeFrom(const Ref& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr dst = 1;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& dst() const;
  inline ::generated::proto::expr::Expr* mutable_dst();
  inline ::generated::proto::expr::Expr* release_dst();
  inline void set_allocated_dst(::generated::proto::expr::Expr* dst);

  static const int kExtFieldNumber = 133;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Ref >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Ref)
 private:
  inline void set_has_dst();
  inline void clear_has_dst();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* dst_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Ref* default_instance_;
};
// -------------------------------------------------------------------

class RefType : public ::google::protobuf::Message {
 public:
  RefType();
  virtual ~RefType();

  RefType(const RefType& from);

  inline RefType& operator=(const RefType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RefType& default_instance();

  void Swap(RefType* other);

  // implements Message ----------------------------------------------

  RefType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RefType& from);
  void MergeFrom(const RefType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string typename = 1;
  inline bool has_typename_() const;
  inline void clear_typename_();
  static const int kTypenameFieldNumber = 1;
  inline const ::std::string& typename_() const;
  inline void set_typename_(const ::std::string& value);
  inline void set_typename_(const char* value);
  inline void set_typename_(const char* value, size_t size);
  inline ::std::string* mutable_typename_();
  inline ::std::string* release_typename_();
  inline void set_allocated_typename_(::std::string* typename_);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  static const int kExtFieldNumber = 134;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::RefType >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.RefType)
 private:
  inline void set_has_typename_();
  inline void clear_has_typename_();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* typename__;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static RefType* default_instance_;
};
// -------------------------------------------------------------------

class Case : public ::google::protobuf::Message {
 public:
  Case();
  virtual ~Case();

  Case(const Case& from);

  inline Case& operator=(const Case& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Case& default_instance();

  void Swap(Case* other);

  // implements Message ----------------------------------------------

  Case* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Case& from);
  void MergeFrom(const Case& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.expr.Expr expr = 1;
  inline bool has_expr() const;
  inline void clear_expr();
  static const int kExprFieldNumber = 1;
  inline const ::generated::proto::expr::Expr& expr() const;
  inline ::generated::proto::expr::Expr* mutable_expr();
  inline ::generated::proto::expr::Expr* release_expr();
  inline void set_allocated_expr(::generated::proto::expr::Expr* expr);

  // repeated .generated.proto.expr.Expr match = 2;
  inline int match_size() const;
  inline void clear_match();
  static const int kMatchFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& match(int index) const;
  inline ::generated::proto::expr::Expr* mutable_match(int index);
  inline ::generated::proto::expr::Expr* add_match();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      match() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_match();

  static const int kExtFieldNumber = 124;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Case >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Case)
 private:
  inline void set_has_expr();
  inline void clear_has_expr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::expr::Expr* expr_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > match_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Case* default_instance_;
};
// -------------------------------------------------------------------

class Match : public ::google::protobuf::Message {
 public:
  Match();
  virtual ~Match();

  Match(const Match& from);

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Match& default_instance();

  void Swap(Match* other);

  // implements Message ----------------------------------------------

  Match* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Match& from);
  void MergeFrom(const Match& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .generated.proto.pat.Pat pat = 1;
  inline bool has_pat() const;
  inline void clear_pat();
  static const int kPatFieldNumber = 1;
  inline const ::generated::proto::pat::Pat& pat() const;
  inline ::generated::proto::pat::Pat* mutable_pat();
  inline ::generated::proto::pat::Pat* release_pat();
  inline void set_allocated_pat(::generated::proto::pat::Pat* pat);

  // repeated .generated.proto.expr.Expr body = 2;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::generated::proto::expr::Expr& body(int index) const;
  inline ::generated::proto::expr::Expr* mutable_body(int index);
  inline ::generated::proto::expr::Expr* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
      mutable_body();

  static const int kExtFieldNumber = 125;
  static ::google::protobuf::internal::ExtensionIdentifier< ::generated::proto::expr::Expr,
      ::google::protobuf::internal::MessageTypeTraits< ::generated::proto::expr::Match >, 11, false >
    ext;
  // @@protoc_insertion_point(class_scope:generated.proto.expr.Match)
 private:
  inline void set_has_pat();
  inline void clear_has_pat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::generated::proto::pat::Pat* pat_;
  ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_expr_2eproto();
  friend void protobuf_AssignDesc_expr_2eproto();
  friend void protobuf_ShutdownFile_expr_2eproto();

  void InitAsDefaultInstance();
  static Match* default_instance_;
};
// ===================================================================


// ===================================================================

// Expr

// required .generated.proto.expr.Expr.Cls cls = 1;
inline bool Expr::has_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_cls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_cls() {
  cls_ = 1;
  clear_has_cls();
}
inline ::generated::proto::expr::Expr_Cls Expr::cls() const {
  return static_cast< ::generated::proto::expr::Expr_Cls >(cls_);
}
inline void Expr::set_cls(::generated::proto::expr::Expr_Cls value) {
  assert(::generated::proto::expr::Expr_Cls_IsValid(value));
  set_has_cls();
  cls_ = value;
}

// optional int32 id = 2 [default = -1];
inline bool Expr::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 Expr::id() const {
  return id_;
}
inline void Expr::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// NOP

// -------------------------------------------------------------------

// Accessor

// optional string name = 1;
inline bool Accessor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Accessor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Accessor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Accessor::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Accessor::name() const {
  return *name_;
}
inline void Accessor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Accessor::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Accessor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Accessor::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Accessor::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Accessor::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .generated.proto.expr.Expr dst = 2;
inline bool Accessor::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Accessor::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Accessor::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Accessor::clear_dst() {
  if (dst_ != NULL) dst_->::generated::proto::expr::Expr::Clear();
  clear_has_dst();
}
inline const ::generated::proto::expr::Expr& Accessor::dst() const {
  return dst_ != NULL ? *dst_ : *default_instance_->dst_;
}
inline ::generated::proto::expr::Expr* Accessor::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) dst_ = new ::generated::proto::expr::Expr;
  return dst_;
}
inline ::generated::proto::expr::Expr* Accessor::release_dst() {
  clear_has_dst();
  ::generated::proto::expr::Expr* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void Accessor::set_allocated_dst(::generated::proto::expr::Expr* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
}

// -------------------------------------------------------------------

// TypeAlias

// optional .generated.proto.type.Type srcType = 1;
inline bool TypeAlias::has_srctype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeAlias::set_has_srctype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeAlias::clear_has_srctype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeAlias::clear_srctype() {
  if (srctype_ != NULL) srctype_->::generated::proto::type::Type::Clear();
  clear_has_srctype();
}
inline const ::generated::proto::type::Type& TypeAlias::srctype() const {
  return srctype_ != NULL ? *srctype_ : *default_instance_->srctype_;
}
inline ::generated::proto::type::Type* TypeAlias::mutable_srctype() {
  set_has_srctype();
  if (srctype_ == NULL) srctype_ = new ::generated::proto::type::Type;
  return srctype_;
}
inline ::generated::proto::type::Type* TypeAlias::release_srctype() {
  clear_has_srctype();
  ::generated::proto::type::Type* temp = srctype_;
  srctype_ = NULL;
  return temp;
}
inline void TypeAlias::set_allocated_srctype(::generated::proto::type::Type* srctype) {
  delete srctype_;
  srctype_ = srctype;
  if (srctype) {
    set_has_srctype();
  } else {
    clear_has_srctype();
  }
}

// optional .generated.proto.type.Type dstType = 2;
inline bool TypeAlias::has_dsttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeAlias::set_has_dsttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeAlias::clear_has_dsttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TypeAlias::clear_dsttype() {
  if (dsttype_ != NULL) dsttype_->::generated::proto::type::Type::Clear();
  clear_has_dsttype();
}
inline const ::generated::proto::type::Type& TypeAlias::dsttype() const {
  return dsttype_ != NULL ? *dsttype_ : *default_instance_->dsttype_;
}
inline ::generated::proto::type::Type* TypeAlias::mutable_dsttype() {
  set_has_dsttype();
  if (dsttype_ == NULL) dsttype_ = new ::generated::proto::type::Type;
  return dsttype_;
}
inline ::generated::proto::type::Type* TypeAlias::release_dsttype() {
  clear_has_dsttype();
  ::generated::proto::type::Type* temp = dsttype_;
  dsttype_ = NULL;
  return temp;
}
inline void TypeAlias::set_allocated_dsttype(::generated::proto::type::Type* dsttype) {
  delete dsttype_;
  dsttype_ = dsttype;
  if (dsttype) {
    set_has_dsttype();
  } else {
    clear_has_dsttype();
  }
}

// -------------------------------------------------------------------

// TypeDef

// optional .generated.proto.type.Type srcType = 1;
inline bool TypeDef::has_srctype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TypeDef::set_has_srctype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TypeDef::clear_has_srctype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TypeDef::clear_srctype() {
  if (srctype_ != NULL) srctype_->::generated::proto::type::Type::Clear();
  clear_has_srctype();
}
inline const ::generated::proto::type::Type& TypeDef::srctype() const {
  return srctype_ != NULL ? *srctype_ : *default_instance_->srctype_;
}
inline ::generated::proto::type::Type* TypeDef::mutable_srctype() {
  set_has_srctype();
  if (srctype_ == NULL) srctype_ = new ::generated::proto::type::Type;
  return srctype_;
}
inline ::generated::proto::type::Type* TypeDef::release_srctype() {
  clear_has_srctype();
  ::generated::proto::type::Type* temp = srctype_;
  srctype_ = NULL;
  return temp;
}
inline void TypeDef::set_allocated_srctype(::generated::proto::type::Type* srctype) {
  delete srctype_;
  srctype_ = srctype;
  if (srctype) {
    set_has_srctype();
  } else {
    clear_has_srctype();
  }
}

// optional .generated.proto.type.Type dstType = 2;
inline bool TypeDef::has_dsttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TypeDef::set_has_dsttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TypeDef::clear_has_dsttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TypeDef::clear_dsttype() {
  if (dsttype_ != NULL) dsttype_->::generated::proto::type::Type::Clear();
  clear_has_dsttype();
}
inline const ::generated::proto::type::Type& TypeDef::dsttype() const {
  return dsttype_ != NULL ? *dsttype_ : *default_instance_->dsttype_;
}
inline ::generated::proto::type::Type* TypeDef::mutable_dsttype() {
  set_has_dsttype();
  if (dsttype_ == NULL) dsttype_ = new ::generated::proto::type::Type;
  return dsttype_;
}
inline ::generated::proto::type::Type* TypeDef::release_dsttype() {
  clear_has_dsttype();
  ::generated::proto::type::Type* temp = dsttype_;
  dsttype_ = NULL;
  return temp;
}
inline void TypeDef::set_allocated_dsttype(::generated::proto::type::Type* dsttype) {
  delete dsttype_;
  dsttype_ = dsttype;
  if (dsttype) {
    set_has_dsttype();
  } else {
    clear_has_dsttype();
  }
}

// -------------------------------------------------------------------

// App

// optional .generated.proto.expr.Expr src = 1;
inline bool App::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void App::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void App::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void App::clear_src() {
  if (src_ != NULL) src_->::generated::proto::expr::Expr::Clear();
  clear_has_src();
}
inline const ::generated::proto::expr::Expr& App::src() const {
  return src_ != NULL ? *src_ : *default_instance_->src_;
}
inline ::generated::proto::expr::Expr* App::mutable_src() {
  set_has_src();
  if (src_ == NULL) src_ = new ::generated::proto::expr::Expr;
  return src_;
}
inline ::generated::proto::expr::Expr* App::release_src() {
  clear_has_src();
  ::generated::proto::expr::Expr* temp = src_;
  src_ = NULL;
  return temp;
}
inline void App::set_allocated_src(::generated::proto::expr::Expr* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
}

// repeated .generated.proto.expr.Expr args = 2;
inline int App::args_size() const {
  return args_.size();
}
inline void App::clear_args() {
  args_.Clear();
}
inline const ::generated::proto::expr::Expr& App::args(int index) const {
  return args_.Get(index);
}
inline ::generated::proto::expr::Expr* App::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::generated::proto::expr::Expr* App::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
App::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
App::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// AppCons_

// repeated .generated.proto.expr.Expr args = 1;
inline int AppCons_::args_size() const {
  return args_.size();
}
inline void AppCons_::clear_args() {
  args_.Clear();
}
inline const ::generated::proto::expr::Expr& AppCons_::args(int index) const {
  return args_.Get(index);
}
inline ::generated::proto::expr::Expr* AppCons_::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::generated::proto::expr::Expr* AppCons_::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
AppCons_::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
AppCons_::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// Assignment

// optional .generated.proto.pat.Pat pat = 1;
inline bool Assignment::has_pat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Assignment::set_has_pat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Assignment::clear_has_pat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Assignment::clear_pat() {
  if (pat_ != NULL) pat_->::generated::proto::pat::Pat::Clear();
  clear_has_pat();
}
inline const ::generated::proto::pat::Pat& Assignment::pat() const {
  return pat_ != NULL ? *pat_ : *default_instance_->pat_;
}
inline ::generated::proto::pat::Pat* Assignment::mutable_pat() {
  set_has_pat();
  if (pat_ == NULL) pat_ = new ::generated::proto::pat::Pat;
  return pat_;
}
inline ::generated::proto::pat::Pat* Assignment::release_pat() {
  clear_has_pat();
  ::generated::proto::pat::Pat* temp = pat_;
  pat_ = NULL;
  return temp;
}
inline void Assignment::set_allocated_pat(::generated::proto::pat::Pat* pat) {
  delete pat_;
  pat_ = pat;
  if (pat) {
    set_has_pat();
  } else {
    clear_has_pat();
  }
}

// optional .generated.proto.expr.Expr dst = 2;
inline bool Assignment::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Assignment::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Assignment::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Assignment::clear_dst() {
  if (dst_ != NULL) dst_->::generated::proto::expr::Expr::Clear();
  clear_has_dst();
}
inline const ::generated::proto::expr::Expr& Assignment::dst() const {
  return dst_ != NULL ? *dst_ : *default_instance_->dst_;
}
inline ::generated::proto::expr::Expr* Assignment::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) dst_ = new ::generated::proto::expr::Expr;
  return dst_;
}
inline ::generated::proto::expr::Expr* Assignment::release_dst() {
  clear_has_dst();
  ::generated::proto::expr::Expr* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void Assignment::set_allocated_dst(::generated::proto::expr::Expr* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
}

// -------------------------------------------------------------------

// RecordUpdate

// optional .generated.proto.expr.Expr src = 1;
inline bool RecordUpdate::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecordUpdate::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecordUpdate::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecordUpdate::clear_src() {
  if (src_ != NULL) src_->::generated::proto::expr::Expr::Clear();
  clear_has_src();
}
inline const ::generated::proto::expr::Expr& RecordUpdate::src() const {
  return src_ != NULL ? *src_ : *default_instance_->src_;
}
inline ::generated::proto::expr::Expr* RecordUpdate::mutable_src() {
  set_has_src();
  if (src_ == NULL) src_ = new ::generated::proto::expr::Expr;
  return src_;
}
inline ::generated::proto::expr::Expr* RecordUpdate::release_src() {
  clear_has_src();
  ::generated::proto::expr::Expr* temp = src_;
  src_ = NULL;
  return temp;
}
inline void RecordUpdate::set_allocated_src(::generated::proto::expr::Expr* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
}

// repeated string selectors = 2;
inline int RecordUpdate::selectors_size() const {
  return selectors_.size();
}
inline void RecordUpdate::clear_selectors() {
  selectors_.Clear();
}
inline const ::std::string& RecordUpdate::selectors(int index) const {
  return selectors_.Get(index);
}
inline ::std::string* RecordUpdate::mutable_selectors(int index) {
  return selectors_.Mutable(index);
}
inline void RecordUpdate::set_selectors(int index, const ::std::string& value) {
  selectors_.Mutable(index)->assign(value);
}
inline void RecordUpdate::set_selectors(int index, const char* value) {
  selectors_.Mutable(index)->assign(value);
}
inline void RecordUpdate::set_selectors(int index, const char* value, size_t size) {
  selectors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecordUpdate::add_selectors() {
  return selectors_.Add();
}
inline void RecordUpdate::add_selectors(const ::std::string& value) {
  selectors_.Add()->assign(value);
}
inline void RecordUpdate::add_selectors(const char* value) {
  selectors_.Add()->assign(value);
}
inline void RecordUpdate::add_selectors(const char* value, size_t size) {
  selectors_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RecordUpdate::selectors() const {
  return selectors_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RecordUpdate::mutable_selectors() {
  return &selectors_;
}

// optional .generated.proto.expr.Expr expr = 3;
inline bool RecordUpdate::has_expr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecordUpdate::set_has_expr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecordUpdate::clear_has_expr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecordUpdate::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& RecordUpdate::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* RecordUpdate::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* RecordUpdate::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void RecordUpdate::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// -------------------------------------------------------------------

// Data

// optional .generated.proto.type.Type cls = 1;
inline bool Data::has_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_cls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_cls() {
  if (cls_ != NULL) cls_->::generated::proto::type::Type::Clear();
  clear_has_cls();
}
inline const ::generated::proto::type::Type& Data::cls() const {
  return cls_ != NULL ? *cls_ : *default_instance_->cls_;
}
inline ::generated::proto::type::Type* Data::mutable_cls() {
  set_has_cls();
  if (cls_ == NULL) cls_ = new ::generated::proto::type::Type;
  return cls_;
}
inline ::generated::proto::type::Type* Data::release_cls() {
  clear_has_cls();
  ::generated::proto::type::Type* temp = cls_;
  cls_ = NULL;
  return temp;
}
inline void Data::set_allocated_cls(::generated::proto::type::Type* cls) {
  delete cls_;
  cls_ = cls;
  if (cls) {
    set_has_cls();
  } else {
    clear_has_cls();
  }
}

// repeated .generated.proto.expr.Expr cons = 2;
inline int Data::cons_size() const {
  return cons_.size();
}
inline void Data::clear_cons() {
  cons_.Clear();
}
inline const ::generated::proto::expr::Expr& Data::cons(int index) const {
  return cons_.Get(index);
}
inline ::generated::proto::expr::Expr* Data::mutable_cons(int index) {
  return cons_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Data::add_cons() {
  return cons_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Data::cons() const {
  return cons_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Data::mutable_cons() {
  return &cons_;
}

// repeated .generated.proto.expr.Expr classes = 3;
inline int Data::classes_size() const {
  return classes_.size();
}
inline void Data::clear_classes() {
  classes_.Clear();
}
inline const ::generated::proto::expr::Expr& Data::classes(int index) const {
  return classes_.Get(index);
}
inline ::generated::proto::expr::Expr* Data::mutable_classes(int index) {
  return classes_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Data::add_classes() {
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Data::classes() const {
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Data::mutable_classes() {
  return &classes_;
}

// repeated .generated.proto.expr.Expr methods = 4;
inline int Data::methods_size() const {
  return methods_.size();
}
inline void Data::clear_methods() {
  methods_.Clear();
}
inline const ::generated::proto::expr::Expr& Data::methods(int index) const {
  return methods_.Get(index);
}
inline ::generated::proto::expr::Expr* Data::mutable_methods(int index) {
  return methods_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Data::add_methods() {
  return methods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Data::methods() const {
  return methods_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Data::mutable_methods() {
  return &methods_;
}

// -------------------------------------------------------------------

// ConD

// optional string name = 1;
inline bool ConD::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConD::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConD::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConD::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConD::name() const {
  return *name_;
}
inline void ConD::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConD::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConD::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConD::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConD::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConD::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .generated.proto.expr.Expr fields = 2;
inline int ConD::fields_size() const {
  return fields_.size();
}
inline void ConD::clear_fields() {
  fields_.Clear();
}
inline const ::generated::proto::expr::Expr& ConD::fields(int index) const {
  return fields_.Get(index);
}
inline ::generated::proto::expr::Expr* ConD::mutable_fields(int index) {
  return fields_.Mutable(index);
}
inline ::generated::proto::expr::Expr* ConD::add_fields() {
  return fields_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
ConD::fields() const {
  return fields_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
ConD::mutable_fields() {
  return &fields_;
}

// -------------------------------------------------------------------

// Con_

// optional string name = 1;
inline bool Con_::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Con_::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Con_::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Con_::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Con_::name() const {
  return *name_;
}
inline void Con_::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Con_::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Con_::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Con_::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Con_::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Con_::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Condition

// optional .generated.proto.expr.Expr cond = 1;
inline bool Condition::has_cond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_cond() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_cond() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_cond() {
  if (cond_ != NULL) cond_->::generated::proto::expr::Expr::Clear();
  clear_has_cond();
}
inline const ::generated::proto::expr::Expr& Condition::cond() const {
  return cond_ != NULL ? *cond_ : *default_instance_->cond_;
}
inline ::generated::proto::expr::Expr* Condition::mutable_cond() {
  set_has_cond();
  if (cond_ == NULL) cond_ = new ::generated::proto::expr::Expr;
  return cond_;
}
inline ::generated::proto::expr::Expr* Condition::release_cond() {
  clear_has_cond();
  ::generated::proto::expr::Expr* temp = cond_;
  cond_ = NULL;
  return temp;
}
inline void Condition::set_allocated_cond(::generated::proto::expr::Expr* cond) {
  delete cond_;
  cond_ = cond;
  if (cond) {
    set_has_cond();
  } else {
    clear_has_cond();
  }
}

// repeated .generated.proto.expr.Expr success = 2;
inline int Condition::success_size() const {
  return success_.size();
}
inline void Condition::clear_success() {
  success_.Clear();
}
inline const ::generated::proto::expr::Expr& Condition::success(int index) const {
  return success_.Get(index);
}
inline ::generated::proto::expr::Expr* Condition::mutable_success(int index) {
  return success_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Condition::add_success() {
  return success_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Condition::success() const {
  return success_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Condition::mutable_success() {
  return &success_;
}

// repeated .generated.proto.expr.Expr failure = 3;
inline int Condition::failure_size() const {
  return failure_.size();
}
inline void Condition::clear_failure() {
  failure_.Clear();
}
inline const ::generated::proto::expr::Expr& Condition::failure(int index) const {
  return failure_.Get(index);
}
inline ::generated::proto::expr::Expr* Condition::mutable_failure(int index) {
  return failure_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Condition::add_failure() {
  return failure_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Condition::failure() const {
  return failure_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Condition::mutable_failure() {
  return &failure_;
}

// -------------------------------------------------------------------

// Function

// repeated string path = 1;
inline int Function::path_size() const {
  return path_.size();
}
inline void Function::clear_path() {
  path_.Clear();
}
inline const ::std::string& Function::path(int index) const {
  return path_.Get(index);
}
inline ::std::string* Function::mutable_path(int index) {
  return path_.Mutable(index);
}
inline void Function::set_path(int index, const ::std::string& value) {
  path_.Mutable(index)->assign(value);
}
inline void Function::set_path(int index, const char* value) {
  path_.Mutable(index)->assign(value);
}
inline void Function::set_path(int index, const char* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::add_path() {
  return path_.Add();
}
inline void Function::add_path(const ::std::string& value) {
  path_.Add()->assign(value);
}
inline void Function::add_path(const char* value) {
  path_.Add()->assign(value);
}
inline void Function::add_path(const char* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Function::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Function::mutable_path() {
  return &path_;
}

// optional string name = 2;
inline bool Function::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Function::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Function::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Function::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Function::name() const {
  return *name_;
}
inline void Function::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Function::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Function::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Function::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Function::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .generated.proto.expr.Expr inputs = 3;
inline int Function::inputs_size() const {
  return inputs_.size();
}
inline void Function::clear_inputs() {
  inputs_.Clear();
}
inline const ::generated::proto::expr::Expr& Function::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::generated::proto::expr::Expr* Function::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Function::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Function::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Function::mutable_inputs() {
  return &inputs_;
}

// optional .generated.proto.type.Type output = 4;
inline bool Function::has_output() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Function::set_has_output() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Function::clear_has_output() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Function::clear_output() {
  if (output_ != NULL) output_->::generated::proto::type::Type::Clear();
  clear_has_output();
}
inline const ::generated::proto::type::Type& Function::output() const {
  return output_ != NULL ? *output_ : *default_instance_->output_;
}
inline ::generated::proto::type::Type* Function::mutable_output() {
  set_has_output();
  if (output_ == NULL) output_ = new ::generated::proto::type::Type;
  return output_;
}
inline ::generated::proto::type::Type* Function::release_output() {
  clear_has_output();
  ::generated::proto::type::Type* temp = output_;
  output_ = NULL;
  return temp;
}
inline void Function::set_allocated_output(::generated::proto::type::Type* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
}

// repeated .generated.proto.expr.Expr body = 5;
inline int Function::body_size() const {
  return body_.size();
}
inline void Function::clear_body() {
  body_.Clear();
}
inline const ::generated::proto::expr::Expr& Function::body(int index) const {
  return body_.Get(index);
}
inline ::generated::proto::expr::Expr* Function::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Function::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Function::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Function::mutable_body() {
  return &body_;
}

// -------------------------------------------------------------------

// Lambda

// repeated .generated.proto.expr.Expr inputs = 1;
inline int Lambda::inputs_size() const {
  return inputs_.size();
}
inline void Lambda::clear_inputs() {
  inputs_.Clear();
}
inline const ::generated::proto::expr::Expr& Lambda::inputs(int index) const {
  return inputs_.Get(index);
}
inline ::generated::proto::expr::Expr* Lambda::mutable_inputs(int index) {
  return inputs_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Lambda::add_inputs() {
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Lambda::inputs() const {
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Lambda::mutable_inputs() {
  return &inputs_;
}

// optional .generated.proto.type.Type output = 2;
inline bool Lambda::has_output() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lambda::set_has_output() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lambda::clear_has_output() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lambda::clear_output() {
  if (output_ != NULL) output_->::generated::proto::type::Type::Clear();
  clear_has_output();
}
inline const ::generated::proto::type::Type& Lambda::output() const {
  return output_ != NULL ? *output_ : *default_instance_->output_;
}
inline ::generated::proto::type::Type* Lambda::mutable_output() {
  set_has_output();
  if (output_ == NULL) output_ = new ::generated::proto::type::Type;
  return output_;
}
inline ::generated::proto::type::Type* Lambda::release_output() {
  clear_has_output();
  ::generated::proto::type::Type* temp = output_;
  output_ = NULL;
  return temp;
}
inline void Lambda::set_allocated_output(::generated::proto::type::Type* output) {
  delete output_;
  output_ = output;
  if (output) {
    set_has_output();
  } else {
    clear_has_output();
  }
}

// repeated .generated.proto.expr.Expr body = 3;
inline int Lambda::body_size() const {
  return body_.size();
}
inline void Lambda::clear_body() {
  body_.Clear();
}
inline const ::generated::proto::expr::Expr& Lambda::body(int index) const {
  return body_.Get(index);
}
inline ::generated::proto::expr::Expr* Lambda::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Lambda::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Lambda::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Lambda::mutable_body() {
  return &body_;
}

// -------------------------------------------------------------------

// Grouped

// optional .generated.proto.expr.Expr expr = 1;
inline bool Grouped::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Grouped::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Grouped::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Grouped::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& Grouped::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* Grouped::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* Grouped::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Grouped::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// -------------------------------------------------------------------

// Import

// repeated string path = 1;
inline int Import::path_size() const {
  return path_.size();
}
inline void Import::clear_path() {
  path_.Clear();
}
inline const ::std::string& Import::path(int index) const {
  return path_.Get(index);
}
inline ::std::string* Import::mutable_path(int index) {
  return path_.Mutable(index);
}
inline void Import::set_path(int index, const ::std::string& value) {
  path_.Mutable(index)->assign(value);
}
inline void Import::set_path(int index, const char* value) {
  path_.Mutable(index)->assign(value);
}
inline void Import::set_path(int index, const char* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Import::add_path() {
  return path_.Add();
}
inline void Import::add_path(const ::std::string& value) {
  path_.Add()->assign(value);
}
inline void Import::add_path(const char* value) {
  path_.Add()->assign(value);
}
inline void Import::add_path(const char* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Import::path() const {
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Import::mutable_path() {
  return &path_;
}

// optional .generated.proto.expr.Expr target = 2;
inline bool Import::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Import::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Import::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Import::clear_target() {
  if (target_ != NULL) target_->::generated::proto::expr::Expr::Clear();
  clear_has_target();
}
inline const ::generated::proto::expr::Expr& Import::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::generated::proto::expr::Expr* Import::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::generated::proto::expr::Expr;
  return target_;
}
inline ::generated::proto::expr::Expr* Import::release_target() {
  clear_has_target();
  ::generated::proto::expr::Expr* temp = target_;
  target_ = NULL;
  return temp;
}
inline void Import::set_allocated_target(::generated::proto::expr::Expr* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
}

// optional string rename = 3;
inline bool Import::has_rename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Import::set_has_rename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Import::clear_has_rename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Import::clear_rename() {
  if (rename_ != &::google::protobuf::internal::kEmptyString) {
    rename_->clear();
  }
  clear_has_rename();
}
inline const ::std::string& Import::rename() const {
  return *rename_;
}
inline void Import::set_rename(const ::std::string& value) {
  set_has_rename();
  if (rename_ == &::google::protobuf::internal::kEmptyString) {
    rename_ = new ::std::string;
  }
  rename_->assign(value);
}
inline void Import::set_rename(const char* value) {
  set_has_rename();
  if (rename_ == &::google::protobuf::internal::kEmptyString) {
    rename_ = new ::std::string;
  }
  rename_->assign(value);
}
inline void Import::set_rename(const char* value, size_t size) {
  set_has_rename();
  if (rename_ == &::google::protobuf::internal::kEmptyString) {
    rename_ = new ::std::string;
  }
  rename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Import::mutable_rename() {
  set_has_rename();
  if (rename_ == &::google::protobuf::internal::kEmptyString) {
    rename_ = new ::std::string;
  }
  return rename_;
}
inline ::std::string* Import::release_rename() {
  clear_has_rename();
  if (rename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rename_;
    rename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Import::set_allocated_rename(::std::string* rename) {
  if (rename_ != &::google::protobuf::internal::kEmptyString) {
    delete rename_;
  }
  if (rename) {
    set_has_rename();
    rename_ = rename;
  } else {
    clear_has_rename();
    rename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ImportNative

// repeated .generated.proto.expr.Expr segments = 1;
inline int ImportNative::segments_size() const {
  return segments_.size();
}
inline void ImportNative::clear_segments() {
  segments_.Clear();
}
inline const ::generated::proto::expr::Expr& ImportNative::segments(int index) const {
  return segments_.Get(index);
}
inline ::generated::proto::expr::Expr* ImportNative::mutable_segments(int index) {
  return segments_.Mutable(index);
}
inline ::generated::proto::expr::Expr* ImportNative::add_segments() {
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
ImportNative::segments() const {
  return segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
ImportNative::mutable_segments() {
  return &segments_;
}

// -------------------------------------------------------------------

// Infix

// optional string name = 1;
inline bool Infix::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Infix::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Infix::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Infix::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Infix::name() const {
  return *name_;
}
inline void Infix::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Infix::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Infix::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Infix::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Infix::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Infix::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .generated.proto.expr.Expr src = 2;
inline bool Infix::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Infix::set_has_src() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Infix::clear_has_src() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Infix::clear_src() {
  if (src_ != NULL) src_->::generated::proto::expr::Expr::Clear();
  clear_has_src();
}
inline const ::generated::proto::expr::Expr& Infix::src() const {
  return src_ != NULL ? *src_ : *default_instance_->src_;
}
inline ::generated::proto::expr::Expr* Infix::mutable_src() {
  set_has_src();
  if (src_ == NULL) src_ = new ::generated::proto::expr::Expr;
  return src_;
}
inline ::generated::proto::expr::Expr* Infix::release_src() {
  clear_has_src();
  ::generated::proto::expr::Expr* temp = src_;
  src_ = NULL;
  return temp;
}
inline void Infix::set_allocated_src(::generated::proto::expr::Expr* src) {
  delete src_;
  src_ = src;
  if (src) {
    set_has_src();
  } else {
    clear_has_src();
  }
}

// optional .generated.proto.expr.Expr dst = 3;
inline bool Infix::has_dst() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Infix::set_has_dst() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Infix::clear_has_dst() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Infix::clear_dst() {
  if (dst_ != NULL) dst_->::generated::proto::expr::Expr::Clear();
  clear_has_dst();
}
inline const ::generated::proto::expr::Expr& Infix::dst() const {
  return dst_ != NULL ? *dst_ : *default_instance_->dst_;
}
inline ::generated::proto::expr::Expr* Infix::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) dst_ = new ::generated::proto::expr::Expr;
  return dst_;
}
inline ::generated::proto::expr::Expr* Infix::release_dst() {
  clear_has_dst();
  ::generated::proto::expr::Expr* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void Infix::set_allocated_dst(::generated::proto::expr::Expr* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
}

// -------------------------------------------------------------------

// List

// repeated .generated.proto.expr.Expr items = 1;
inline int List::items_size() const {
  return items_.size();
}
inline void List::clear_items() {
  items_.Clear();
}
inline const ::generated::proto::expr::Expr& List::items(int index) const {
  return items_.Get(index);
}
inline ::generated::proto::expr::Expr* List::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::generated::proto::expr::Expr* List::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
List::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
List::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Lit

// optional .generated.proto.lit.Lit lvalue = 1;
inline bool Lit::has_lvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lit::set_has_lvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lit::clear_has_lvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lit::clear_lvalue() {
  if (lvalue_ != NULL) lvalue_->::generated::proto::lit::Lit::Clear();
  clear_has_lvalue();
}
inline const ::generated::proto::lit::Lit& Lit::lvalue() const {
  return lvalue_ != NULL ? *lvalue_ : *default_instance_->lvalue_;
}
inline ::generated::proto::lit::Lit* Lit::mutable_lvalue() {
  set_has_lvalue();
  if (lvalue_ == NULL) lvalue_ = new ::generated::proto::lit::Lit;
  return lvalue_;
}
inline ::generated::proto::lit::Lit* Lit::release_lvalue() {
  clear_has_lvalue();
  ::generated::proto::lit::Lit* temp = lvalue_;
  lvalue_ = NULL;
  return temp;
}
inline void Lit::set_allocated_lvalue(::generated::proto::lit::Lit* lvalue) {
  delete lvalue_;
  lvalue_ = lvalue;
  if (lvalue) {
    set_has_lvalue();
  } else {
    clear_has_lvalue();
  }
}

// -------------------------------------------------------------------

// Tuple

// repeated .generated.proto.expr.Expr items = 1;
inline int Tuple::items_size() const {
  return items_.size();
}
inline void Tuple::clear_items() {
  items_.Clear();
}
inline const ::generated::proto::expr::Expr& Tuple::items(int index) const {
  return items_.Get(index);
}
inline ::generated::proto::expr::Expr* Tuple::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Tuple::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Tuple::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Tuple::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// Typed

// optional .generated.proto.type.Type cls = 1;
inline bool Typed::has_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Typed::set_has_cls() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Typed::clear_has_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Typed::clear_cls() {
  if (cls_ != NULL) cls_->::generated::proto::type::Type::Clear();
  clear_has_cls();
}
inline const ::generated::proto::type::Type& Typed::cls() const {
  return cls_ != NULL ? *cls_ : *default_instance_->cls_;
}
inline ::generated::proto::type::Type* Typed::mutable_cls() {
  set_has_cls();
  if (cls_ == NULL) cls_ = new ::generated::proto::type::Type;
  return cls_;
}
inline ::generated::proto::type::Type* Typed::release_cls() {
  clear_has_cls();
  ::generated::proto::type::Type* temp = cls_;
  cls_ = NULL;
  return temp;
}
inline void Typed::set_allocated_cls(::generated::proto::type::Type* cls) {
  delete cls_;
  cls_ = cls;
  if (cls) {
    set_has_cls();
  } else {
    clear_has_cls();
  }
}

// optional .generated.proto.expr.Expr expr = 2;
inline bool Typed::has_expr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Typed::set_has_expr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Typed::clear_has_expr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Typed::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& Typed::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* Typed::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* Typed::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Typed::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// -------------------------------------------------------------------

// Var

// optional string name = 1;
inline bool Var::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Var::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Var::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Var::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Var::name() const {
  return *name_;
}
inline void Var::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Var::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Var::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Var::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Var::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Var::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Wildcard

// -------------------------------------------------------------------

// RangeFromTo

// optional .generated.proto.expr.Expr start = 1;
inline bool RangeFromTo::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeFromTo::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeFromTo::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeFromTo::clear_start() {
  if (start_ != NULL) start_->::generated::proto::expr::Expr::Clear();
  clear_has_start();
}
inline const ::generated::proto::expr::Expr& RangeFromTo::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::generated::proto::expr::Expr* RangeFromTo::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::generated::proto::expr::Expr;
  return start_;
}
inline ::generated::proto::expr::Expr* RangeFromTo::release_start() {
  clear_has_start();
  ::generated::proto::expr::Expr* temp = start_;
  start_ = NULL;
  return temp;
}
inline void RangeFromTo::set_allocated_start(::generated::proto::expr::Expr* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// optional .generated.proto.expr.Expr end = 2;
inline bool RangeFromTo::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RangeFromTo::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RangeFromTo::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RangeFromTo::clear_end() {
  if (end_ != NULL) end_->::generated::proto::expr::Expr::Clear();
  clear_has_end();
}
inline const ::generated::proto::expr::Expr& RangeFromTo::end() const {
  return end_ != NULL ? *end_ : *default_instance_->end_;
}
inline ::generated::proto::expr::Expr* RangeFromTo::mutable_end() {
  set_has_end();
  if (end_ == NULL) end_ = new ::generated::proto::expr::Expr;
  return end_;
}
inline ::generated::proto::expr::Expr* RangeFromTo::release_end() {
  clear_has_end();
  ::generated::proto::expr::Expr* temp = end_;
  end_ = NULL;
  return temp;
}
inline void RangeFromTo::set_allocated_end(::generated::proto::expr::Expr* end) {
  delete end_;
  end_ = end;
  if (end) {
    set_has_end();
  } else {
    clear_has_end();
  }
}

// -------------------------------------------------------------------

// RangeFrom

// optional .generated.proto.expr.Expr start = 1;
inline bool RangeFrom::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangeFrom::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangeFrom::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangeFrom::clear_start() {
  if (start_ != NULL) start_->::generated::proto::expr::Expr::Clear();
  clear_has_start();
}
inline const ::generated::proto::expr::Expr& RangeFrom::start() const {
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::generated::proto::expr::Expr* RangeFrom::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::generated::proto::expr::Expr;
  return start_;
}
inline ::generated::proto::expr::Expr* RangeFrom::release_start() {
  clear_has_start();
  ::generated::proto::expr::Expr* temp = start_;
  start_ = NULL;
  return temp;
}
inline void RangeFrom::set_allocated_start(::generated::proto::expr::Expr* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
}

// -------------------------------------------------------------------

// Field

// optional string name = 1;
inline bool Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Field::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Field::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Field::name() const {
  return *name_;
}
inline void Field::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Field::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Field::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Field::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Field::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .generated.proto.type.Type cls = 2;
inline bool Field::has_cls() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Field::set_has_cls() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Field::clear_has_cls() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Field::clear_cls() {
  if (cls_ != NULL) cls_->::generated::proto::type::Type::Clear();
  clear_has_cls();
}
inline const ::generated::proto::type::Type& Field::cls() const {
  return cls_ != NULL ? *cls_ : *default_instance_->cls_;
}
inline ::generated::proto::type::Type* Field::mutable_cls() {
  set_has_cls();
  if (cls_ == NULL) cls_ = new ::generated::proto::type::Type;
  return cls_;
}
inline ::generated::proto::type::Type* Field::release_cls() {
  clear_has_cls();
  ::generated::proto::type::Type* temp = cls_;
  cls_ = NULL;
  return temp;
}
inline void Field::set_allocated_cls(::generated::proto::type::Type* cls) {
  delete cls_;
  cls_ = cls;
  if (cls) {
    set_has_cls();
  } else {
    clear_has_cls();
  }
}

// optional .generated.proto.expr.Expr value = 3;
inline bool Field::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Field::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Field::clear_value() {
  if (value_ != NULL) value_->::generated::proto::expr::Expr::Clear();
  clear_has_value();
}
inline const ::generated::proto::expr::Expr& Field::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::generated::proto::expr::Expr* Field::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::generated::proto::expr::Expr;
  return value_;
}
inline ::generated::proto::expr::Expr* Field::release_value() {
  clear_has_value();
  ::generated::proto::expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Field::set_allocated_value(::generated::proto::expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// Arg

// optional .generated.proto.pat.Pat pat = 1;
inline bool Arg::has_pat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Arg::set_has_pat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Arg::clear_has_pat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Arg::clear_pat() {
  if (pat_ != NULL) pat_->::generated::proto::pat::Pat::Clear();
  clear_has_pat();
}
inline const ::generated::proto::pat::Pat& Arg::pat() const {
  return pat_ != NULL ? *pat_ : *default_instance_->pat_;
}
inline ::generated::proto::pat::Pat* Arg::mutable_pat() {
  set_has_pat();
  if (pat_ == NULL) pat_ = new ::generated::proto::pat::Pat;
  return pat_;
}
inline ::generated::proto::pat::Pat* Arg::release_pat() {
  clear_has_pat();
  ::generated::proto::pat::Pat* temp = pat_;
  pat_ = NULL;
  return temp;
}
inline void Arg::set_allocated_pat(::generated::proto::pat::Pat* pat) {
  delete pat_;
  pat_ = pat;
  if (pat) {
    set_has_pat();
  } else {
    clear_has_pat();
  }
}

// optional .generated.proto.expr.Expr value = 2;
inline bool Arg::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Arg::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Arg::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Arg::clear_value() {
  if (value_ != NULL) value_->::generated::proto::expr::Expr::Clear();
  clear_has_value();
}
inline const ::generated::proto::expr::Expr& Arg::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::generated::proto::expr::Expr* Arg::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::generated::proto::expr::Expr;
  return value_;
}
inline ::generated::proto::expr::Expr* Arg::release_value() {
  clear_has_value();
  ::generated::proto::expr::Expr* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Arg::set_allocated_value(::generated::proto::expr::Expr* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// Native

// repeated .generated.proto.expr.Expr segments = 1;
inline int Native::segments_size() const {
  return segments_.size();
}
inline void Native::clear_segments() {
  segments_.Clear();
}
inline const ::generated::proto::expr::Expr& Native::segments(int index) const {
  return segments_.Get(index);
}
inline ::generated::proto::expr::Expr* Native::mutable_segments(int index) {
  return segments_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Native::add_segments() {
  return segments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Native::segments() const {
  return segments_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Native::mutable_segments() {
  return &segments_;
}

// -------------------------------------------------------------------

// NativeCode

// optional string code = 1;
inline bool NativeCode::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NativeCode::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NativeCode::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NativeCode::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& NativeCode::code() const {
  return *code_;
}
inline void NativeCode::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void NativeCode::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void NativeCode::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NativeCode::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* NativeCode::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NativeCode::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NativeVar

// optional string name = 1;
inline bool NativeVar::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NativeVar::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NativeVar::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NativeVar::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NativeVar::name() const {
  return *name_;
}
inline void NativeVar::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NativeVar::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NativeVar::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NativeVar::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NativeVar::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NativeVar::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Ref

// optional .generated.proto.expr.Expr dst = 1;
inline bool Ref::has_dst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ref::set_has_dst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ref::clear_has_dst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ref::clear_dst() {
  if (dst_ != NULL) dst_->::generated::proto::expr::Expr::Clear();
  clear_has_dst();
}
inline const ::generated::proto::expr::Expr& Ref::dst() const {
  return dst_ != NULL ? *dst_ : *default_instance_->dst_;
}
inline ::generated::proto::expr::Expr* Ref::mutable_dst() {
  set_has_dst();
  if (dst_ == NULL) dst_ = new ::generated::proto::expr::Expr;
  return dst_;
}
inline ::generated::proto::expr::Expr* Ref::release_dst() {
  clear_has_dst();
  ::generated::proto::expr::Expr* temp = dst_;
  dst_ = NULL;
  return temp;
}
inline void Ref::set_allocated_dst(::generated::proto::expr::Expr* dst) {
  delete dst_;
  dst_ = dst;
  if (dst) {
    set_has_dst();
  } else {
    clear_has_dst();
  }
}

// -------------------------------------------------------------------

// RefType

// optional string typename = 1;
inline bool RefType::has_typename_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RefType::set_has_typename_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RefType::clear_has_typename_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RefType::clear_typename_() {
  if (typename__ != &::google::protobuf::internal::kEmptyString) {
    typename__->clear();
  }
  clear_has_typename_();
}
inline const ::std::string& RefType::typename_() const {
  return *typename__;
}
inline void RefType::set_typename_(const ::std::string& value) {
  set_has_typename_();
  if (typename__ == &::google::protobuf::internal::kEmptyString) {
    typename__ = new ::std::string;
  }
  typename__->assign(value);
}
inline void RefType::set_typename_(const char* value) {
  set_has_typename_();
  if (typename__ == &::google::protobuf::internal::kEmptyString) {
    typename__ = new ::std::string;
  }
  typename__->assign(value);
}
inline void RefType::set_typename_(const char* value, size_t size) {
  set_has_typename_();
  if (typename__ == &::google::protobuf::internal::kEmptyString) {
    typename__ = new ::std::string;
  }
  typename__->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefType::mutable_typename_() {
  set_has_typename_();
  if (typename__ == &::google::protobuf::internal::kEmptyString) {
    typename__ = new ::std::string;
  }
  return typename__;
}
inline ::std::string* RefType::release_typename_() {
  clear_has_typename_();
  if (typename__ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = typename__;
    typename__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RefType::set_allocated_typename_(::std::string* typename_) {
  if (typename__ != &::google::protobuf::internal::kEmptyString) {
    delete typename__;
  }
  if (typename_) {
    set_has_typename_();
    typename__ = typename_;
  } else {
    clear_has_typename_();
    typename__ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool RefType::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RefType::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RefType::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RefType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RefType::name() const {
  return *name_;
}
inline void RefType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RefType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RefType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RefType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RefType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RefType::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Case

// optional .generated.proto.expr.Expr expr = 1;
inline bool Case::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Case::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Case::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Case::clear_expr() {
  if (expr_ != NULL) expr_->::generated::proto::expr::Expr::Clear();
  clear_has_expr();
}
inline const ::generated::proto::expr::Expr& Case::expr() const {
  return expr_ != NULL ? *expr_ : *default_instance_->expr_;
}
inline ::generated::proto::expr::Expr* Case::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) expr_ = new ::generated::proto::expr::Expr;
  return expr_;
}
inline ::generated::proto::expr::Expr* Case::release_expr() {
  clear_has_expr();
  ::generated::proto::expr::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline void Case::set_allocated_expr(::generated::proto::expr::Expr* expr) {
  delete expr_;
  expr_ = expr;
  if (expr) {
    set_has_expr();
  } else {
    clear_has_expr();
  }
}

// repeated .generated.proto.expr.Expr match = 2;
inline int Case::match_size() const {
  return match_.size();
}
inline void Case::clear_match() {
  match_.Clear();
}
inline const ::generated::proto::expr::Expr& Case::match(int index) const {
  return match_.Get(index);
}
inline ::generated::proto::expr::Expr* Case::mutable_match(int index) {
  return match_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Case::add_match() {
  return match_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Case::match() const {
  return match_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Case::mutable_match() {
  return &match_;
}

// -------------------------------------------------------------------

// Match

// optional .generated.proto.pat.Pat pat = 1;
inline bool Match::has_pat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Match::set_has_pat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Match::clear_has_pat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Match::clear_pat() {
  if (pat_ != NULL) pat_->::generated::proto::pat::Pat::Clear();
  clear_has_pat();
}
inline const ::generated::proto::pat::Pat& Match::pat() const {
  return pat_ != NULL ? *pat_ : *default_instance_->pat_;
}
inline ::generated::proto::pat::Pat* Match::mutable_pat() {
  set_has_pat();
  if (pat_ == NULL) pat_ = new ::generated::proto::pat::Pat;
  return pat_;
}
inline ::generated::proto::pat::Pat* Match::release_pat() {
  clear_has_pat();
  ::generated::proto::pat::Pat* temp = pat_;
  pat_ = NULL;
  return temp;
}
inline void Match::set_allocated_pat(::generated::proto::pat::Pat* pat) {
  delete pat_;
  pat_ = pat;
  if (pat) {
    set_has_pat();
  } else {
    clear_has_pat();
  }
}

// repeated .generated.proto.expr.Expr body = 2;
inline int Match::body_size() const {
  return body_.size();
}
inline void Match::clear_body() {
  body_.Clear();
}
inline const ::generated::proto::expr::Expr& Match::body(int index) const {
  return body_.Get(index);
}
inline ::generated::proto::expr::Expr* Match::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::generated::proto::expr::Expr* Match::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >&
Match::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::generated::proto::expr::Expr >*
Match::mutable_body() {
  return &body_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace expr
}  // namespace proto
}  // namespace generated

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::generated::proto::expr::Expr_Cls>() {
  return ::generated::proto::expr::Expr_Cls_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_expr_2eproto__INCLUDED
