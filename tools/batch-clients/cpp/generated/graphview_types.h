/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef graphview_TYPES_H
#define graphview_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "graph_types.h"


namespace flowbox { namespace batch { namespace graph {

typedef std::vector<int32_t>  PortDescriptor;

typedef struct _EdgeView__isset {
  _EdgeView__isset() : srcNode(false), dstNode(false), srcPort(false), dstPort(false) {}
  bool srcNode;
  bool dstNode;
  bool srcPort;
  bool dstPort;
} _EdgeView__isset;

class EdgeView {
 public:

  static const char* ascii_fingerprint; // = "A8C2A7C113E82F9E83C944457CEF1050";
  static const uint8_t binary_fingerprint[16]; // = {0xA8,0xC2,0xA7,0xC1,0x13,0xE8,0x2F,0x9E,0x83,0xC9,0x44,0x45,0x7C,0xEF,0x10,0x50};

  EdgeView() : srcNode(0), dstNode(0), dstPort(0) {
  }

  virtual ~EdgeView() throw() {}

   ::flowbox::batch::graph::NodeID srcNode;
   ::flowbox::batch::graph::NodeID dstNode;
  PortDescriptor srcPort;
  int32_t dstPort;

  _EdgeView__isset __isset;

  void __set_srcNode(const  ::flowbox::batch::graph::NodeID val) {
    srcNode = val;
    __isset.srcNode = true;
  }

  void __set_dstNode(const  ::flowbox::batch::graph::NodeID val) {
    dstNode = val;
    __isset.dstNode = true;
  }

  void __set_srcPort(const PortDescriptor& val) {
    srcPort = val;
    __isset.srcPort = true;
  }

  void __set_dstPort(const int32_t val) {
    dstPort = val;
    __isset.dstPort = true;
  }

  bool operator == (const EdgeView & rhs) const
  {
    if (__isset.srcNode != rhs.__isset.srcNode)
      return false;
    else if (__isset.srcNode && !(srcNode == rhs.srcNode))
      return false;
    if (__isset.dstNode != rhs.__isset.dstNode)
      return false;
    else if (__isset.dstNode && !(dstNode == rhs.dstNode))
      return false;
    if (__isset.srcPort != rhs.__isset.srcPort)
      return false;
    else if (__isset.srcPort && !(srcPort == rhs.srcPort))
      return false;
    if (__isset.dstPort != rhs.__isset.dstPort)
      return false;
    else if (__isset.dstPort && !(dstPort == rhs.dstPort))
      return false;
    return true;
  }
  bool operator != (const EdgeView &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EdgeView & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(EdgeView &a, EdgeView &b);

typedef struct _GraphView__isset {
  _GraphView__isset() : nodes(false), edges(false) {}
  bool nodes;
  bool edges;
} _GraphView__isset;

class GraphView {
 public:

  static const char* ascii_fingerprint; // = "858C6E7D8E0007C97144342852E2D151";
  static const uint8_t binary_fingerprint[16]; // = {0x85,0x8C,0x6E,0x7D,0x8E,0x00,0x07,0xC9,0x71,0x44,0x34,0x28,0x52,0xE2,0xD1,0x51};

  GraphView() {
  }

  virtual ~GraphView() throw() {}

  std::map< ::flowbox::batch::graph::NodeID,  ::flowbox::batch::graph::Node>  nodes;
  std::vector<EdgeView>  edges;

  _GraphView__isset __isset;

  void __set_nodes(const std::map< ::flowbox::batch::graph::NodeID,  ::flowbox::batch::graph::Node> & val) {
    nodes = val;
    __isset.nodes = true;
  }

  void __set_edges(const std::vector<EdgeView> & val) {
    edges = val;
    __isset.edges = true;
  }

  bool operator == (const GraphView & rhs) const
  {
    if (__isset.nodes != rhs.__isset.nodes)
      return false;
    else if (__isset.nodes && !(nodes == rhs.nodes))
      return false;
    if (__isset.edges != rhs.__isset.edges)
      return false;
    else if (__isset.edges && !(edges == rhs.edges))
      return false;
    return true;
  }
  bool operator != (const GraphView &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GraphView & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(GraphView &a, GraphView &b);

}}} // namespace

#endif
