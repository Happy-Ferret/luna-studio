/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Batch_H
#define Batch_H

#include <thrift/TDispatchProcessor.h>
#include "batch_types.h"

namespace flowbox { namespace batch {

class BatchIf {
 public:
  virtual ~BatchIf() {}
  virtual void projects(std::vector< ::flowbox::batch::projects::Project> & _return) = 0;
  virtual void projectByID( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void createProject( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::Project& project) = 0;
  virtual void openProject( ::flowbox::batch::projects::Project& _return, const std::string& path) = 0;
  virtual void updateProject(const  ::flowbox::batch::projects::Project& project) = 0;
  virtual void closeProject(const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void storeProject(const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void libraries(std::vector< ::flowbox::batch::libs::Library> & _return, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void libraryByID( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::LibID libraryID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void createLibrary( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::Library& library, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void loadLibrary( ::flowbox::batch::libs::Library& _return, const std::string& path, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void unloadLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void storeLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void buildLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void runLibrary(std::string& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void libraryRootDef( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void defsGraph( ::flowbox::batch::defs::DefsGraph& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void defByID( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void addDefinition( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void updateDefinition(const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void removeDefinition(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void definitionChildren(std::vector< ::flowbox::batch::defs::Definition> & _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void definitionParent( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void resolveDefinition(std::vector< ::flowbox::batch::defs::DefPtr> & _return, const std::string& name, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void newTypeModule( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector< ::flowbox::batch::types::Type> & fields) = 0;
  virtual void newTypeClass( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector<std::string> & params, const std::vector< ::flowbox::batch::types::Type> & fields) = 0;
  virtual void newTypeFunction( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& inputs, const  ::flowbox::batch::types::Type& outputs) = 0;
  virtual void newTypeUdefined( ::flowbox::batch::types::Type& _return) = 0;
  virtual void newTypeNamed( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& type) = 0;
  virtual void newTypeName( ::flowbox::batch::types::Type& _return, const std::string& name) = 0;
  virtual void newTypeTuple( ::flowbox::batch::types::Type& _return, const std::vector< ::flowbox::batch::types::Type> & types) = 0;
  virtual void nodesGraph( ::flowbox::batch::graph::GraphView& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void nodeByID( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void addNode( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void updateNode(const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void removeNode(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void connect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void disconnect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void nodeDefaults(std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void setNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::DefaultValue& value, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void removeNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) = 0;
  virtual void FS_ls(std::vector< ::flowbox::batch::fs::FSItem> & _return, const std::string& path) = 0;
  virtual void FS_stat( ::flowbox::batch::fs::FSItem& _return, const std::string& path) = 0;
  virtual void FS_mkdir(const std::string& path) = 0;
  virtual void FS_touch(const std::string& path) = 0;
  virtual void FS_rm(const std::string& path) = 0;
  virtual void FS_cp(const std::string& src, const std::string& dst) = 0;
  virtual void FS_mv(const std::string& src, const std::string& dst) = 0;
  virtual void initialize() = 0;
  virtual void ping() = 0;
  virtual void dump() = 0;
  virtual void shutdown() = 0;
};

class BatchIfFactory {
 public:
  typedef BatchIf Handler;

  virtual ~BatchIfFactory() {}

  virtual BatchIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(BatchIf* /* handler */) = 0;
};

class BatchIfSingletonFactory : virtual public BatchIfFactory {
 public:
  BatchIfSingletonFactory(const boost::shared_ptr<BatchIf>& iface) : iface_(iface) {}
  virtual ~BatchIfSingletonFactory() {}

  virtual BatchIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(BatchIf* /* handler */) {}

 protected:
  boost::shared_ptr<BatchIf> iface_;
};

class BatchNull : virtual public BatchIf {
 public:
  virtual ~BatchNull() {}
  void projects(std::vector< ::flowbox::batch::projects::Project> & /* _return */) {
    return;
  }
  void projectByID( ::flowbox::batch::projects::Project& /* _return */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void createProject( ::flowbox::batch::projects::Project& /* _return */, const  ::flowbox::batch::projects::Project& /* project */) {
    return;
  }
  void openProject( ::flowbox::batch::projects::Project& /* _return */, const std::string& /* path */) {
    return;
  }
  void updateProject(const  ::flowbox::batch::projects::Project& /* project */) {
    return;
  }
  void closeProject(const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void storeProject(const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void libraries(std::vector< ::flowbox::batch::libs::Library> & /* _return */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void libraryByID( ::flowbox::batch::libs::Library& /* _return */, const  ::flowbox::batch::libs::LibID /* libraryID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void createLibrary( ::flowbox::batch::libs::Library& /* _return */, const  ::flowbox::batch::libs::Library& /* library */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void loadLibrary( ::flowbox::batch::libs::Library& /* _return */, const std::string& /* path */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void unloadLibrary(const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void storeLibrary(const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void buildLibrary(const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void runLibrary(std::string& /* _return */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void libraryRootDef( ::flowbox::batch::defs::Definition& /* _return */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void defsGraph( ::flowbox::batch::defs::DefsGraph& /* _return */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void defByID( ::flowbox::batch::defs::Definition& /* _return */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void addDefinition( ::flowbox::batch::defs::Definition& /* _return */, const  ::flowbox::batch::defs::Definition& /* definition */, const  ::flowbox::batch::defs::DefID /* parentID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void updateDefinition(const  ::flowbox::batch::defs::Definition& /* definition */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void removeDefinition(const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void definitionChildren(std::vector< ::flowbox::batch::defs::Definition> & /* _return */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void definitionParent( ::flowbox::batch::defs::Definition& /* _return */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void resolveDefinition(std::vector< ::flowbox::batch::defs::DefPtr> & /* _return */, const std::string& /* name */, const  ::flowbox::batch::defs::DefID /* parentID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void newTypeModule( ::flowbox::batch::types::Type& /* _return */, const std::string& /* name */, const std::vector< ::flowbox::batch::types::Type> & /* fields */) {
    return;
  }
  void newTypeClass( ::flowbox::batch::types::Type& /* _return */, const std::string& /* name */, const std::vector<std::string> & /* params */, const std::vector< ::flowbox::batch::types::Type> & /* fields */) {
    return;
  }
  void newTypeFunction( ::flowbox::batch::types::Type& /* _return */, const std::string& /* name */, const  ::flowbox::batch::types::Type& /* inputs */, const  ::flowbox::batch::types::Type& /* outputs */) {
    return;
  }
  void newTypeUdefined( ::flowbox::batch::types::Type& /* _return */) {
    return;
  }
  void newTypeNamed( ::flowbox::batch::types::Type& /* _return */, const std::string& /* name */, const  ::flowbox::batch::types::Type& /* type */) {
    return;
  }
  void newTypeName( ::flowbox::batch::types::Type& /* _return */, const std::string& /* name */) {
    return;
  }
  void newTypeTuple( ::flowbox::batch::types::Type& /* _return */, const std::vector< ::flowbox::batch::types::Type> & /* types */) {
    return;
  }
  void nodesGraph( ::flowbox::batch::graph::GraphView& /* _return */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void nodeByID( ::flowbox::batch::graph::Node& /* _return */, const  ::flowbox::batch::graph::NodeID /* nodeID */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void addNode( ::flowbox::batch::graph::Node& /* _return */, const  ::flowbox::batch::graph::Node& /* node */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void updateNode(const  ::flowbox::batch::graph::Node& /* node */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void removeNode(const  ::flowbox::batch::graph::NodeID /* nodeID */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void connect(const  ::flowbox::batch::graph::NodeID /* srcNodeID */, const  ::flowbox::batch::graph::PortDescriptor& /* srcPort */, const  ::flowbox::batch::graph::NodeID /* dstNodeID */, const  ::flowbox::batch::graph::PortDescriptor& /* dstPort */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void disconnect(const  ::flowbox::batch::graph::NodeID /* srcNodeID */, const  ::flowbox::batch::graph::PortDescriptor& /* srcPort */, const  ::flowbox::batch::graph::NodeID /* dstNodeID */, const  ::flowbox::batch::graph::PortDescriptor& /* dstPort */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void nodeDefaults(std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & /* _return */, const  ::flowbox::batch::graph::NodeID /* nodeID */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void setNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& /* dst */, const  ::flowbox::batch::graph::DefaultValue& /* value */, const  ::flowbox::batch::graph::NodeID /* nodeID */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void removeNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& /* dst */, const  ::flowbox::batch::graph::NodeID /* nodeID */, const  ::flowbox::batch::defs::DefID /* defID */, const  ::flowbox::batch::libs::LibID /* libID */, const  ::flowbox::batch::projects::ProjectID /* projectID */) {
    return;
  }
  void FS_ls(std::vector< ::flowbox::batch::fs::FSItem> & /* _return */, const std::string& /* path */) {
    return;
  }
  void FS_stat( ::flowbox::batch::fs::FSItem& /* _return */, const std::string& /* path */) {
    return;
  }
  void FS_mkdir(const std::string& /* path */) {
    return;
  }
  void FS_touch(const std::string& /* path */) {
    return;
  }
  void FS_rm(const std::string& /* path */) {
    return;
  }
  void FS_cp(const std::string& /* src */, const std::string& /* dst */) {
    return;
  }
  void FS_mv(const std::string& /* src */, const std::string& /* dst */) {
    return;
  }
  void initialize() {
    return;
  }
  void ping() {
    return;
  }
  void dump() {
    return;
  }
  void shutdown() {
    return;
  }
};


class Batch_projects_args {
 public:

  Batch_projects_args() {
  }

  virtual ~Batch_projects_args() throw() {}


  bool operator == (const Batch_projects_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_projects_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_projects_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_projects_pargs {
 public:


  virtual ~Batch_projects_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_projects_result__isset {
  _Batch_projects_result__isset() : success(false) {}
  bool success;
} _Batch_projects_result__isset;

class Batch_projects_result {
 public:

  Batch_projects_result() {
  }

  virtual ~Batch_projects_result() throw() {}

  std::vector< ::flowbox::batch::projects::Project>  success;

  _Batch_projects_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::projects::Project> & val) {
    success = val;
  }

  bool operator == (const Batch_projects_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Batch_projects_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_projects_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_projects_presult__isset {
  _Batch_projects_presult__isset() : success(false) {}
  bool success;
} _Batch_projects_presult__isset;

class Batch_projects_presult {
 public:


  virtual ~Batch_projects_presult() throw() {}

  std::vector< ::flowbox::batch::projects::Project> * success;

  _Batch_projects_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_projectByID_args__isset {
  _Batch_projectByID_args__isset() : projectID(false) {}
  bool projectID;
} _Batch_projectByID_args__isset;

class Batch_projectByID_args {
 public:

  Batch_projectByID_args() : projectID(0) {
  }

  virtual ~Batch_projectByID_args() throw() {}

   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_projectByID_args__isset __isset;

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_projectByID_args & rhs) const
  {
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_projectByID_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_projectByID_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_projectByID_pargs {
 public:


  virtual ~Batch_projectByID_pargs() throw() {}

  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_projectByID_result__isset {
  _Batch_projectByID_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_projectByID_result__isset;

class Batch_projectByID_result {
 public:

  Batch_projectByID_result() {
  }

  virtual ~Batch_projectByID_result() throw() {}

   ::flowbox::batch::projects::Project success;
  ArgumentException missingFields;

  _Batch_projectByID_result__isset __isset;

  void __set_success(const  ::flowbox::batch::projects::Project& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_projectByID_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_projectByID_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_projectByID_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_projectByID_presult__isset {
  _Batch_projectByID_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_projectByID_presult__isset;

class Batch_projectByID_presult {
 public:


  virtual ~Batch_projectByID_presult() throw() {}

   ::flowbox::batch::projects::Project* success;
  ArgumentException missingFields;

  _Batch_projectByID_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_createProject_args__isset {
  _Batch_createProject_args__isset() : project(false) {}
  bool project;
} _Batch_createProject_args__isset;

class Batch_createProject_args {
 public:

  Batch_createProject_args() {
  }

  virtual ~Batch_createProject_args() throw() {}

   ::flowbox::batch::projects::Project project;

  _Batch_createProject_args__isset __isset;

  void __set_project(const  ::flowbox::batch::projects::Project& val) {
    project = val;
  }

  bool operator == (const Batch_createProject_args & rhs) const
  {
    if (!(project == rhs.project))
      return false;
    return true;
  }
  bool operator != (const Batch_createProject_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createProject_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_createProject_pargs {
 public:


  virtual ~Batch_createProject_pargs() throw() {}

  const  ::flowbox::batch::projects::Project* project;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createProject_result__isset {
  _Batch_createProject_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createProject_result__isset;

class Batch_createProject_result {
 public:

  Batch_createProject_result() {
  }

  virtual ~Batch_createProject_result() throw() {}

   ::flowbox::batch::projects::Project success;
  ArgumentException missingFields;

  _Batch_createProject_result__isset __isset;

  void __set_success(const  ::flowbox::batch::projects::Project& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_createProject_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_createProject_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createProject_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createProject_presult__isset {
  _Batch_createProject_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createProject_presult__isset;

class Batch_createProject_presult {
 public:


  virtual ~Batch_createProject_presult() throw() {}

   ::flowbox::batch::projects::Project* success;
  ArgumentException missingFields;

  _Batch_createProject_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_openProject_args__isset {
  _Batch_openProject_args__isset() : path(false) {}
  bool path;
} _Batch_openProject_args__isset;

class Batch_openProject_args {
 public:

  Batch_openProject_args() : path() {
  }

  virtual ~Batch_openProject_args() throw() {}

  std::string path;

  _Batch_openProject_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_openProject_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_openProject_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_openProject_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_openProject_pargs {
 public:


  virtual ~Batch_openProject_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_openProject_result__isset {
  _Batch_openProject_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_openProject_result__isset;

class Batch_openProject_result {
 public:

  Batch_openProject_result() {
  }

  virtual ~Batch_openProject_result() throw() {}

   ::flowbox::batch::projects::Project success;
  ArgumentException missingFields;

  _Batch_openProject_result__isset __isset;

  void __set_success(const  ::flowbox::batch::projects::Project& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_openProject_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_openProject_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_openProject_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_openProject_presult__isset {
  _Batch_openProject_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_openProject_presult__isset;

class Batch_openProject_presult {
 public:


  virtual ~Batch_openProject_presult() throw() {}

   ::flowbox::batch::projects::Project* success;
  ArgumentException missingFields;

  _Batch_openProject_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_updateProject_args__isset {
  _Batch_updateProject_args__isset() : project(false) {}
  bool project;
} _Batch_updateProject_args__isset;

class Batch_updateProject_args {
 public:

  Batch_updateProject_args() {
  }

  virtual ~Batch_updateProject_args() throw() {}

   ::flowbox::batch::projects::Project project;

  _Batch_updateProject_args__isset __isset;

  void __set_project(const  ::flowbox::batch::projects::Project& val) {
    project = val;
  }

  bool operator == (const Batch_updateProject_args & rhs) const
  {
    if (!(project == rhs.project))
      return false;
    return true;
  }
  bool operator != (const Batch_updateProject_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateProject_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_updateProject_pargs {
 public:


  virtual ~Batch_updateProject_pargs() throw() {}

  const  ::flowbox::batch::projects::Project* project;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateProject_result__isset {
  _Batch_updateProject_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateProject_result__isset;

class Batch_updateProject_result {
 public:

  Batch_updateProject_result() {
  }

  virtual ~Batch_updateProject_result() throw() {}

  ArgumentException missingFields;

  _Batch_updateProject_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_updateProject_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_updateProject_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateProject_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateProject_presult__isset {
  _Batch_updateProject_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateProject_presult__isset;

class Batch_updateProject_presult {
 public:


  virtual ~Batch_updateProject_presult() throw() {}

  ArgumentException missingFields;

  _Batch_updateProject_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_closeProject_args__isset {
  _Batch_closeProject_args__isset() : projectID(false) {}
  bool projectID;
} _Batch_closeProject_args__isset;

class Batch_closeProject_args {
 public:

  Batch_closeProject_args() : projectID(0) {
  }

  virtual ~Batch_closeProject_args() throw() {}

   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_closeProject_args__isset __isset;

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_closeProject_args & rhs) const
  {
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_closeProject_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_closeProject_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_closeProject_pargs {
 public:


  virtual ~Batch_closeProject_pargs() throw() {}

  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_closeProject_result__isset {
  _Batch_closeProject_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_closeProject_result__isset;

class Batch_closeProject_result {
 public:

  Batch_closeProject_result() {
  }

  virtual ~Batch_closeProject_result() throw() {}

  ArgumentException missingFields;

  _Batch_closeProject_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_closeProject_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_closeProject_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_closeProject_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_closeProject_presult__isset {
  _Batch_closeProject_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_closeProject_presult__isset;

class Batch_closeProject_presult {
 public:


  virtual ~Batch_closeProject_presult() throw() {}

  ArgumentException missingFields;

  _Batch_closeProject_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_storeProject_args__isset {
  _Batch_storeProject_args__isset() : projectID(false) {}
  bool projectID;
} _Batch_storeProject_args__isset;

class Batch_storeProject_args {
 public:

  Batch_storeProject_args() : projectID(0) {
  }

  virtual ~Batch_storeProject_args() throw() {}

   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_storeProject_args__isset __isset;

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_storeProject_args & rhs) const
  {
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_storeProject_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeProject_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_storeProject_pargs {
 public:


  virtual ~Batch_storeProject_pargs() throw() {}

  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeProject_result__isset {
  _Batch_storeProject_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeProject_result__isset;

class Batch_storeProject_result {
 public:

  Batch_storeProject_result() {
  }

  virtual ~Batch_storeProject_result() throw() {}

  ArgumentException missingFields;

  _Batch_storeProject_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_storeProject_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_storeProject_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeProject_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeProject_presult__isset {
  _Batch_storeProject_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeProject_presult__isset;

class Batch_storeProject_presult {
 public:


  virtual ~Batch_storeProject_presult() throw() {}

  ArgumentException missingFields;

  _Batch_storeProject_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_libraries_args__isset {
  _Batch_libraries_args__isset() : projectID(false) {}
  bool projectID;
} _Batch_libraries_args__isset;

class Batch_libraries_args {
 public:

  Batch_libraries_args() : projectID(0) {
  }

  virtual ~Batch_libraries_args() throw() {}

   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_libraries_args__isset __isset;

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_libraries_args & rhs) const
  {
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_libraries_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraries_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_libraries_pargs {
 public:


  virtual ~Batch_libraries_pargs() throw() {}

  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraries_result__isset {
  _Batch_libraries_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraries_result__isset;

class Batch_libraries_result {
 public:

  Batch_libraries_result() {
  }

  virtual ~Batch_libraries_result() throw() {}

  std::vector< ::flowbox::batch::libs::Library>  success;
  ArgumentException missingFields;

  _Batch_libraries_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::libs::Library> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_libraries_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_libraries_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraries_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraries_presult__isset {
  _Batch_libraries_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraries_presult__isset;

class Batch_libraries_presult {
 public:


  virtual ~Batch_libraries_presult() throw() {}

  std::vector< ::flowbox::batch::libs::Library> * success;
  ArgumentException missingFields;

  _Batch_libraries_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_libraryByID_args__isset {
  _Batch_libraryByID_args__isset() : libraryID(false), projectID(false) {}
  bool libraryID;
  bool projectID;
} _Batch_libraryByID_args__isset;

class Batch_libraryByID_args {
 public:

  Batch_libraryByID_args() : libraryID(0), projectID(0) {
  }

  virtual ~Batch_libraryByID_args() throw() {}

   ::flowbox::batch::libs::LibID libraryID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_libraryByID_args__isset __isset;

  void __set_libraryID(const  ::flowbox::batch::libs::LibID val) {
    libraryID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_libraryByID_args & rhs) const
  {
    if (!(libraryID == rhs.libraryID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryByID_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryByID_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_libraryByID_pargs {
 public:


  virtual ~Batch_libraryByID_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libraryID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryByID_result__isset {
  _Batch_libraryByID_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryByID_result__isset;

class Batch_libraryByID_result {
 public:

  Batch_libraryByID_result() {
  }

  virtual ~Batch_libraryByID_result() throw() {}

   ::flowbox::batch::libs::Library success;
  ArgumentException missingFields;

  _Batch_libraryByID_result__isset __isset;

  void __set_success(const  ::flowbox::batch::libs::Library& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_libraryByID_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryByID_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryByID_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryByID_presult__isset {
  _Batch_libraryByID_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryByID_presult__isset;

class Batch_libraryByID_presult {
 public:


  virtual ~Batch_libraryByID_presult() throw() {}

   ::flowbox::batch::libs::Library* success;
  ArgumentException missingFields;

  _Batch_libraryByID_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_createLibrary_args__isset {
  _Batch_createLibrary_args__isset() : library(false), projectID(false) {}
  bool library;
  bool projectID;
} _Batch_createLibrary_args__isset;

class Batch_createLibrary_args {
 public:

  Batch_createLibrary_args() : projectID(0) {
  }

  virtual ~Batch_createLibrary_args() throw() {}

   ::flowbox::batch::libs::Library library;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_createLibrary_args__isset __isset;

  void __set_library(const  ::flowbox::batch::libs::Library& val) {
    library = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_createLibrary_args & rhs) const
  {
    if (!(library == rhs.library))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_createLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_createLibrary_pargs {
 public:


  virtual ~Batch_createLibrary_pargs() throw() {}

  const  ::flowbox::batch::libs::Library* library;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createLibrary_result__isset {
  _Batch_createLibrary_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createLibrary_result__isset;

class Batch_createLibrary_result {
 public:

  Batch_createLibrary_result() {
  }

  virtual ~Batch_createLibrary_result() throw() {}

   ::flowbox::batch::libs::Library success;
  ArgumentException missingFields;

  _Batch_createLibrary_result__isset __isset;

  void __set_success(const  ::flowbox::batch::libs::Library& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_createLibrary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_createLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_createLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_createLibrary_presult__isset {
  _Batch_createLibrary_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_createLibrary_presult__isset;

class Batch_createLibrary_presult {
 public:


  virtual ~Batch_createLibrary_presult() throw() {}

   ::flowbox::batch::libs::Library* success;
  ArgumentException missingFields;

  _Batch_createLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_loadLibrary_args__isset {
  _Batch_loadLibrary_args__isset() : path(false), projectID(false) {}
  bool path;
  bool projectID;
} _Batch_loadLibrary_args__isset;

class Batch_loadLibrary_args {
 public:

  Batch_loadLibrary_args() : path(), projectID(0) {
  }

  virtual ~Batch_loadLibrary_args() throw() {}

  std::string path;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_loadLibrary_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_loadLibrary_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_loadLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_loadLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_loadLibrary_pargs {
 public:


  virtual ~Batch_loadLibrary_pargs() throw() {}

  const std::string* path;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_loadLibrary_result__isset {
  _Batch_loadLibrary_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_loadLibrary_result__isset;

class Batch_loadLibrary_result {
 public:

  Batch_loadLibrary_result() {
  }

  virtual ~Batch_loadLibrary_result() throw() {}

   ::flowbox::batch::libs::Library success;
  ArgumentException missingFields;

  _Batch_loadLibrary_result__isset __isset;

  void __set_success(const  ::flowbox::batch::libs::Library& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_loadLibrary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_loadLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_loadLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_loadLibrary_presult__isset {
  _Batch_loadLibrary_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_loadLibrary_presult__isset;

class Batch_loadLibrary_presult {
 public:


  virtual ~Batch_loadLibrary_presult() throw() {}

   ::flowbox::batch::libs::Library* success;
  ArgumentException missingFields;

  _Batch_loadLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_unloadLibrary_args__isset {
  _Batch_unloadLibrary_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_unloadLibrary_args__isset;

class Batch_unloadLibrary_args {
 public:

  Batch_unloadLibrary_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_unloadLibrary_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_unloadLibrary_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_unloadLibrary_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_unloadLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_unloadLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_unloadLibrary_pargs {
 public:


  virtual ~Batch_unloadLibrary_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_unloadLibrary_result__isset {
  _Batch_unloadLibrary_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_unloadLibrary_result__isset;

class Batch_unloadLibrary_result {
 public:

  Batch_unloadLibrary_result() {
  }

  virtual ~Batch_unloadLibrary_result() throw() {}

  ArgumentException missingFields;

  _Batch_unloadLibrary_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_unloadLibrary_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_unloadLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_unloadLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_unloadLibrary_presult__isset {
  _Batch_unloadLibrary_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_unloadLibrary_presult__isset;

class Batch_unloadLibrary_presult {
 public:


  virtual ~Batch_unloadLibrary_presult() throw() {}

  ArgumentException missingFields;

  _Batch_unloadLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_storeLibrary_args__isset {
  _Batch_storeLibrary_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_storeLibrary_args__isset;

class Batch_storeLibrary_args {
 public:

  Batch_storeLibrary_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_storeLibrary_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_storeLibrary_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_storeLibrary_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_storeLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_storeLibrary_pargs {
 public:


  virtual ~Batch_storeLibrary_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeLibrary_result__isset {
  _Batch_storeLibrary_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeLibrary_result__isset;

class Batch_storeLibrary_result {
 public:

  Batch_storeLibrary_result() {
  }

  virtual ~Batch_storeLibrary_result() throw() {}

  ArgumentException missingFields;

  _Batch_storeLibrary_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_storeLibrary_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_storeLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_storeLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_storeLibrary_presult__isset {
  _Batch_storeLibrary_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_storeLibrary_presult__isset;

class Batch_storeLibrary_presult {
 public:


  virtual ~Batch_storeLibrary_presult() throw() {}

  ArgumentException missingFields;

  _Batch_storeLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_buildLibrary_args__isset {
  _Batch_buildLibrary_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_buildLibrary_args__isset;

class Batch_buildLibrary_args {
 public:

  Batch_buildLibrary_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_buildLibrary_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_buildLibrary_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_buildLibrary_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_buildLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_buildLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_buildLibrary_pargs {
 public:


  virtual ~Batch_buildLibrary_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_buildLibrary_result__isset {
  _Batch_buildLibrary_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_buildLibrary_result__isset;

class Batch_buildLibrary_result {
 public:

  Batch_buildLibrary_result() {
  }

  virtual ~Batch_buildLibrary_result() throw() {}

  ArgumentException missingFields;

  _Batch_buildLibrary_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_buildLibrary_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_buildLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_buildLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_buildLibrary_presult__isset {
  _Batch_buildLibrary_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_buildLibrary_presult__isset;

class Batch_buildLibrary_presult {
 public:


  virtual ~Batch_buildLibrary_presult() throw() {}

  ArgumentException missingFields;

  _Batch_buildLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_runLibrary_args__isset {
  _Batch_runLibrary_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_runLibrary_args__isset;

class Batch_runLibrary_args {
 public:

  Batch_runLibrary_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_runLibrary_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_runLibrary_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_runLibrary_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_runLibrary_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_runLibrary_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_runLibrary_pargs {
 public:


  virtual ~Batch_runLibrary_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_runLibrary_result__isset {
  _Batch_runLibrary_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_runLibrary_result__isset;

class Batch_runLibrary_result {
 public:

  Batch_runLibrary_result() : success() {
  }

  virtual ~Batch_runLibrary_result() throw() {}

  std::string success;
  ArgumentException missingFields;

  _Batch_runLibrary_result__isset __isset;

  void __set_success(const std::string& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_runLibrary_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_runLibrary_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_runLibrary_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_runLibrary_presult__isset {
  _Batch_runLibrary_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_runLibrary_presult__isset;

class Batch_runLibrary_presult {
 public:


  virtual ~Batch_runLibrary_presult() throw() {}

  std::string* success;
  ArgumentException missingFields;

  _Batch_runLibrary_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_libraryRootDef_args__isset {
  _Batch_libraryRootDef_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_libraryRootDef_args__isset;

class Batch_libraryRootDef_args {
 public:

  Batch_libraryRootDef_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_libraryRootDef_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_libraryRootDef_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_libraryRootDef_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryRootDef_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryRootDef_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_libraryRootDef_pargs {
 public:


  virtual ~Batch_libraryRootDef_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryRootDef_result__isset {
  _Batch_libraryRootDef_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryRootDef_result__isset;

class Batch_libraryRootDef_result {
 public:

  Batch_libraryRootDef_result() {
  }

  virtual ~Batch_libraryRootDef_result() throw() {}

   ::flowbox::batch::defs::Definition success;
  ArgumentException missingFields;

  _Batch_libraryRootDef_result__isset __isset;

  void __set_success(const  ::flowbox::batch::defs::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_libraryRootDef_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_libraryRootDef_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_libraryRootDef_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_libraryRootDef_presult__isset {
  _Batch_libraryRootDef_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_libraryRootDef_presult__isset;

class Batch_libraryRootDef_presult {
 public:


  virtual ~Batch_libraryRootDef_presult() throw() {}

   ::flowbox::batch::defs::Definition* success;
  ArgumentException missingFields;

  _Batch_libraryRootDef_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_defsGraph_args__isset {
  _Batch_defsGraph_args__isset() : libID(false), projectID(false) {}
  bool libID;
  bool projectID;
} _Batch_defsGraph_args__isset;

class Batch_defsGraph_args {
 public:

  Batch_defsGraph_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_defsGraph_args() throw() {}

   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_defsGraph_args__isset __isset;

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_defsGraph_args & rhs) const
  {
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_defsGraph_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_defsGraph_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_defsGraph_pargs {
 public:


  virtual ~Batch_defsGraph_pargs() throw() {}

  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_defsGraph_result__isset {
  _Batch_defsGraph_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_defsGraph_result__isset;

class Batch_defsGraph_result {
 public:

  Batch_defsGraph_result() {
  }

  virtual ~Batch_defsGraph_result() throw() {}

   ::flowbox::batch::defs::DefsGraph success;
  ArgumentException missingFields;

  _Batch_defsGraph_result__isset __isset;

  void __set_success(const  ::flowbox::batch::defs::DefsGraph& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_defsGraph_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_defsGraph_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_defsGraph_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_defsGraph_presult__isset {
  _Batch_defsGraph_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_defsGraph_presult__isset;

class Batch_defsGraph_presult {
 public:


  virtual ~Batch_defsGraph_presult() throw() {}

   ::flowbox::batch::defs::DefsGraph* success;
  ArgumentException missingFields;

  _Batch_defsGraph_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_defByID_args__isset {
  _Batch_defByID_args__isset() : defID(false), libID(false), projectID(false) {}
  bool defID;
  bool libID;
  bool projectID;
} _Batch_defByID_args__isset;

class Batch_defByID_args {
 public:

  Batch_defByID_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_defByID_args() throw() {}

   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_defByID_args__isset __isset;

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_defByID_args & rhs) const
  {
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_defByID_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_defByID_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_defByID_pargs {
 public:


  virtual ~Batch_defByID_pargs() throw() {}

  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_defByID_result__isset {
  _Batch_defByID_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_defByID_result__isset;

class Batch_defByID_result {
 public:

  Batch_defByID_result() {
  }

  virtual ~Batch_defByID_result() throw() {}

   ::flowbox::batch::defs::Definition success;
  ArgumentException missingFields;

  _Batch_defByID_result__isset __isset;

  void __set_success(const  ::flowbox::batch::defs::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_defByID_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_defByID_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_defByID_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_defByID_presult__isset {
  _Batch_defByID_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_defByID_presult__isset;

class Batch_defByID_presult {
 public:


  virtual ~Batch_defByID_presult() throw() {}

   ::flowbox::batch::defs::Definition* success;
  ArgumentException missingFields;

  _Batch_defByID_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_addDefinition_args__isset {
  _Batch_addDefinition_args__isset() : definition(false), parentID(false), libID(false), projectID(false) {}
  bool definition;
  bool parentID;
  bool libID;
  bool projectID;
} _Batch_addDefinition_args__isset;

class Batch_addDefinition_args {
 public:

  Batch_addDefinition_args() : parentID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_addDefinition_args() throw() {}

   ::flowbox::batch::defs::Definition definition;
   ::flowbox::batch::defs::DefID parentID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_addDefinition_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::defs::Definition& val) {
    definition = val;
  }

  void __set_parentID(const  ::flowbox::batch::defs::DefID val) {
    parentID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_addDefinition_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    if (!(parentID == rhs.parentID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_addDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_addDefinition_pargs {
 public:


  virtual ~Batch_addDefinition_pargs() throw() {}

  const  ::flowbox::batch::defs::Definition* definition;
  const  ::flowbox::batch::defs::DefID* parentID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addDefinition_result__isset {
  _Batch_addDefinition_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addDefinition_result__isset;

class Batch_addDefinition_result {
 public:

  Batch_addDefinition_result() {
  }

  virtual ~Batch_addDefinition_result() throw() {}

   ::flowbox::batch::defs::Definition success;
  ArgumentException missingFields;

  _Batch_addDefinition_result__isset __isset;

  void __set_success(const  ::flowbox::batch::defs::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_addDefinition_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_addDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addDefinition_presult__isset {
  _Batch_addDefinition_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addDefinition_presult__isset;

class Batch_addDefinition_presult {
 public:


  virtual ~Batch_addDefinition_presult() throw() {}

   ::flowbox::batch::defs::Definition* success;
  ArgumentException missingFields;

  _Batch_addDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_updateDefinition_args__isset {
  _Batch_updateDefinition_args__isset() : definition(false), libID(false), projectID(false) {}
  bool definition;
  bool libID;
  bool projectID;
} _Batch_updateDefinition_args__isset;

class Batch_updateDefinition_args {
 public:

  Batch_updateDefinition_args() : libID(0), projectID(0) {
  }

  virtual ~Batch_updateDefinition_args() throw() {}

   ::flowbox::batch::defs::Definition definition;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_updateDefinition_args__isset __isset;

  void __set_definition(const  ::flowbox::batch::defs::Definition& val) {
    definition = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_updateDefinition_args & rhs) const
  {
    if (!(definition == rhs.definition))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_updateDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_updateDefinition_pargs {
 public:


  virtual ~Batch_updateDefinition_pargs() throw() {}

  const  ::flowbox::batch::defs::Definition* definition;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateDefinition_result__isset {
  _Batch_updateDefinition_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateDefinition_result__isset;

class Batch_updateDefinition_result {
 public:

  Batch_updateDefinition_result() {
  }

  virtual ~Batch_updateDefinition_result() throw() {}

  ArgumentException missingFields;

  _Batch_updateDefinition_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_updateDefinition_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_updateDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateDefinition_presult__isset {
  _Batch_updateDefinition_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateDefinition_presult__isset;

class Batch_updateDefinition_presult {
 public:


  virtual ~Batch_updateDefinition_presult() throw() {}

  ArgumentException missingFields;

  _Batch_updateDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_removeDefinition_args__isset {
  _Batch_removeDefinition_args__isset() : defID(false), libID(false), projectID(false) {}
  bool defID;
  bool libID;
  bool projectID;
} _Batch_removeDefinition_args__isset;

class Batch_removeDefinition_args {
 public:

  Batch_removeDefinition_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_removeDefinition_args() throw() {}

   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_removeDefinition_args__isset __isset;

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_removeDefinition_args & rhs) const
  {
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_removeDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_removeDefinition_pargs {
 public:


  virtual ~Batch_removeDefinition_pargs() throw() {}

  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeDefinition_result__isset {
  _Batch_removeDefinition_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeDefinition_result__isset;

class Batch_removeDefinition_result {
 public:

  Batch_removeDefinition_result() {
  }

  virtual ~Batch_removeDefinition_result() throw() {}

  ArgumentException missingFields;

  _Batch_removeDefinition_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_removeDefinition_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_removeDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeDefinition_presult__isset {
  _Batch_removeDefinition_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeDefinition_presult__isset;

class Batch_removeDefinition_presult {
 public:


  virtual ~Batch_removeDefinition_presult() throw() {}

  ArgumentException missingFields;

  _Batch_removeDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_definitionChildren_args__isset {
  _Batch_definitionChildren_args__isset() : defID(false), libID(false), projectID(false) {}
  bool defID;
  bool libID;
  bool projectID;
} _Batch_definitionChildren_args__isset;

class Batch_definitionChildren_args {
 public:

  Batch_definitionChildren_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_definitionChildren_args() throw() {}

   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_definitionChildren_args__isset __isset;

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_definitionChildren_args & rhs) const
  {
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionChildren_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionChildren_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_definitionChildren_pargs {
 public:


  virtual ~Batch_definitionChildren_pargs() throw() {}

  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionChildren_result__isset {
  _Batch_definitionChildren_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionChildren_result__isset;

class Batch_definitionChildren_result {
 public:

  Batch_definitionChildren_result() {
  }

  virtual ~Batch_definitionChildren_result() throw() {}

  std::vector< ::flowbox::batch::defs::Definition>  success;
  ArgumentException missingFields;

  _Batch_definitionChildren_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::defs::Definition> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_definitionChildren_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionChildren_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionChildren_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionChildren_presult__isset {
  _Batch_definitionChildren_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionChildren_presult__isset;

class Batch_definitionChildren_presult {
 public:


  virtual ~Batch_definitionChildren_presult() throw() {}

  std::vector< ::flowbox::batch::defs::Definition> * success;
  ArgumentException missingFields;

  _Batch_definitionChildren_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_definitionParent_args__isset {
  _Batch_definitionParent_args__isset() : defID(false), libID(false), projectID(false) {}
  bool defID;
  bool libID;
  bool projectID;
} _Batch_definitionParent_args__isset;

class Batch_definitionParent_args {
 public:

  Batch_definitionParent_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_definitionParent_args() throw() {}

   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_definitionParent_args__isset __isset;

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_definitionParent_args & rhs) const
  {
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionParent_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionParent_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_definitionParent_pargs {
 public:


  virtual ~Batch_definitionParent_pargs() throw() {}

  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionParent_result__isset {
  _Batch_definitionParent_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionParent_result__isset;

class Batch_definitionParent_result {
 public:

  Batch_definitionParent_result() {
  }

  virtual ~Batch_definitionParent_result() throw() {}

   ::flowbox::batch::defs::Definition success;
  ArgumentException missingFields;

  _Batch_definitionParent_result__isset __isset;

  void __set_success(const  ::flowbox::batch::defs::Definition& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_definitionParent_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_definitionParent_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_definitionParent_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_definitionParent_presult__isset {
  _Batch_definitionParent_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_definitionParent_presult__isset;

class Batch_definitionParent_presult {
 public:


  virtual ~Batch_definitionParent_presult() throw() {}

   ::flowbox::batch::defs::Definition* success;
  ArgumentException missingFields;

  _Batch_definitionParent_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_resolveDefinition_args__isset {
  _Batch_resolveDefinition_args__isset() : name(false), parentID(false), libID(false), projectID(false) {}
  bool name;
  bool parentID;
  bool libID;
  bool projectID;
} _Batch_resolveDefinition_args__isset;

class Batch_resolveDefinition_args {
 public:

  Batch_resolveDefinition_args() : name(), parentID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_resolveDefinition_args() throw() {}

  std::string name;
   ::flowbox::batch::defs::DefID parentID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_resolveDefinition_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_parentID(const  ::flowbox::batch::defs::DefID val) {
    parentID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_resolveDefinition_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(parentID == rhs.parentID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_resolveDefinition_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_resolveDefinition_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_resolveDefinition_pargs {
 public:


  virtual ~Batch_resolveDefinition_pargs() throw() {}

  const std::string* name;
  const  ::flowbox::batch::defs::DefID* parentID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_resolveDefinition_result__isset {
  _Batch_resolveDefinition_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_resolveDefinition_result__isset;

class Batch_resolveDefinition_result {
 public:

  Batch_resolveDefinition_result() {
  }

  virtual ~Batch_resolveDefinition_result() throw() {}

  std::vector< ::flowbox::batch::defs::DefPtr>  success;
  ArgumentException missingFields;

  _Batch_resolveDefinition_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::defs::DefPtr> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_resolveDefinition_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_resolveDefinition_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_resolveDefinition_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_resolveDefinition_presult__isset {
  _Batch_resolveDefinition_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_resolveDefinition_presult__isset;

class Batch_resolveDefinition_presult {
 public:


  virtual ~Batch_resolveDefinition_presult() throw() {}

  std::vector< ::flowbox::batch::defs::DefPtr> * success;
  ArgumentException missingFields;

  _Batch_resolveDefinition_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeModule_args__isset {
  _Batch_newTypeModule_args__isset() : name(false), fields(false) {}
  bool name;
  bool fields;
} _Batch_newTypeModule_args__isset;

class Batch_newTypeModule_args {
 public:

  Batch_newTypeModule_args() : name() {
  }

  virtual ~Batch_newTypeModule_args() throw() {}

  std::string name;
  std::vector< ::flowbox::batch::types::Type>  fields;

  _Batch_newTypeModule_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_fields(const std::vector< ::flowbox::batch::types::Type> & val) {
    fields = val;
  }

  bool operator == (const Batch_newTypeModule_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeModule_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeModule_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeModule_pargs {
 public:


  virtual ~Batch_newTypeModule_pargs() throw() {}

  const std::string* name;
  const std::vector< ::flowbox::batch::types::Type> * fields;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeModule_result__isset {
  _Batch_newTypeModule_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeModule_result__isset;

class Batch_newTypeModule_result {
 public:

  Batch_newTypeModule_result() {
  }

  virtual ~Batch_newTypeModule_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeModule_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeModule_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeModule_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeModule_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeModule_presult__isset {
  _Batch_newTypeModule_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeModule_presult__isset;

class Batch_newTypeModule_presult {
 public:


  virtual ~Batch_newTypeModule_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeModule_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeClass_args__isset {
  _Batch_newTypeClass_args__isset() : name(false), params(false), fields(false) {}
  bool name;
  bool params;
  bool fields;
} _Batch_newTypeClass_args__isset;

class Batch_newTypeClass_args {
 public:

  Batch_newTypeClass_args() : name() {
  }

  virtual ~Batch_newTypeClass_args() throw() {}

  std::string name;
  std::vector<std::string>  params;
  std::vector< ::flowbox::batch::types::Type>  fields;

  _Batch_newTypeClass_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_params(const std::vector<std::string> & val) {
    params = val;
  }

  void __set_fields(const std::vector< ::flowbox::batch::types::Type> & val) {
    fields = val;
  }

  bool operator == (const Batch_newTypeClass_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(params == rhs.params))
      return false;
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeClass_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeClass_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeClass_pargs {
 public:


  virtual ~Batch_newTypeClass_pargs() throw() {}

  const std::string* name;
  const std::vector<std::string> * params;
  const std::vector< ::flowbox::batch::types::Type> * fields;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeClass_result__isset {
  _Batch_newTypeClass_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeClass_result__isset;

class Batch_newTypeClass_result {
 public:

  Batch_newTypeClass_result() {
  }

  virtual ~Batch_newTypeClass_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeClass_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeClass_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeClass_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeClass_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeClass_presult__isset {
  _Batch_newTypeClass_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeClass_presult__isset;

class Batch_newTypeClass_presult {
 public:


  virtual ~Batch_newTypeClass_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeClass_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeFunction_args__isset {
  _Batch_newTypeFunction_args__isset() : name(false), inputs(false), outputs(false) {}
  bool name;
  bool inputs;
  bool outputs;
} _Batch_newTypeFunction_args__isset;

class Batch_newTypeFunction_args {
 public:

  Batch_newTypeFunction_args() : name() {
  }

  virtual ~Batch_newTypeFunction_args() throw() {}

  std::string name;
   ::flowbox::batch::types::Type inputs;
   ::flowbox::batch::types::Type outputs;

  _Batch_newTypeFunction_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_inputs(const  ::flowbox::batch::types::Type& val) {
    inputs = val;
  }

  void __set_outputs(const  ::flowbox::batch::types::Type& val) {
    outputs = val;
  }

  bool operator == (const Batch_newTypeFunction_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(inputs == rhs.inputs))
      return false;
    if (!(outputs == rhs.outputs))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeFunction_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeFunction_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeFunction_pargs {
 public:


  virtual ~Batch_newTypeFunction_pargs() throw() {}

  const std::string* name;
  const  ::flowbox::batch::types::Type* inputs;
  const  ::flowbox::batch::types::Type* outputs;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeFunction_result__isset {
  _Batch_newTypeFunction_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeFunction_result__isset;

class Batch_newTypeFunction_result {
 public:

  Batch_newTypeFunction_result() {
  }

  virtual ~Batch_newTypeFunction_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeFunction_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeFunction_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeFunction_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeFunction_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeFunction_presult__isset {
  _Batch_newTypeFunction_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeFunction_presult__isset;

class Batch_newTypeFunction_presult {
 public:


  virtual ~Batch_newTypeFunction_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeFunction_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_newTypeUdefined_args {
 public:

  Batch_newTypeUdefined_args() {
  }

  virtual ~Batch_newTypeUdefined_args() throw() {}


  bool operator == (const Batch_newTypeUdefined_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_newTypeUdefined_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeUdefined_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeUdefined_pargs {
 public:


  virtual ~Batch_newTypeUdefined_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeUdefined_result__isset {
  _Batch_newTypeUdefined_result__isset() : success(false) {}
  bool success;
} _Batch_newTypeUdefined_result__isset;

class Batch_newTypeUdefined_result {
 public:

  Batch_newTypeUdefined_result() {
  }

  virtual ~Batch_newTypeUdefined_result() throw() {}

   ::flowbox::batch::types::Type success;

  _Batch_newTypeUdefined_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  bool operator == (const Batch_newTypeUdefined_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeUdefined_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeUdefined_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeUdefined_presult__isset {
  _Batch_newTypeUdefined_presult__isset() : success(false) {}
  bool success;
} _Batch_newTypeUdefined_presult__isset;

class Batch_newTypeUdefined_presult {
 public:


  virtual ~Batch_newTypeUdefined_presult() throw() {}

   ::flowbox::batch::types::Type* success;

  _Batch_newTypeUdefined_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeNamed_args__isset {
  _Batch_newTypeNamed_args__isset() : name(false), type(false) {}
  bool name;
  bool type;
} _Batch_newTypeNamed_args__isset;

class Batch_newTypeNamed_args {
 public:

  Batch_newTypeNamed_args() : name() {
  }

  virtual ~Batch_newTypeNamed_args() throw() {}

  std::string name;
   ::flowbox::batch::types::Type type;

  _Batch_newTypeNamed_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  void __set_type(const  ::flowbox::batch::types::Type& val) {
    type = val;
  }

  bool operator == (const Batch_newTypeNamed_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeNamed_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeNamed_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeNamed_pargs {
 public:


  virtual ~Batch_newTypeNamed_pargs() throw() {}

  const std::string* name;
  const  ::flowbox::batch::types::Type* type;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeNamed_result__isset {
  _Batch_newTypeNamed_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeNamed_result__isset;

class Batch_newTypeNamed_result {
 public:

  Batch_newTypeNamed_result() {
  }

  virtual ~Batch_newTypeNamed_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeNamed_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeNamed_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeNamed_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeNamed_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeNamed_presult__isset {
  _Batch_newTypeNamed_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeNamed_presult__isset;

class Batch_newTypeNamed_presult {
 public:


  virtual ~Batch_newTypeNamed_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeNamed_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeName_args__isset {
  _Batch_newTypeName_args__isset() : name(false) {}
  bool name;
} _Batch_newTypeName_args__isset;

class Batch_newTypeName_args {
 public:

  Batch_newTypeName_args() : name() {
  }

  virtual ~Batch_newTypeName_args() throw() {}

  std::string name;

  _Batch_newTypeName_args__isset __isset;

  void __set_name(const std::string& val) {
    name = val;
  }

  bool operator == (const Batch_newTypeName_args & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeName_pargs {
 public:


  virtual ~Batch_newTypeName_pargs() throw() {}

  const std::string* name;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeName_result__isset {
  _Batch_newTypeName_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeName_result__isset;

class Batch_newTypeName_result {
 public:

  Batch_newTypeName_result() {
  }

  virtual ~Batch_newTypeName_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeName_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeName_presult__isset {
  _Batch_newTypeName_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeName_presult__isset;

class Batch_newTypeName_presult {
 public:


  virtual ~Batch_newTypeName_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_newTypeTuple_args__isset {
  _Batch_newTypeTuple_args__isset() : types(false) {}
  bool types;
} _Batch_newTypeTuple_args__isset;

class Batch_newTypeTuple_args {
 public:

  Batch_newTypeTuple_args() {
  }

  virtual ~Batch_newTypeTuple_args() throw() {}

  std::vector< ::flowbox::batch::types::Type>  types;

  _Batch_newTypeTuple_args__isset __isset;

  void __set_types(const std::vector< ::flowbox::batch::types::Type> & val) {
    types = val;
  }

  bool operator == (const Batch_newTypeTuple_args & rhs) const
  {
    if (!(types == rhs.types))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeTuple_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeTuple_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_newTypeTuple_pargs {
 public:


  virtual ~Batch_newTypeTuple_pargs() throw() {}

  const std::vector< ::flowbox::batch::types::Type> * types;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeTuple_result__isset {
  _Batch_newTypeTuple_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeTuple_result__isset;

class Batch_newTypeTuple_result {
 public:

  Batch_newTypeTuple_result() {
  }

  virtual ~Batch_newTypeTuple_result() throw() {}

   ::flowbox::batch::types::Type success;
  ArgumentException missingFields;

  _Batch_newTypeTuple_result__isset __isset;

  void __set_success(const  ::flowbox::batch::types::Type& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_newTypeTuple_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_newTypeTuple_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_newTypeTuple_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_newTypeTuple_presult__isset {
  _Batch_newTypeTuple_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_newTypeTuple_presult__isset;

class Batch_newTypeTuple_presult {
 public:


  virtual ~Batch_newTypeTuple_presult() throw() {}

   ::flowbox::batch::types::Type* success;
  ArgumentException missingFields;

  _Batch_newTypeTuple_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_nodesGraph_args__isset {
  _Batch_nodesGraph_args__isset() : defID(false), libID(false), projectID(false) {}
  bool defID;
  bool libID;
  bool projectID;
} _Batch_nodesGraph_args__isset;

class Batch_nodesGraph_args {
 public:

  Batch_nodesGraph_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_nodesGraph_args() throw() {}

   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_nodesGraph_args__isset __isset;

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_nodesGraph_args & rhs) const
  {
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_nodesGraph_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodesGraph_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_nodesGraph_pargs {
 public:


  virtual ~Batch_nodesGraph_pargs() throw() {}

  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodesGraph_result__isset {
  _Batch_nodesGraph_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodesGraph_result__isset;

class Batch_nodesGraph_result {
 public:

  Batch_nodesGraph_result() {
  }

  virtual ~Batch_nodesGraph_result() throw() {}

   ::flowbox::batch::graph::GraphView success;
  ArgumentException missingFields;

  _Batch_nodesGraph_result__isset __isset;

  void __set_success(const  ::flowbox::batch::graph::GraphView& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_nodesGraph_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_nodesGraph_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodesGraph_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodesGraph_presult__isset {
  _Batch_nodesGraph_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodesGraph_presult__isset;

class Batch_nodesGraph_presult {
 public:


  virtual ~Batch_nodesGraph_presult() throw() {}

   ::flowbox::batch::graph::GraphView* success;
  ArgumentException missingFields;

  _Batch_nodesGraph_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_nodeByID_args__isset {
  _Batch_nodeByID_args__isset() : nodeID(false), defID(false), libID(false), projectID(false) {}
  bool nodeID;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_nodeByID_args__isset;

class Batch_nodeByID_args {
 public:

  Batch_nodeByID_args() : nodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_nodeByID_args() throw() {}

   ::flowbox::batch::graph::NodeID nodeID;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_nodeByID_args__isset __isset;

  void __set_nodeID(const  ::flowbox::batch::graph::NodeID val) {
    nodeID = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_nodeByID_args & rhs) const
  {
    if (!(nodeID == rhs.nodeID))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_nodeByID_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodeByID_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_nodeByID_pargs {
 public:


  virtual ~Batch_nodeByID_pargs() throw() {}

  const  ::flowbox::batch::graph::NodeID* nodeID;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodeByID_result__isset {
  _Batch_nodeByID_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodeByID_result__isset;

class Batch_nodeByID_result {
 public:

  Batch_nodeByID_result() {
  }

  virtual ~Batch_nodeByID_result() throw() {}

   ::flowbox::batch::graph::Node success;
  ArgumentException missingFields;

  _Batch_nodeByID_result__isset __isset;

  void __set_success(const  ::flowbox::batch::graph::Node& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_nodeByID_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_nodeByID_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodeByID_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodeByID_presult__isset {
  _Batch_nodeByID_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodeByID_presult__isset;

class Batch_nodeByID_presult {
 public:


  virtual ~Batch_nodeByID_presult() throw() {}

   ::flowbox::batch::graph::Node* success;
  ArgumentException missingFields;

  _Batch_nodeByID_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_addNode_args__isset {
  _Batch_addNode_args__isset() : node(false), defID(false), libID(false), projectID(false) {}
  bool node;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_addNode_args__isset;

class Batch_addNode_args {
 public:

  Batch_addNode_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_addNode_args() throw() {}

   ::flowbox::batch::graph::Node node;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_addNode_args__isset __isset;

  void __set_node(const  ::flowbox::batch::graph::Node& val) {
    node = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_addNode_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_addNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_addNode_pargs {
 public:


  virtual ~Batch_addNode_pargs() throw() {}

  const  ::flowbox::batch::graph::Node* node;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addNode_result__isset {
  _Batch_addNode_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addNode_result__isset;

class Batch_addNode_result {
 public:

  Batch_addNode_result() {
  }

  virtual ~Batch_addNode_result() throw() {}

   ::flowbox::batch::graph::Node success;
  ArgumentException missingFields;

  _Batch_addNode_result__isset __isset;

  void __set_success(const  ::flowbox::batch::graph::Node& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_addNode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_addNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_addNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_addNode_presult__isset {
  _Batch_addNode_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_addNode_presult__isset;

class Batch_addNode_presult {
 public:


  virtual ~Batch_addNode_presult() throw() {}

   ::flowbox::batch::graph::Node* success;
  ArgumentException missingFields;

  _Batch_addNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_updateNode_args__isset {
  _Batch_updateNode_args__isset() : node(false), defID(false), libID(false), projectID(false) {}
  bool node;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_updateNode_args__isset;

class Batch_updateNode_args {
 public:

  Batch_updateNode_args() : defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_updateNode_args() throw() {}

   ::flowbox::batch::graph::Node node;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_updateNode_args__isset __isset;

  void __set_node(const  ::flowbox::batch::graph::Node& val) {
    node = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_updateNode_args & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_updateNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_updateNode_pargs {
 public:


  virtual ~Batch_updateNode_pargs() throw() {}

  const  ::flowbox::batch::graph::Node* node;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateNode_result__isset {
  _Batch_updateNode_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateNode_result__isset;

class Batch_updateNode_result {
 public:

  Batch_updateNode_result() {
  }

  virtual ~Batch_updateNode_result() throw() {}

  ArgumentException missingFields;

  _Batch_updateNode_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_updateNode_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_updateNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_updateNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_updateNode_presult__isset {
  _Batch_updateNode_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_updateNode_presult__isset;

class Batch_updateNode_presult {
 public:


  virtual ~Batch_updateNode_presult() throw() {}

  ArgumentException missingFields;

  _Batch_updateNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_removeNode_args__isset {
  _Batch_removeNode_args__isset() : nodeID(false), defID(false), libID(false), projectID(false) {}
  bool nodeID;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_removeNode_args__isset;

class Batch_removeNode_args {
 public:

  Batch_removeNode_args() : nodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_removeNode_args() throw() {}

   ::flowbox::batch::graph::NodeID nodeID;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_removeNode_args__isset __isset;

  void __set_nodeID(const  ::flowbox::batch::graph::NodeID val) {
    nodeID = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_removeNode_args & rhs) const
  {
    if (!(nodeID == rhs.nodeID))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_removeNode_pargs {
 public:


  virtual ~Batch_removeNode_pargs() throw() {}

  const  ::flowbox::batch::graph::NodeID* nodeID;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNode_result__isset {
  _Batch_removeNode_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNode_result__isset;

class Batch_removeNode_result {
 public:

  Batch_removeNode_result() {
  }

  virtual ~Batch_removeNode_result() throw() {}

  ArgumentException missingFields;

  _Batch_removeNode_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_removeNode_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNode_presult__isset {
  _Batch_removeNode_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNode_presult__isset;

class Batch_removeNode_presult {
 public:


  virtual ~Batch_removeNode_presult() throw() {}

  ArgumentException missingFields;

  _Batch_removeNode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_connect_args__isset {
  _Batch_connect_args__isset() : srcNodeID(false), srcPort(false), dstNodeID(false), dstPort(false), defID(false), libID(false), projectID(false) {}
  bool srcNodeID;
  bool srcPort;
  bool dstNodeID;
  bool dstPort;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_connect_args__isset;

class Batch_connect_args {
 public:

  Batch_connect_args() : srcNodeID(0), dstNodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_connect_args() throw() {}

   ::flowbox::batch::graph::NodeID srcNodeID;
   ::flowbox::batch::graph::PortDescriptor srcPort;
   ::flowbox::batch::graph::NodeID dstNodeID;
   ::flowbox::batch::graph::PortDescriptor dstPort;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_connect_args__isset __isset;

  void __set_srcNodeID(const  ::flowbox::batch::graph::NodeID val) {
    srcNodeID = val;
  }

  void __set_srcPort(const  ::flowbox::batch::graph::PortDescriptor& val) {
    srcPort = val;
  }

  void __set_dstNodeID(const  ::flowbox::batch::graph::NodeID val) {
    dstNodeID = val;
  }

  void __set_dstPort(const  ::flowbox::batch::graph::PortDescriptor& val) {
    dstPort = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_connect_args & rhs) const
  {
    if (!(srcNodeID == rhs.srcNodeID))
      return false;
    if (!(srcPort == rhs.srcPort))
      return false;
    if (!(dstNodeID == rhs.dstNodeID))
      return false;
    if (!(dstPort == rhs.dstPort))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_connect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_connect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_connect_pargs {
 public:


  virtual ~Batch_connect_pargs() throw() {}

  const  ::flowbox::batch::graph::NodeID* srcNodeID;
  const  ::flowbox::batch::graph::PortDescriptor* srcPort;
  const  ::flowbox::batch::graph::NodeID* dstNodeID;
  const  ::flowbox::batch::graph::PortDescriptor* dstPort;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_connect_result__isset {
  _Batch_connect_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_connect_result__isset;

class Batch_connect_result {
 public:

  Batch_connect_result() {
  }

  virtual ~Batch_connect_result() throw() {}

  ArgumentException missingFields;

  _Batch_connect_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_connect_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_connect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_connect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_connect_presult__isset {
  _Batch_connect_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_connect_presult__isset;

class Batch_connect_presult {
 public:


  virtual ~Batch_connect_presult() throw() {}

  ArgumentException missingFields;

  _Batch_connect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_disconnect_args__isset {
  _Batch_disconnect_args__isset() : srcNodeID(false), srcPort(false), dstNodeID(false), dstPort(false), defID(false), libID(false), projectID(false) {}
  bool srcNodeID;
  bool srcPort;
  bool dstNodeID;
  bool dstPort;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_disconnect_args__isset;

class Batch_disconnect_args {
 public:

  Batch_disconnect_args() : srcNodeID(0), dstNodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_disconnect_args() throw() {}

   ::flowbox::batch::graph::NodeID srcNodeID;
   ::flowbox::batch::graph::PortDescriptor srcPort;
   ::flowbox::batch::graph::NodeID dstNodeID;
   ::flowbox::batch::graph::PortDescriptor dstPort;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_disconnect_args__isset __isset;

  void __set_srcNodeID(const  ::flowbox::batch::graph::NodeID val) {
    srcNodeID = val;
  }

  void __set_srcPort(const  ::flowbox::batch::graph::PortDescriptor& val) {
    srcPort = val;
  }

  void __set_dstNodeID(const  ::flowbox::batch::graph::NodeID val) {
    dstNodeID = val;
  }

  void __set_dstPort(const  ::flowbox::batch::graph::PortDescriptor& val) {
    dstPort = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_disconnect_args & rhs) const
  {
    if (!(srcNodeID == rhs.srcNodeID))
      return false;
    if (!(srcPort == rhs.srcPort))
      return false;
    if (!(dstNodeID == rhs.dstNodeID))
      return false;
    if (!(dstPort == rhs.dstPort))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_disconnect_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_disconnect_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_disconnect_pargs {
 public:


  virtual ~Batch_disconnect_pargs() throw() {}

  const  ::flowbox::batch::graph::NodeID* srcNodeID;
  const  ::flowbox::batch::graph::PortDescriptor* srcPort;
  const  ::flowbox::batch::graph::NodeID* dstNodeID;
  const  ::flowbox::batch::graph::PortDescriptor* dstPort;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_disconnect_result__isset {
  _Batch_disconnect_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_disconnect_result__isset;

class Batch_disconnect_result {
 public:

  Batch_disconnect_result() {
  }

  virtual ~Batch_disconnect_result() throw() {}

  ArgumentException missingFields;

  _Batch_disconnect_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_disconnect_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_disconnect_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_disconnect_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_disconnect_presult__isset {
  _Batch_disconnect_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_disconnect_presult__isset;

class Batch_disconnect_presult {
 public:


  virtual ~Batch_disconnect_presult() throw() {}

  ArgumentException missingFields;

  _Batch_disconnect_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_nodeDefaults_args__isset {
  _Batch_nodeDefaults_args__isset() : nodeID(false), defID(false), libID(false), projectID(false) {}
  bool nodeID;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_nodeDefaults_args__isset;

class Batch_nodeDefaults_args {
 public:

  Batch_nodeDefaults_args() : nodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_nodeDefaults_args() throw() {}

   ::flowbox::batch::graph::NodeID nodeID;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_nodeDefaults_args__isset __isset;

  void __set_nodeID(const  ::flowbox::batch::graph::NodeID val) {
    nodeID = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_nodeDefaults_args & rhs) const
  {
    if (!(nodeID == rhs.nodeID))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_nodeDefaults_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodeDefaults_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_nodeDefaults_pargs {
 public:


  virtual ~Batch_nodeDefaults_pargs() throw() {}

  const  ::flowbox::batch::graph::NodeID* nodeID;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodeDefaults_result__isset {
  _Batch_nodeDefaults_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodeDefaults_result__isset;

class Batch_nodeDefaults_result {
 public:

  Batch_nodeDefaults_result() {
  }

  virtual ~Batch_nodeDefaults_result() throw() {}

  std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue>  success;
  ArgumentException missingFields;

  _Batch_nodeDefaults_result__isset __isset;

  void __set_success(const std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_nodeDefaults_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_nodeDefaults_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_nodeDefaults_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_nodeDefaults_presult__isset {
  _Batch_nodeDefaults_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_nodeDefaults_presult__isset;

class Batch_nodeDefaults_presult {
 public:


  virtual ~Batch_nodeDefaults_presult() throw() {}

  std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> * success;
  ArgumentException missingFields;

  _Batch_nodeDefaults_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_setNodeDefault_args__isset {
  _Batch_setNodeDefault_args__isset() : dst(false), value(false), nodeID(false), defID(false), libID(false), projectID(false) {}
  bool dst;
  bool value;
  bool nodeID;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_setNodeDefault_args__isset;

class Batch_setNodeDefault_args {
 public:

  Batch_setNodeDefault_args() : nodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_setNodeDefault_args() throw() {}

   ::flowbox::batch::graph::PortDescriptor dst;
   ::flowbox::batch::graph::DefaultValue value;
   ::flowbox::batch::graph::NodeID nodeID;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_setNodeDefault_args__isset __isset;

  void __set_dst(const  ::flowbox::batch::graph::PortDescriptor& val) {
    dst = val;
  }

  void __set_value(const  ::flowbox::batch::graph::DefaultValue& val) {
    value = val;
  }

  void __set_nodeID(const  ::flowbox::batch::graph::NodeID val) {
    nodeID = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_setNodeDefault_args & rhs) const
  {
    if (!(dst == rhs.dst))
      return false;
    if (!(value == rhs.value))
      return false;
    if (!(nodeID == rhs.nodeID))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_setNodeDefault_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_setNodeDefault_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_setNodeDefault_pargs {
 public:


  virtual ~Batch_setNodeDefault_pargs() throw() {}

  const  ::flowbox::batch::graph::PortDescriptor* dst;
  const  ::flowbox::batch::graph::DefaultValue* value;
  const  ::flowbox::batch::graph::NodeID* nodeID;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_setNodeDefault_result__isset {
  _Batch_setNodeDefault_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_setNodeDefault_result__isset;

class Batch_setNodeDefault_result {
 public:

  Batch_setNodeDefault_result() {
  }

  virtual ~Batch_setNodeDefault_result() throw() {}

  ArgumentException missingFields;

  _Batch_setNodeDefault_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_setNodeDefault_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_setNodeDefault_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_setNodeDefault_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_setNodeDefault_presult__isset {
  _Batch_setNodeDefault_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_setNodeDefault_presult__isset;

class Batch_setNodeDefault_presult {
 public:


  virtual ~Batch_setNodeDefault_presult() throw() {}

  ArgumentException missingFields;

  _Batch_setNodeDefault_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_removeNodeDefault_args__isset {
  _Batch_removeNodeDefault_args__isset() : dst(false), nodeID(false), defID(false), libID(false), projectID(false) {}
  bool dst;
  bool nodeID;
  bool defID;
  bool libID;
  bool projectID;
} _Batch_removeNodeDefault_args__isset;

class Batch_removeNodeDefault_args {
 public:

  Batch_removeNodeDefault_args() : nodeID(0), defID(0), libID(0), projectID(0) {
  }

  virtual ~Batch_removeNodeDefault_args() throw() {}

   ::flowbox::batch::graph::PortDescriptor dst;
   ::flowbox::batch::graph::NodeID nodeID;
   ::flowbox::batch::defs::DefID defID;
   ::flowbox::batch::libs::LibID libID;
   ::flowbox::batch::projects::ProjectID projectID;

  _Batch_removeNodeDefault_args__isset __isset;

  void __set_dst(const  ::flowbox::batch::graph::PortDescriptor& val) {
    dst = val;
  }

  void __set_nodeID(const  ::flowbox::batch::graph::NodeID val) {
    nodeID = val;
  }

  void __set_defID(const  ::flowbox::batch::defs::DefID val) {
    defID = val;
  }

  void __set_libID(const  ::flowbox::batch::libs::LibID val) {
    libID = val;
  }

  void __set_projectID(const  ::flowbox::batch::projects::ProjectID val) {
    projectID = val;
  }

  bool operator == (const Batch_removeNodeDefault_args & rhs) const
  {
    if (!(dst == rhs.dst))
      return false;
    if (!(nodeID == rhs.nodeID))
      return false;
    if (!(defID == rhs.defID))
      return false;
    if (!(libID == rhs.libID))
      return false;
    if (!(projectID == rhs.projectID))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNodeDefault_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNodeDefault_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_removeNodeDefault_pargs {
 public:


  virtual ~Batch_removeNodeDefault_pargs() throw() {}

  const  ::flowbox::batch::graph::PortDescriptor* dst;
  const  ::flowbox::batch::graph::NodeID* nodeID;
  const  ::flowbox::batch::defs::DefID* defID;
  const  ::flowbox::batch::libs::LibID* libID;
  const  ::flowbox::batch::projects::ProjectID* projectID;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNodeDefault_result__isset {
  _Batch_removeNodeDefault_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNodeDefault_result__isset;

class Batch_removeNodeDefault_result {
 public:

  Batch_removeNodeDefault_result() {
  }

  virtual ~Batch_removeNodeDefault_result() throw() {}

  ArgumentException missingFields;

  _Batch_removeNodeDefault_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_removeNodeDefault_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_removeNodeDefault_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_removeNodeDefault_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_removeNodeDefault_presult__isset {
  _Batch_removeNodeDefault_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_removeNodeDefault_presult__isset;

class Batch_removeNodeDefault_presult {
 public:


  virtual ~Batch_removeNodeDefault_presult() throw() {}

  ArgumentException missingFields;

  _Batch_removeNodeDefault_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_ls_args__isset {
  _Batch_FS_ls_args__isset() : path(false) {}
  bool path;
} _Batch_FS_ls_args__isset;

class Batch_FS_ls_args {
 public:

  Batch_FS_ls_args() : path() {
  }

  virtual ~Batch_FS_ls_args() throw() {}

  std::string path;

  _Batch_FS_ls_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_FS_ls_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_ls_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_ls_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_ls_pargs {
 public:


  virtual ~Batch_FS_ls_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_ls_result__isset {
  _Batch_FS_ls_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_FS_ls_result__isset;

class Batch_FS_ls_result {
 public:

  Batch_FS_ls_result() {
  }

  virtual ~Batch_FS_ls_result() throw() {}

  std::vector< ::flowbox::batch::fs::FSItem>  success;
  ArgumentException missingFields;

  _Batch_FS_ls_result__isset __isset;

  void __set_success(const std::vector< ::flowbox::batch::fs::FSItem> & val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_ls_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_ls_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_ls_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_ls_presult__isset {
  _Batch_FS_ls_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_FS_ls_presult__isset;

class Batch_FS_ls_presult {
 public:


  virtual ~Batch_FS_ls_presult() throw() {}

  std::vector< ::flowbox::batch::fs::FSItem> * success;
  ArgumentException missingFields;

  _Batch_FS_ls_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_stat_args__isset {
  _Batch_FS_stat_args__isset() : path(false) {}
  bool path;
} _Batch_FS_stat_args__isset;

class Batch_FS_stat_args {
 public:

  Batch_FS_stat_args() : path() {
  }

  virtual ~Batch_FS_stat_args() throw() {}

  std::string path;

  _Batch_FS_stat_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_FS_stat_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_stat_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_stat_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_stat_pargs {
 public:


  virtual ~Batch_FS_stat_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_stat_result__isset {
  _Batch_FS_stat_result__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_FS_stat_result__isset;

class Batch_FS_stat_result {
 public:

  Batch_FS_stat_result() {
  }

  virtual ~Batch_FS_stat_result() throw() {}

   ::flowbox::batch::fs::FSItem success;
  ArgumentException missingFields;

  _Batch_FS_stat_result__isset __isset;

  void __set_success(const  ::flowbox::batch::fs::FSItem& val) {
    success = val;
  }

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_stat_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_stat_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_stat_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_stat_presult__isset {
  _Batch_FS_stat_presult__isset() : success(false), missingFields(false) {}
  bool success;
  bool missingFields;
} _Batch_FS_stat_presult__isset;

class Batch_FS_stat_presult {
 public:


  virtual ~Batch_FS_stat_presult() throw() {}

   ::flowbox::batch::fs::FSItem* success;
  ArgumentException missingFields;

  _Batch_FS_stat_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_mkdir_args__isset {
  _Batch_FS_mkdir_args__isset() : path(false) {}
  bool path;
} _Batch_FS_mkdir_args__isset;

class Batch_FS_mkdir_args {
 public:

  Batch_FS_mkdir_args() : path() {
  }

  virtual ~Batch_FS_mkdir_args() throw() {}

  std::string path;

  _Batch_FS_mkdir_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_FS_mkdir_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_mkdir_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_mkdir_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_mkdir_pargs {
 public:


  virtual ~Batch_FS_mkdir_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_mkdir_result__isset {
  _Batch_FS_mkdir_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_mkdir_result__isset;

class Batch_FS_mkdir_result {
 public:

  Batch_FS_mkdir_result() {
  }

  virtual ~Batch_FS_mkdir_result() throw() {}

  ArgumentException missingFields;

  _Batch_FS_mkdir_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_mkdir_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_mkdir_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_mkdir_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_mkdir_presult__isset {
  _Batch_FS_mkdir_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_mkdir_presult__isset;

class Batch_FS_mkdir_presult {
 public:


  virtual ~Batch_FS_mkdir_presult() throw() {}

  ArgumentException missingFields;

  _Batch_FS_mkdir_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_touch_args__isset {
  _Batch_FS_touch_args__isset() : path(false) {}
  bool path;
} _Batch_FS_touch_args__isset;

class Batch_FS_touch_args {
 public:

  Batch_FS_touch_args() : path() {
  }

  virtual ~Batch_FS_touch_args() throw() {}

  std::string path;

  _Batch_FS_touch_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_FS_touch_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_touch_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_touch_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_touch_pargs {
 public:


  virtual ~Batch_FS_touch_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_touch_result__isset {
  _Batch_FS_touch_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_touch_result__isset;

class Batch_FS_touch_result {
 public:

  Batch_FS_touch_result() {
  }

  virtual ~Batch_FS_touch_result() throw() {}

  ArgumentException missingFields;

  _Batch_FS_touch_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_touch_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_touch_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_touch_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_touch_presult__isset {
  _Batch_FS_touch_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_touch_presult__isset;

class Batch_FS_touch_presult {
 public:


  virtual ~Batch_FS_touch_presult() throw() {}

  ArgumentException missingFields;

  _Batch_FS_touch_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_rm_args__isset {
  _Batch_FS_rm_args__isset() : path(false) {}
  bool path;
} _Batch_FS_rm_args__isset;

class Batch_FS_rm_args {
 public:

  Batch_FS_rm_args() : path() {
  }

  virtual ~Batch_FS_rm_args() throw() {}

  std::string path;

  _Batch_FS_rm_args__isset __isset;

  void __set_path(const std::string& val) {
    path = val;
  }

  bool operator == (const Batch_FS_rm_args & rhs) const
  {
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_rm_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_rm_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_rm_pargs {
 public:


  virtual ~Batch_FS_rm_pargs() throw() {}

  const std::string* path;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_rm_result__isset {
  _Batch_FS_rm_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_rm_result__isset;

class Batch_FS_rm_result {
 public:

  Batch_FS_rm_result() {
  }

  virtual ~Batch_FS_rm_result() throw() {}

  ArgumentException missingFields;

  _Batch_FS_rm_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_rm_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_rm_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_rm_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_rm_presult__isset {
  _Batch_FS_rm_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_rm_presult__isset;

class Batch_FS_rm_presult {
 public:


  virtual ~Batch_FS_rm_presult() throw() {}

  ArgumentException missingFields;

  _Batch_FS_rm_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_cp_args__isset {
  _Batch_FS_cp_args__isset() : src(false), dst(false) {}
  bool src;
  bool dst;
} _Batch_FS_cp_args__isset;

class Batch_FS_cp_args {
 public:

  Batch_FS_cp_args() : src(), dst() {
  }

  virtual ~Batch_FS_cp_args() throw() {}

  std::string src;
  std::string dst;

  _Batch_FS_cp_args__isset __isset;

  void __set_src(const std::string& val) {
    src = val;
  }

  void __set_dst(const std::string& val) {
    dst = val;
  }

  bool operator == (const Batch_FS_cp_args & rhs) const
  {
    if (!(src == rhs.src))
      return false;
    if (!(dst == rhs.dst))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_cp_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_cp_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_cp_pargs {
 public:


  virtual ~Batch_FS_cp_pargs() throw() {}

  const std::string* src;
  const std::string* dst;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_cp_result__isset {
  _Batch_FS_cp_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_cp_result__isset;

class Batch_FS_cp_result {
 public:

  Batch_FS_cp_result() {
  }

  virtual ~Batch_FS_cp_result() throw() {}

  ArgumentException missingFields;

  _Batch_FS_cp_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_cp_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_cp_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_cp_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_cp_presult__isset {
  _Batch_FS_cp_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_cp_presult__isset;

class Batch_FS_cp_presult {
 public:


  virtual ~Batch_FS_cp_presult() throw() {}

  ArgumentException missingFields;

  _Batch_FS_cp_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Batch_FS_mv_args__isset {
  _Batch_FS_mv_args__isset() : src(false), dst(false) {}
  bool src;
  bool dst;
} _Batch_FS_mv_args__isset;

class Batch_FS_mv_args {
 public:

  Batch_FS_mv_args() : src(), dst() {
  }

  virtual ~Batch_FS_mv_args() throw() {}

  std::string src;
  std::string dst;

  _Batch_FS_mv_args__isset __isset;

  void __set_src(const std::string& val) {
    src = val;
  }

  void __set_dst(const std::string& val) {
    dst = val;
  }

  bool operator == (const Batch_FS_mv_args & rhs) const
  {
    if (!(src == rhs.src))
      return false;
    if (!(dst == rhs.dst))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_mv_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_mv_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_FS_mv_pargs {
 public:


  virtual ~Batch_FS_mv_pargs() throw() {}

  const std::string* src;
  const std::string* dst;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_mv_result__isset {
  _Batch_FS_mv_result__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_mv_result__isset;

class Batch_FS_mv_result {
 public:

  Batch_FS_mv_result() {
  }

  virtual ~Batch_FS_mv_result() throw() {}

  ArgumentException missingFields;

  _Batch_FS_mv_result__isset __isset;

  void __set_missingFields(const ArgumentException& val) {
    missingFields = val;
  }

  bool operator == (const Batch_FS_mv_result & rhs) const
  {
    if (!(missingFields == rhs.missingFields))
      return false;
    return true;
  }
  bool operator != (const Batch_FS_mv_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_FS_mv_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Batch_FS_mv_presult__isset {
  _Batch_FS_mv_presult__isset() : missingFields(false) {}
  bool missingFields;
} _Batch_FS_mv_presult__isset;

class Batch_FS_mv_presult {
 public:


  virtual ~Batch_FS_mv_presult() throw() {}

  ArgumentException missingFields;

  _Batch_FS_mv_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_initialize_args {
 public:

  Batch_initialize_args() {
  }

  virtual ~Batch_initialize_args() throw() {}


  bool operator == (const Batch_initialize_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_initialize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_initialize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_initialize_pargs {
 public:


  virtual ~Batch_initialize_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_initialize_result {
 public:

  Batch_initialize_result() {
  }

  virtual ~Batch_initialize_result() throw() {}


  bool operator == (const Batch_initialize_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_initialize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_initialize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_initialize_presult {
 public:


  virtual ~Batch_initialize_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_ping_args {
 public:

  Batch_ping_args() {
  }

  virtual ~Batch_ping_args() throw() {}


  bool operator == (const Batch_ping_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_ping_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_ping_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_pargs {
 public:


  virtual ~Batch_ping_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_result {
 public:

  Batch_ping_result() {
  }

  virtual ~Batch_ping_result() throw() {}


  bool operator == (const Batch_ping_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_ping_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_ping_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_ping_presult {
 public:


  virtual ~Batch_ping_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_dump_args {
 public:

  Batch_dump_args() {
  }

  virtual ~Batch_dump_args() throw() {}


  bool operator == (const Batch_dump_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_dump_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_dump_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_dump_pargs {
 public:


  virtual ~Batch_dump_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_dump_result {
 public:

  Batch_dump_result() {
  }

  virtual ~Batch_dump_result() throw() {}


  bool operator == (const Batch_dump_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_dump_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_dump_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_dump_presult {
 public:


  virtual ~Batch_dump_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Batch_shutdown_args {
 public:

  Batch_shutdown_args() {
  }

  virtual ~Batch_shutdown_args() throw() {}


  bool operator == (const Batch_shutdown_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_shutdown_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_shutdown_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_shutdown_pargs {
 public:


  virtual ~Batch_shutdown_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_shutdown_result {
 public:

  Batch_shutdown_result() {
  }

  virtual ~Batch_shutdown_result() throw() {}


  bool operator == (const Batch_shutdown_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Batch_shutdown_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Batch_shutdown_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Batch_shutdown_presult {
 public:


  virtual ~Batch_shutdown_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class BatchClient : virtual public BatchIf {
 public:
  BatchClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  BatchClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void projects(std::vector< ::flowbox::batch::projects::Project> & _return);
  void send_projects();
  void recv_projects(std::vector< ::flowbox::batch::projects::Project> & _return);
  void projectByID( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_projectByID(const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_projectByID( ::flowbox::batch::projects::Project& _return);
  void createProject( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::Project& project);
  void send_createProject(const  ::flowbox::batch::projects::Project& project);
  void recv_createProject( ::flowbox::batch::projects::Project& _return);
  void openProject( ::flowbox::batch::projects::Project& _return, const std::string& path);
  void send_openProject(const std::string& path);
  void recv_openProject( ::flowbox::batch::projects::Project& _return);
  void updateProject(const  ::flowbox::batch::projects::Project& project);
  void send_updateProject(const  ::flowbox::batch::projects::Project& project);
  void recv_updateProject();
  void closeProject(const  ::flowbox::batch::projects::ProjectID projectID);
  void send_closeProject(const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_closeProject();
  void storeProject(const  ::flowbox::batch::projects::ProjectID projectID);
  void send_storeProject(const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_storeProject();
  void libraries(std::vector< ::flowbox::batch::libs::Library> & _return, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_libraries(const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_libraries(std::vector< ::flowbox::batch::libs::Library> & _return);
  void libraryByID( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::LibID libraryID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_libraryByID(const  ::flowbox::batch::libs::LibID libraryID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_libraryByID( ::flowbox::batch::libs::Library& _return);
  void createLibrary( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::Library& library, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_createLibrary(const  ::flowbox::batch::libs::Library& library, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_createLibrary( ::flowbox::batch::libs::Library& _return);
  void loadLibrary( ::flowbox::batch::libs::Library& _return, const std::string& path, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_loadLibrary(const std::string& path, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_loadLibrary( ::flowbox::batch::libs::Library& _return);
  void unloadLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_unloadLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_unloadLibrary();
  void storeLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_storeLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_storeLibrary();
  void buildLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_buildLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_buildLibrary();
  void runLibrary(std::string& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_runLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_runLibrary(std::string& _return);
  void libraryRootDef( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_libraryRootDef(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_libraryRootDef( ::flowbox::batch::defs::Definition& _return);
  void defsGraph( ::flowbox::batch::defs::DefsGraph& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_defsGraph(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_defsGraph( ::flowbox::batch::defs::DefsGraph& _return);
  void defByID( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_defByID(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_defByID( ::flowbox::batch::defs::Definition& _return);
  void addDefinition( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_addDefinition(const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_addDefinition( ::flowbox::batch::defs::Definition& _return);
  void updateDefinition(const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_updateDefinition(const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_updateDefinition();
  void removeDefinition(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_removeDefinition(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_removeDefinition();
  void definitionChildren(std::vector< ::flowbox::batch::defs::Definition> & _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_definitionChildren(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_definitionChildren(std::vector< ::flowbox::batch::defs::Definition> & _return);
  void definitionParent( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_definitionParent(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_definitionParent( ::flowbox::batch::defs::Definition& _return);
  void resolveDefinition(std::vector< ::flowbox::batch::defs::DefPtr> & _return, const std::string& name, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_resolveDefinition(const std::string& name, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_resolveDefinition(std::vector< ::flowbox::batch::defs::DefPtr> & _return);
  void newTypeModule( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector< ::flowbox::batch::types::Type> & fields);
  void send_newTypeModule(const std::string& name, const std::vector< ::flowbox::batch::types::Type> & fields);
  void recv_newTypeModule( ::flowbox::batch::types::Type& _return);
  void newTypeClass( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector<std::string> & params, const std::vector< ::flowbox::batch::types::Type> & fields);
  void send_newTypeClass(const std::string& name, const std::vector<std::string> & params, const std::vector< ::flowbox::batch::types::Type> & fields);
  void recv_newTypeClass( ::flowbox::batch::types::Type& _return);
  void newTypeFunction( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& inputs, const  ::flowbox::batch::types::Type& outputs);
  void send_newTypeFunction(const std::string& name, const  ::flowbox::batch::types::Type& inputs, const  ::flowbox::batch::types::Type& outputs);
  void recv_newTypeFunction( ::flowbox::batch::types::Type& _return);
  void newTypeUdefined( ::flowbox::batch::types::Type& _return);
  void send_newTypeUdefined();
  void recv_newTypeUdefined( ::flowbox::batch::types::Type& _return);
  void newTypeNamed( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& type);
  void send_newTypeNamed(const std::string& name, const  ::flowbox::batch::types::Type& type);
  void recv_newTypeNamed( ::flowbox::batch::types::Type& _return);
  void newTypeName( ::flowbox::batch::types::Type& _return, const std::string& name);
  void send_newTypeName(const std::string& name);
  void recv_newTypeName( ::flowbox::batch::types::Type& _return);
  void newTypeTuple( ::flowbox::batch::types::Type& _return, const std::vector< ::flowbox::batch::types::Type> & types);
  void send_newTypeTuple(const std::vector< ::flowbox::batch::types::Type> & types);
  void recv_newTypeTuple( ::flowbox::batch::types::Type& _return);
  void nodesGraph( ::flowbox::batch::graph::GraphView& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_nodesGraph(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_nodesGraph( ::flowbox::batch::graph::GraphView& _return);
  void nodeByID( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_nodeByID(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_nodeByID( ::flowbox::batch::graph::Node& _return);
  void addNode( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_addNode(const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_addNode( ::flowbox::batch::graph::Node& _return);
  void updateNode(const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_updateNode(const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_updateNode();
  void removeNode(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_removeNode(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_removeNode();
  void connect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_connect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_connect();
  void disconnect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_disconnect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_disconnect();
  void nodeDefaults(std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_nodeDefaults(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_nodeDefaults(std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & _return);
  void setNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::DefaultValue& value, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_setNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::DefaultValue& value, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_setNodeDefault();
  void removeNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void send_removeNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID);
  void recv_removeNodeDefault();
  void FS_ls(std::vector< ::flowbox::batch::fs::FSItem> & _return, const std::string& path);
  void send_FS_ls(const std::string& path);
  void recv_FS_ls(std::vector< ::flowbox::batch::fs::FSItem> & _return);
  void FS_stat( ::flowbox::batch::fs::FSItem& _return, const std::string& path);
  void send_FS_stat(const std::string& path);
  void recv_FS_stat( ::flowbox::batch::fs::FSItem& _return);
  void FS_mkdir(const std::string& path);
  void send_FS_mkdir(const std::string& path);
  void recv_FS_mkdir();
  void FS_touch(const std::string& path);
  void send_FS_touch(const std::string& path);
  void recv_FS_touch();
  void FS_rm(const std::string& path);
  void send_FS_rm(const std::string& path);
  void recv_FS_rm();
  void FS_cp(const std::string& src, const std::string& dst);
  void send_FS_cp(const std::string& src, const std::string& dst);
  void recv_FS_cp();
  void FS_mv(const std::string& src, const std::string& dst);
  void send_FS_mv(const std::string& src, const std::string& dst);
  void recv_FS_mv();
  void initialize();
  void send_initialize();
  void recv_initialize();
  void ping();
  void send_ping();
  void recv_ping();
  void dump();
  void send_dump();
  void recv_dump();
  void shutdown();
  void send_shutdown();
  void recv_shutdown();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class BatchProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<BatchIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (BatchProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_projects(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_projectByID(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createProject(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_openProject(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateProject(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_closeProject(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_storeProject(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_libraries(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_libraryByID(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_loadLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_unloadLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_storeLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_buildLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_runLibrary(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_libraryRootDef(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defsGraph(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_defByID(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_definitionChildren(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_definitionParent(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_resolveDefinition(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeModule(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeClass(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeFunction(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeUdefined(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeNamed(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTypeTuple(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_nodesGraph(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_nodeByID(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_addNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_updateNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeNode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_connect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disconnect(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_nodeDefaults(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_setNodeDefault(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_removeNodeDefault(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_ls(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_stat(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_mkdir(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_touch(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_rm(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_cp(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_FS_mv(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_initialize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ping(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_dump(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_shutdown(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  BatchProcessor(boost::shared_ptr<BatchIf> iface) :
    iface_(iface) {
    processMap_["projects"] = &BatchProcessor::process_projects;
    processMap_["projectByID"] = &BatchProcessor::process_projectByID;
    processMap_["createProject"] = &BatchProcessor::process_createProject;
    processMap_["openProject"] = &BatchProcessor::process_openProject;
    processMap_["updateProject"] = &BatchProcessor::process_updateProject;
    processMap_["closeProject"] = &BatchProcessor::process_closeProject;
    processMap_["storeProject"] = &BatchProcessor::process_storeProject;
    processMap_["libraries"] = &BatchProcessor::process_libraries;
    processMap_["libraryByID"] = &BatchProcessor::process_libraryByID;
    processMap_["createLibrary"] = &BatchProcessor::process_createLibrary;
    processMap_["loadLibrary"] = &BatchProcessor::process_loadLibrary;
    processMap_["unloadLibrary"] = &BatchProcessor::process_unloadLibrary;
    processMap_["storeLibrary"] = &BatchProcessor::process_storeLibrary;
    processMap_["buildLibrary"] = &BatchProcessor::process_buildLibrary;
    processMap_["runLibrary"] = &BatchProcessor::process_runLibrary;
    processMap_["libraryRootDef"] = &BatchProcessor::process_libraryRootDef;
    processMap_["defsGraph"] = &BatchProcessor::process_defsGraph;
    processMap_["defByID"] = &BatchProcessor::process_defByID;
    processMap_["addDefinition"] = &BatchProcessor::process_addDefinition;
    processMap_["updateDefinition"] = &BatchProcessor::process_updateDefinition;
    processMap_["removeDefinition"] = &BatchProcessor::process_removeDefinition;
    processMap_["definitionChildren"] = &BatchProcessor::process_definitionChildren;
    processMap_["definitionParent"] = &BatchProcessor::process_definitionParent;
    processMap_["resolveDefinition"] = &BatchProcessor::process_resolveDefinition;
    processMap_["newTypeModule"] = &BatchProcessor::process_newTypeModule;
    processMap_["newTypeClass"] = &BatchProcessor::process_newTypeClass;
    processMap_["newTypeFunction"] = &BatchProcessor::process_newTypeFunction;
    processMap_["newTypeUdefined"] = &BatchProcessor::process_newTypeUdefined;
    processMap_["newTypeNamed"] = &BatchProcessor::process_newTypeNamed;
    processMap_["newTypeName"] = &BatchProcessor::process_newTypeName;
    processMap_["newTypeTuple"] = &BatchProcessor::process_newTypeTuple;
    processMap_["nodesGraph"] = &BatchProcessor::process_nodesGraph;
    processMap_["nodeByID"] = &BatchProcessor::process_nodeByID;
    processMap_["addNode"] = &BatchProcessor::process_addNode;
    processMap_["updateNode"] = &BatchProcessor::process_updateNode;
    processMap_["removeNode"] = &BatchProcessor::process_removeNode;
    processMap_["connect"] = &BatchProcessor::process_connect;
    processMap_["disconnect"] = &BatchProcessor::process_disconnect;
    processMap_["nodeDefaults"] = &BatchProcessor::process_nodeDefaults;
    processMap_["setNodeDefault"] = &BatchProcessor::process_setNodeDefault;
    processMap_["removeNodeDefault"] = &BatchProcessor::process_removeNodeDefault;
    processMap_["FS_ls"] = &BatchProcessor::process_FS_ls;
    processMap_["FS_stat"] = &BatchProcessor::process_FS_stat;
    processMap_["FS_mkdir"] = &BatchProcessor::process_FS_mkdir;
    processMap_["FS_touch"] = &BatchProcessor::process_FS_touch;
    processMap_["FS_rm"] = &BatchProcessor::process_FS_rm;
    processMap_["FS_cp"] = &BatchProcessor::process_FS_cp;
    processMap_["FS_mv"] = &BatchProcessor::process_FS_mv;
    processMap_["initialize"] = &BatchProcessor::process_initialize;
    processMap_["ping"] = &BatchProcessor::process_ping;
    processMap_["dump"] = &BatchProcessor::process_dump;
    processMap_["shutdown"] = &BatchProcessor::process_shutdown;
  }

  virtual ~BatchProcessor() {}
};

class BatchProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  BatchProcessorFactory(const ::boost::shared_ptr< BatchIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< BatchIfFactory > handlerFactory_;
};

class BatchMultiface : virtual public BatchIf {
 public:
  BatchMultiface(std::vector<boost::shared_ptr<BatchIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~BatchMultiface() {}
 protected:
  std::vector<boost::shared_ptr<BatchIf> > ifaces_;
  BatchMultiface() {}
  void add(boost::shared_ptr<BatchIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void projects(std::vector< ::flowbox::batch::projects::Project> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->projects(_return);
    }
    ifaces_[i]->projects(_return);
    return;
  }

  void projectByID( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->projectByID(_return, projectID);
    }
    ifaces_[i]->projectByID(_return, projectID);
    return;
  }

  void createProject( ::flowbox::batch::projects::Project& _return, const  ::flowbox::batch::projects::Project& project) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createProject(_return, project);
    }
    ifaces_[i]->createProject(_return, project);
    return;
  }

  void openProject( ::flowbox::batch::projects::Project& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->openProject(_return, path);
    }
    ifaces_[i]->openProject(_return, path);
    return;
  }

  void updateProject(const  ::flowbox::batch::projects::Project& project) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateProject(project);
    }
    ifaces_[i]->updateProject(project);
  }

  void closeProject(const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->closeProject(projectID);
    }
    ifaces_[i]->closeProject(projectID);
  }

  void storeProject(const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->storeProject(projectID);
    }
    ifaces_[i]->storeProject(projectID);
  }

  void libraries(std::vector< ::flowbox::batch::libs::Library> & _return, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->libraries(_return, projectID);
    }
    ifaces_[i]->libraries(_return, projectID);
    return;
  }

  void libraryByID( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::LibID libraryID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->libraryByID(_return, libraryID, projectID);
    }
    ifaces_[i]->libraryByID(_return, libraryID, projectID);
    return;
  }

  void createLibrary( ::flowbox::batch::libs::Library& _return, const  ::flowbox::batch::libs::Library& library, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createLibrary(_return, library, projectID);
    }
    ifaces_[i]->createLibrary(_return, library, projectID);
    return;
  }

  void loadLibrary( ::flowbox::batch::libs::Library& _return, const std::string& path, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->loadLibrary(_return, path, projectID);
    }
    ifaces_[i]->loadLibrary(_return, path, projectID);
    return;
  }

  void unloadLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->unloadLibrary(libID, projectID);
    }
    ifaces_[i]->unloadLibrary(libID, projectID);
  }

  void storeLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->storeLibrary(libID, projectID);
    }
    ifaces_[i]->storeLibrary(libID, projectID);
  }

  void buildLibrary(const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->buildLibrary(libID, projectID);
    }
    ifaces_[i]->buildLibrary(libID, projectID);
  }

  void runLibrary(std::string& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->runLibrary(_return, libID, projectID);
    }
    ifaces_[i]->runLibrary(_return, libID, projectID);
    return;
  }

  void libraryRootDef( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->libraryRootDef(_return, libID, projectID);
    }
    ifaces_[i]->libraryRootDef(_return, libID, projectID);
    return;
  }

  void defsGraph( ::flowbox::batch::defs::DefsGraph& _return, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->defsGraph(_return, libID, projectID);
    }
    ifaces_[i]->defsGraph(_return, libID, projectID);
    return;
  }

  void defByID( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->defByID(_return, defID, libID, projectID);
    }
    ifaces_[i]->defByID(_return, defID, libID, projectID);
    return;
  }

  void addDefinition( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addDefinition(_return, definition, parentID, libID, projectID);
    }
    ifaces_[i]->addDefinition(_return, definition, parentID, libID, projectID);
    return;
  }

  void updateDefinition(const  ::flowbox::batch::defs::Definition& definition, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateDefinition(definition, libID, projectID);
    }
    ifaces_[i]->updateDefinition(definition, libID, projectID);
  }

  void removeDefinition(const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeDefinition(defID, libID, projectID);
    }
    ifaces_[i]->removeDefinition(defID, libID, projectID);
  }

  void definitionChildren(std::vector< ::flowbox::batch::defs::Definition> & _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->definitionChildren(_return, defID, libID, projectID);
    }
    ifaces_[i]->definitionChildren(_return, defID, libID, projectID);
    return;
  }

  void definitionParent( ::flowbox::batch::defs::Definition& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->definitionParent(_return, defID, libID, projectID);
    }
    ifaces_[i]->definitionParent(_return, defID, libID, projectID);
    return;
  }

  void resolveDefinition(std::vector< ::flowbox::batch::defs::DefPtr> & _return, const std::string& name, const  ::flowbox::batch::defs::DefID parentID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->resolveDefinition(_return, name, parentID, libID, projectID);
    }
    ifaces_[i]->resolveDefinition(_return, name, parentID, libID, projectID);
    return;
  }

  void newTypeModule( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector< ::flowbox::batch::types::Type> & fields) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeModule(_return, name, fields);
    }
    ifaces_[i]->newTypeModule(_return, name, fields);
    return;
  }

  void newTypeClass( ::flowbox::batch::types::Type& _return, const std::string& name, const std::vector<std::string> & params, const std::vector< ::flowbox::batch::types::Type> & fields) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeClass(_return, name, params, fields);
    }
    ifaces_[i]->newTypeClass(_return, name, params, fields);
    return;
  }

  void newTypeFunction( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& inputs, const  ::flowbox::batch::types::Type& outputs) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeFunction(_return, name, inputs, outputs);
    }
    ifaces_[i]->newTypeFunction(_return, name, inputs, outputs);
    return;
  }

  void newTypeUdefined( ::flowbox::batch::types::Type& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeUdefined(_return);
    }
    ifaces_[i]->newTypeUdefined(_return);
    return;
  }

  void newTypeNamed( ::flowbox::batch::types::Type& _return, const std::string& name, const  ::flowbox::batch::types::Type& type) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeNamed(_return, name, type);
    }
    ifaces_[i]->newTypeNamed(_return, name, type);
    return;
  }

  void newTypeName( ::flowbox::batch::types::Type& _return, const std::string& name) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeName(_return, name);
    }
    ifaces_[i]->newTypeName(_return, name);
    return;
  }

  void newTypeTuple( ::flowbox::batch::types::Type& _return, const std::vector< ::flowbox::batch::types::Type> & types) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTypeTuple(_return, types);
    }
    ifaces_[i]->newTypeTuple(_return, types);
    return;
  }

  void nodesGraph( ::flowbox::batch::graph::GraphView& _return, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->nodesGraph(_return, defID, libID, projectID);
    }
    ifaces_[i]->nodesGraph(_return, defID, libID, projectID);
    return;
  }

  void nodeByID( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->nodeByID(_return, nodeID, defID, libID, projectID);
    }
    ifaces_[i]->nodeByID(_return, nodeID, defID, libID, projectID);
    return;
  }

  void addNode( ::flowbox::batch::graph::Node& _return, const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->addNode(_return, node, defID, libID, projectID);
    }
    ifaces_[i]->addNode(_return, node, defID, libID, projectID);
    return;
  }

  void updateNode(const  ::flowbox::batch::graph::Node& node, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->updateNode(node, defID, libID, projectID);
    }
    ifaces_[i]->updateNode(node, defID, libID, projectID);
  }

  void removeNode(const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeNode(nodeID, defID, libID, projectID);
    }
    ifaces_[i]->removeNode(nodeID, defID, libID, projectID);
  }

  void connect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->connect(srcNodeID, srcPort, dstNodeID, dstPort, defID, libID, projectID);
    }
    ifaces_[i]->connect(srcNodeID, srcPort, dstNodeID, dstPort, defID, libID, projectID);
  }

  void disconnect(const  ::flowbox::batch::graph::NodeID srcNodeID, const  ::flowbox::batch::graph::PortDescriptor& srcPort, const  ::flowbox::batch::graph::NodeID dstNodeID, const  ::flowbox::batch::graph::PortDescriptor& dstPort, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disconnect(srcNodeID, srcPort, dstNodeID, dstPort, defID, libID, projectID);
    }
    ifaces_[i]->disconnect(srcNodeID, srcPort, dstNodeID, dstPort, defID, libID, projectID);
  }

  void nodeDefaults(std::map< ::flowbox::batch::graph::PortDescriptor,  ::flowbox::batch::graph::DefaultValue> & _return, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->nodeDefaults(_return, nodeID, defID, libID, projectID);
    }
    ifaces_[i]->nodeDefaults(_return, nodeID, defID, libID, projectID);
    return;
  }

  void setNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::DefaultValue& value, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->setNodeDefault(dst, value, nodeID, defID, libID, projectID);
    }
    ifaces_[i]->setNodeDefault(dst, value, nodeID, defID, libID, projectID);
  }

  void removeNodeDefault(const  ::flowbox::batch::graph::PortDescriptor& dst, const  ::flowbox::batch::graph::NodeID nodeID, const  ::flowbox::batch::defs::DefID defID, const  ::flowbox::batch::libs::LibID libID, const  ::flowbox::batch::projects::ProjectID projectID) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->removeNodeDefault(dst, nodeID, defID, libID, projectID);
    }
    ifaces_[i]->removeNodeDefault(dst, nodeID, defID, libID, projectID);
  }

  void FS_ls(std::vector< ::flowbox::batch::fs::FSItem> & _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_ls(_return, path);
    }
    ifaces_[i]->FS_ls(_return, path);
    return;
  }

  void FS_stat( ::flowbox::batch::fs::FSItem& _return, const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_stat(_return, path);
    }
    ifaces_[i]->FS_stat(_return, path);
    return;
  }

  void FS_mkdir(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_mkdir(path);
    }
    ifaces_[i]->FS_mkdir(path);
  }

  void FS_touch(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_touch(path);
    }
    ifaces_[i]->FS_touch(path);
  }

  void FS_rm(const std::string& path) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_rm(path);
    }
    ifaces_[i]->FS_rm(path);
  }

  void FS_cp(const std::string& src, const std::string& dst) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_cp(src, dst);
    }
    ifaces_[i]->FS_cp(src, dst);
  }

  void FS_mv(const std::string& src, const std::string& dst) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->FS_mv(src, dst);
    }
    ifaces_[i]->FS_mv(src, dst);
  }

  void initialize() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->initialize();
    }
    ifaces_[i]->initialize();
  }

  void ping() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ping();
    }
    ifaces_[i]->ping();
  }

  void dump() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->dump();
    }
    ifaces_[i]->dump();
  }

  void shutdown() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->shutdown();
    }
    ifaces_[i]->shutdown();
  }

};

}} // namespace

#endif
