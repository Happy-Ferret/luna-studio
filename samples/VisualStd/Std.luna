###### Console ################################

def print self msg::String:
    ```print' #{msg}```

###### List ###################################

def List.at self index:
    ```(flattenCtx `dot2` liftf2 (!!)) #{self} #{index}```

def List.+ self l2:
    ```liftf2 (++) #{self} #{l2}```

def List.contains self el:
    ```liftf2 (elem) (val #{el}) #{self}```

def List.each self callback:
    ```let {mymap = liftf2 map}```
    ```mymap (val $ call1 #{callback}) #{self}```

def List.foldr self f el:
    ```flattenCtx $ (fmap.fmap) (foldr (call2 #{f}) #{el}) #{self}```

def List.head self:
    ```flattenCtx $ liftf1 head #{self}```

def List.length self:
    ```liftf1 length #{self}```

def List.sort self:
    #FIXME[wd]: very dirty hack for Pure Safe values.
    ```(fmap.fmap.fmap) val $ liftf1 sort ((fmap.fmap.fmap) (fromSafe.fromPure) #{self})```

def List.min self:
    self.sort.head

def List.sum self:
    self.foldr ((x,y):x+y) 0


###### Bool ####################################

def Bool.not self:
    ```liftf1 not #{self}```

###### Int ####################################

def Int.+ self::Int a::Int:
    ```liftf2 (+) #{self} #{a}```

def Int.- self::Int a::Int:
    ```liftf2 (-) #{self} #{a}```

def Int.* self::Int a::Int:
    ```liftf2 (*) #{self} #{a}```

def Int./ self::Int a::Int:
    ```liftf2 (\a b -> toDouble a / toDouble b) #{self} #{a}```

def Int.< self::Int a::Int:
    ```liftf2 (<) #{self} #{a}```

def Int.> self::Int a::Int:
    ```liftf2 (>) #{self} #{a}```

def Int.sqrt self::Int:
    ```liftf1 (sqrt.toDouble) #{self}```

def Int.next self::Int:
    ```liftf1 (+1) #{self}```

def Int.prev self::Int:
    ```liftf1 (-1) #{self}```

###### Double ##################################

def Double.+ self::Float a::Float:
    ```liftf2 (+) #{self} #{a}```

def Double.- self::Float a::Float:
    ```liftf2 (-) #{self} #{a}```

def Double.* self::Float a::Float:
    ```liftf2 (*) #{self} #{a}```
    
def Double./ self::Float a::Float:
    ```liftf2 (/) #{self} #{a}```

def Double.< self::Float a::Float:
    ```liftf2 (<) #{self} #{a}```

def Double.> self::Float a::Float:
    ```liftf2 (>) #{self} #{a}```

def Double.sqrt self::Float:
    ```liftf1 sqrt #{self}```

def Double.next self::Float:
    ```liftf1 (+1) #{self}```

def Double.prev self::Float:
    ```liftf1 (-1) #{self}```



def Double.invert self::Float:
    ```liftf1 invert #{self}```

def Double.invert_ self::Float:
    ```liftf1 invert' #{self}```

def Double.sign self::Float:
    ```liftf1 sign #{self}```

def Double.parametrize self::Float lo::Float hi::Float:
    ```liftf3 parametrize #{lo} #{hi} #{self}```

def Double.bias self::Float b::Float:
    ```liftf2 bias #{b} #{self}```

def Double.gain self::Float g::Float:
    ```liftf2 gain #{g} #{self}```

def Double.gamma self::Float g::Float:
    ```liftf2 gamma #{g} #{self}```

def Double.compress self::Float lo::Float hi::Float:
    ```liftf3 gamma #{lo} #{hi} #{self}```

def Double.expand self::Float lo::Float hi::Float:
    ```liftf3 expand #{lo} #{hi} #{self}```

def Double.remap self::Float loA::Float hiA::Float loB::Float hiB::Float:
    ```liftf5 remap #{loA} #{hiA} #{loB} #{hiB} #{self}```



def raise self el err:
    ```raise #{el} #{err}```

def catch self el f:
    ```catch #{el} #{f}```

def isError self a:
    ```isError #{a}```

class Sys:
    def exitSuccess self:
        ```Exit.exitSuccess *> returnIO (Safe ())```
    def exitFailure self:
        ```Exit.exitFailure *> returnIO (Safe ())```


## Backend ####################################

def cuda self::Std:
    ```liftf0 cuda```

def interp self::Std:
    ```liftf0 interp```

## Image ######################################

def readImageWord8 self::Std path::Path:
    ```flattenCtx $ liftf1 (Image.readImageFromBMP2) #{path}```

def readImage self::Std path::Path:
    (readImageWord8 path).decompose.reprDouble

# FIXME[wd]: UNSAFE ERROR
def Image.writeWord8 self::Std path::Path backend:
    ```flattenCtx $ liftf3 writeImage #{self} #{path} #{backend}```
    self


def Image.write self path::Path backend:
    self.reprWord8.compose.writeWord8 path backend

def Image.compose self:
    ```flattenCtx $ liftf1 (Pure . RGBA.compose) #{self}```

def Image.decompose self:
    ```flattenCtx $ liftf1 (Pure . RGBA.decompose) #{self}```

def Image.reprDouble self:
    ```liftf1 Image.reprDouble #{self}```

def Image.reprWord8 self:
    ```liftf1 Image.reprWord8 #{self}```

def Image.adjustCB self contrast::Float brightness::Float:
    ```flattenCtx $ liftf3 Mockup.adjustCB #{contrast} #{brightness} #{self}```

def Image.convolve self kernel::Float:
    ```flattenCtx $ liftf2 Mockup.convolve #{kernel} #{self}```

def Image.convertRGBtoHSV self:
    ```flattenCtx $ liftf1 (Pure . Alg.convertRGBtoHSV) #{self}```

def Image.convertHSVtoRGB self:
    ```flattenCtx $ liftf1 (Pure . Alg.convertHSVtoRGB) #{self}```

def Image.get self name::String:
    ```flattenCtx $ liftf2 (Pure `dot2` Image.lookup) #{name} #{self}```

def Image.put self name::String channel:
    ```liftf3 Image.insert #{name} #{channel} #{self}```

def Image.displayP self name::Path:
    b = interp
    self.write name b

def extractBackground self images:
    ```flattenCtx $ liftf1 (Pure . (Alg.extractBackground ("r", "g", "b"))) #{images}```

    
## Channel ####################################


# # FIXME [wd] zrÃ³b to
def Channel.map self callback:
    ```liftf2 Channel.map (val $ (\x -> (fromSafe.fromPure) (call1 #{callback} (val x)))) #{self}```
#     # ```liftf2 channelMap (val $ call1 #{callback}) #{self}```

# def Channel.erode:
#    ```liftf1 erodeChannel #{self}```

## Transformed ################################


def Image.transform self:
    ```val $ Image.transform #{self}```

def Transformed.rasterize self:
    ```flattenCtx $ liftf1 Mockup.rasterize' #{self}```

def Transformed.translate self x::Float y::Float:
    ```liftf3 Image.translate #{x} #{y} #{self}```

def Transformed.rotate self angle::Float:
    ```liftf2 Image.rotate #{angle} #{self}```

def Transformed.rotateAt self angle::Float x::Float y::Float:
    ```liftf4 Image.rotateAt #{angle} #{x} #{y} #{self}```

def Transformed.scale self x::Float y::Float:
    ```liftf3 Image.scale #{self} #{x} #{y}```

def Transformed.scaleAt self sx::Float sy::Float x::Float y::Float:
    ```liftf5 Image.scaleAt #{self} #{sx} #{sy} #{x} #{y}```

def Transformed.adjustCB self contrast::Float brightness::Float:
    ```let { f1 c b self = call2 (member (P :: P "adjustCB") self) c b}```
    ```let { f2 self c b = (fmap.fmap.fmap) (f1 c b) self}```
    ```f2 #{self} #{contrast} #{brightness} ```

def Transformed.convolve self kernel::Float:
    ```let { f1 k self = call1 (member (P :: P "convolve") self) k}```
    ```let { f2 self k = (fmap.fmap.fmap) (f1 k) self}```
    ```f2 #{self} #{kernel} ```

###############################################

def constant self x:
    ```liftf1 A.constant #{x}```


