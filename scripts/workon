#!/usr/bin/env python2.7

###########################################################################
## Copyright (C) Flowbox, Inc / All Rights Reserved
## Unauthorized copying of this file, via any medium is strictly prohibited
## Proprietary and confidential
## Flowbox Team <contact@flowbox.io>, 2014
###########################################################################

import sys
import os.path
import ConfigParser

import psutil
from   copy              import copy, deepcopy
from   config.packages   import pkgDb
from   subprocess        import call, Popen, PIPE
from   utils.colors      import print_info, print_error, print_warning
from   utils.errors      import fatal
from   utils.system      import platformFix, system, systems, osname
from   utils.initialized import checkAndHandleInitialized, markInitialized
import shutil
SILENTINSTALL = False

myPath = os.path.dirname(os.path.realpath(__file__))
rootPath = os.path.dirname(myPath)
sboxName = 'dist'
shellConfPath = os.path.join(myPath, 'shell')
cwd = os.getcwd()
os.chdir(rootPath)


def try_call(cmd):
    print_info("Calling: %s" % cmd)
    if call(cmd, shell=True): fatal()


def flatten(lofl):
    return [val for subl in lofl for val in subl]

def handle_error(e):
    if e:
        print_error(e)
        fatal()

def print_usage():
    print_info ("Usage: workon {%s} [ARGS]" % ", ".join(sorted(pkgDb.keys())))
    sys.exit(0)

def main():
    global SILENTINSTALL
    if '-y' in sys.argv:
        SILENTINSTALL = True

    args = sys.argv
    if len(args) < 2 : print_usage()
    targetStr = sys.argv[1]
    targetSegments = filter(bool, targetStr.replace('\\','/').split('/'))
    target = '/'.join(targetSegments)
    if not target in pkgDb:
        print_error ("Unrecognized target '%s'" % target)
        print_usage ()

    platformFix(sboxName)
    workon(target)

def check_deps(pkg):
    deps = deepcopy(pkg.deps)
    for dep in pkg.deps:
        if not dep in pkgDb:
            print_error ("Configuration error! '%s' could not be found." % dep)
            raise Exception()
        dpkg = pkgDb[dep]
        deps = deepcopy(deps).union(check_deps(dpkg))
    return deps

zdotdir = None  # see notes for system.DARWIN in workon(name) below (grep for OSXWORKAROUND_01)


def workon(name):
    if not checkAndHandleInitialized('dist'):
        print_info ("It seems that sandbox is not initialized. Running scripts/init first.")
        if SILENTINSTALL:
            try_call('python2.7 scripts/init -y')
        else:
            try_call('python2.7 scripts/init')

    print_info("Running gencabal")
    try_call('python2.7 scripts/gencabal')
    
    targets   = []
    project   = pkgDb[name]
    pkgs      = project.targets()
    for pkg in pkgs:

        print_info("Setting environment for '%s' development, under path %s" % (pkg.name, pkg.path))


        targets.append(pkg.path)
        sbox = os.path.join(rootPath, 'dist', pkg.path)
        if not checkAndHandleInitialized(sbox):
            os.makedirs(sbox)
            os.chdir(sbox)
            try_call('cabal sandbox init --sandbox=.')

            try:
                pnames = check_deps(pkg)
            except:
                print_error ("Dependency checking failed.")
                return
            pkg = deepcopy(pkg)
            pnames.add(pkg.path)
            for pname in pnames:
                register(pname)
            markInitialized(sbox)

    os.chdir(rootPath)
    markInitialized('dist')

    if not '--no-shell' in sys.argv:
        fdevWorkon  = os.environ.get("FDEV_WORKON", "")
        fdevHistory = os.environ.get("FDEV_WORKON_HISTORY", "")
        
        if fdevHistory: fdevHistory += " > "
        fdevHistory += name


        os.environ["FDEV_WORKON"] = name
        os.environ["FDEV_WORKON_HISTORY"] = fdevHistory
        os.environ["FDEV_TARGETS"] = ':'.join(targets)

        print_info("The targets are %s" % targets)

        os.chdir(cwd)
        shell = None
        if system == systems.WINDOWS:
            shell     = "cmd.exe"
            shellOpts = "/K prompt ["+fdevHistory+"] %prompt%"
        elif system == systems.LINUX:
            shell = os.readlink('/proc/%d/exe' % os.getppid())
            shellPath = shell.split('/')
            shellOpts = ""
            if 'zsh' in shellPath:
                if not os.environ.has_key('ZDOTDIR_ORIG'):
                    if os.environ.has_key('ZDOTDIR'):
                        zdotdir = os.environ['ZDOTDIR']
                    else:
                        zdotdir = os.path.expanduser('~')
                    os.environ['ZDOTDIR_ORIG'] = zdotdir
                os.environ['ZDOTDIR'] = shellConfPath
            elif 'bash' in shellPath:
                shellOpts = "--rcfile " + os.path.join(shellConfPath, '.bashrc')
            else:
                print_error("Unsupported shell '%s'. There will be no fancy effects :(" % shell)
        elif system == systems.DARWIN:
            shell = psutil.Process(os.getppid()).name()
            shellOpts = ""
            if shell == 'zsh':

                if not os.environ.has_key('ZDOTDIR_ORIG'):
                    if os.environ.has_key('ZDOTDIR'):
                        zdotdir = os.environ['ZDOTDIR']
                    else:
                        zdotdir = os.path.expanduser('~')
                    os.putenv('ZDOTDIR_ORIG', zdotdir)
                os.putenv('ZDOTDIR', shellConfPath)
                
                # =====[ OSXWORKAROUND_01 ]=====
                # From Python 2.7 documentation:
                # NOTE
                #      On some platforms, including FreeBSD and Mac OS X, setting environ may cause memory leaks. Refer to
                #      the system documentation for putenv.
                #
                # From OS X manual:
                # COMPATIBILITY
                #      putenv() no longer copies its input buffer.  This often appears in crash logs as a crash in getenv().
                #      Avoid passing local buffers or freeing the memory that is passed to putenv().  Use setenv(), which
                #      still makes an internal copy of its buffers.
                #
                # So. As long as we don't allow GC to free `shellConfPath` and `zdotdir`, we shall be fine (note that
                # `shellConfPath` is global). That's why there is `zdotdir = None` at global scope.

            else:
                print_error("Unsupported shell '%s'. There will be no fancy effects :(" % shell)
        else:
            print_error("Unsupported platform '%s'. There will be no fancy effects :(" % osname)
        
        if shell:
            print_info("Executing new flowbox '%s' shell" % shell)
            call(shell + " " + shellOpts, shell=True)
        else:
            print_info("NOT executing flowbox shell")

    

def register(name):
    name = name.replace('\\', '/')
    print_info("Registering %s" % name)
    pkg = pkgDb[name]
    pkg.install()


def unregister(name):
    name = name.replace('\\', '/')
    print_info("Unregistering %s" % name)
    pkg = pkgDb[name]
    pkg.uninstall()



main()


