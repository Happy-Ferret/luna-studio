#!/usr/bin/python2.7
import sys
import os.path
import ConfigParser

from copy            import copy, deepcopy
from config.packages import pkgDb
from subprocess      import call, Popen, PIPE
from packages        import pkgDb
from utils.colors    import print_info, print_error, print_warning
from utils.errors    import fatal

myPath = os.path.dirname(os.path.realpath(__file__))
rootPath = os.path.dirname(myPath)
shellConfPath = os.path.join(myPath, 'shell')
cwd = os.getcwd()
os.chdir(rootPath)


def try_call(cmd):
    if call(cmd, shell=True): fatal()


def flatten(lofl):
    return [val for subl in lofl for val in subl]

def handle_error(e):
    if e:
        print_error(e)
        fatal()

def print_usage():
    print_info ("Usage: workon {%s} [ARGS]" % ", ".join(sorted(pkgDb.keys())))
    sys.exit(0)

def main():
    args = sys.argv
    if len(args) < 2 : print_usage()
    targetStr = sys.argv[1]
    targetSegments = filter(bool, targetStr.replace('\\','/').split('/'))
    target = '/'.join(targetSegments)
    print target
    if not target in pkgDb:
        print_error ("Unrecognized target '%s'" % target)
        print_usage ()
    workon(target)

def check_deps(pkg):
    deps = deepcopy(pkg.deps)
    for dep in pkg.deps:
        dpkg = pkgDb[dep]
        deps = deepcopy(deps).union(check_deps(dpkg))
    return deps


def workon(name):
    if not os.path.exists('dist'):
        print_info ("It seems that sandbox is not initialized. Running scripts/init first.")
        try_call('python2.7 scripts/init')

    print_info("Running gencabal")
    try_call('python2.7 scripts/gencabal')
    
    cabalConf = "cabal.config"
    targets   = []
    project   = pkgDb[name]
    pkgs      = project.targets()
    for pkg in pkgs:

        print_info("Setting environment for '%s' development" % pkg.name)
        sbox = os.path.join(rootPath, 'dist', pkg.path)
        targets.append(pkg.path)

        if not os.path.exists(sbox):
            os.makedirs(sbox)
            os.chdir(sbox)
            try_call('cabal sandbox init --sandbox=.')

            pnames = check_deps(pkg)
            pkg = deepcopy(pkg)
            pnames.add(pkg.path)
            for pname in pnames:
                register(pname)

            os.symlink('../../../' + cabalConf, os.path.join(sbox, cabalConf))
    

    fdevWorkon  = os.environ.get("FDEV_WORKON", "")
    fdevHistory = os.environ.get("FDEV_WORKON_HISTORY", "")
    
    if fdevHistory: fdevHistory += " > "
    fdevHistory += name


    os.environ["FDEV_WORKON"] = name
    os.environ["FDEV_WORKON_HISTORY"] = fdevHistory
    os.environ["FDEV_TARGETS"] = ':'.join(targets)


    if not '--no-shell' in sys.argv:
        os.chdir(cwd)
        shell = os.readlink('/proc/%d/exe' % os.getppid())
        shellPath = shell.split('/')
        if 'zsh' in shellPath:
            if not os.environ.has_key('ZDOTDIR_ORIG'):
                if os.environ.has_key('ZDOTDIR'):
                    zdotdir = os.environ['ZDOTDIR']
                else:
                    zdotdir = os.path.expanduser('~')
                os.environ['ZDOTDIR_ORIG'] = zdotdir
            os.environ['ZDOTDIR'] = shellConfPath
        else:
            print_error("Unsupported shell '%s'. There will be no fancy effects :(" % shell)

        print_info("Executing new flowbox '%s' shell" % shell)
        call(shell, shell=True)
    


def register(name):
    print_info("Registering %s" % name)
    pkg = pkgDb[name]
    pkg.install()


def unregister(name):
    print_info("Unregistering %s" % name)
    pkg = pkgDb[name]
    pkg.uninstall()



main()


