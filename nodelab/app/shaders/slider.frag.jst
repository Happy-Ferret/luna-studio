precision mediump float;

uniform float value;
uniform float ticks;
uniform float tickSpan;
uniform float tickOffset;

<%= require('shaders/stdlib')() %>

void main(void) {
    if (objectMap == 1) {
        gl_FragColor = vec4(objectId, 1.0); // TODO: apply actual shape
        return;
    }

    vec3 local   = vec3(luv * size, 0.0);
    vec3 ulocal  = local * dpr;
    vec2 p       = ulocal.xy - size / 2.0;

    float width  = size.x;
    float height = size.y;
    float width1 = width * value;
    float width2 = width * (1.0 - value);
    float radius = height / 2.0;
    float gRect           = sdf_rect(p, vec2(width, height), vec4(radius, radius, radius, radius));
    float gRightHalfplane = sdf_halfplaneRight(translate(p, vec2(-width/2.0 + width1, 0)));

    vec2  tickPos    = vec2(mod(ulocal.x - tickSpan / 2.0 + tickOffset, tickSpan) - tickSpan / 2.0, p.y - (height / 2.0) + (height / 16.0));
    vec2  tickSize   = vec2(height / 8.0, height / 8.0);
    float gTick        = sdf_rect(tickPos, tickSize);
    float gSlider      = sdf_aa(gRect);
    float gSliderRight = sdf_aa(sdf_subtract(gRightHalfplane, gRect));

    vec4 color1 = vec4(0.25, 0.25, 0.25, 1.0);
    vec4 color2 = vec4(0.18, 0.18, 0.18, 1.0);

    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);

    gl_FragColor = mix(color1, gl_FragColor, 1.0 - gSlider);
    gl_FragColor = mix(color2, gl_FragColor, 1.0 - gSliderRight);
    gl_FragColor = mix(vec4(1.0, 1.0, 1.0, 1.0), gl_FragColor, (1.0 - ticks * 0.4 * sdf_aa(sdf_intersect(gRect, gTick))));
}
